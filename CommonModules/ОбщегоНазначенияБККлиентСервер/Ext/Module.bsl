////////////////////////////////////////////////////////////////////////////////
// ОбщегоНазначенияБККлиентСервер:
//  
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// ПРОГРАММНЫЙ ИНТЕРФЕЙС

Функция НовыйКлючСвязиСтрокиТаблицы(Таблица) Экспорт
	
	// Найти максимальный ключ связи.
	МаксКлючСвязи = 0;	
	Для Каждого СтрокаТаблицы Из Таблица Цикл		
		Если МаксКлючСвязи < СтрокаТаблицы.КлючСвязи Тогда
			МаксКлючСвязи = СтрокаТаблицы.КлючСвязи;
		КонецЕсли;
	КонецЦикла;
	
	// Новый ключ связи всегда на единицу больше максимального.
	КлючСвязи = МаксКлючСвязи + 1;
	
	Возврат КлючСвязи;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции общего назначения

// Вычисляет значение идентификатора из строки соответствии с правилами
// именования идентификаторов
//
// Параметры
//  СтрНаименование - строка, которую необходимо преобразовать в идентификатор
// 
// Возвращаемое значение:
//   Строка - идентификатор, соответствующий правилам именования идентификаторов
//
Функция ПолучитьИдентификатор(СтрНаименование) Экспорт
	
	Разделители	=  " .,+,-,/,*,?,=,<,>,(,)%!@#$%&*""№:;{}[]?()\|/`~'^_";
	
	Идентификатор = "";
	БылСпецСимвол = Ложь;
	
	Для НомСимвола = 1 По СтрДлина(СтрНаименование) Цикл
		
		Символ = Сред(СтрНаименование, НомСимвола, 1);
		
		Если Найти(Разделители, Символ) <> 0 Тогда
			БылСпецСимвол = Истина;
		ИначеЕсли БылСпецСимвол Тогда
			БылСпецСимвол = Ложь;
			Идентификатор = Идентификатор + ВРег(Символ);
		Иначе
			Идентификатор = Идентификатор + Символ;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Идентификатор;
	
КонецФункции // ПолучитьИдентификатор()

Процедура ЗаменитьСубконтоНУ(Объект, СчетБУ, СчетНУ, НомерСубконто, СубконтоБУ, ИмяРеквизитаСубконтоНУ = "СубконтоНУ") Экспорт

	Если НЕ ЗначениеЗаполнено(СчетБУ) Тогда
		
		Возврат;
		
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(СчетНУ) Тогда
		
		Возврат;
		
	КонецЕсли;
	
	ДанныеСчетаБУ = ПроцедурыБухгалтерскогоУчетаВызовСервераПовтИсп.ПолучитьСвойстваСчета(СчетБУ);
	
	Если ДанныеСчетаБУ.КоличествоСубконто < НомерСубконто Тогда
		
		Возврат;
		
	КонецЕсли;
	
	ДанныеСчетаНУ = ПроцедурыБухгалтерскогоУчетаВызовСервераПовтИсп.ПолучитьСвойстваСчета(СчетНУ);
	
	НомерСубконтоНУ = Неопределено;
	
	Если ДанныеСчетаНУ.КоличествоСубконто > 0 И ДанныеСчетаНУ.ВидСубконто1 = ДанныеСчетаБУ["ВидСубконто" + НомерСубконто] Тогда
		НомерСубконтоНУ = 1;		
	ИначеЕсли ДанныеСчетаНУ.КоличествоСубконто > 1 И ДанныеСчетаНУ.ВидСубконто2 = ДанныеСчетаБУ["ВидСубконто" + НомерСубконто] Тогда
		НомерСубконтоНУ = 2;		
	ИначеЕсли ДанныеСчетаНУ.КоличествоСубконто > 2 И ДанныеСчетаНУ.ВидСубконто3 = ДанныеСчетаБУ["ВидСубконто" + НомерСубконто] Тогда
		НомерСубконтоНУ = 3;	
	КонецЕсли;
	
	Если НомерСубконтоНУ = Неопределено Тогда

		// по типу
		Для Счетчик = 1 по 3 Цикл			
			Если ДанныеСчетаНУ.КоличествоСубконто >= Счетчик Тогда
				Если ДанныеСчетаНУ["ВидСубконто" + Счетчик + "ТипЗначения"].СодержитТип(ТипЗнч(СубконтоБУ)) Тогда						
					Объект[ИмяРеквизитаСубконтоНУ + Счетчик]= СубконтоБУ;						
				КонецЕсли;
			КонецЕсли;	
		КонецЦикла;				
	Иначе
		Объект[ИмяРеквизитаСубконтоНУ + НомерСубконтоНУ] = СубконтоБУ;						
	КонецЕсли;

КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции работы с ошибками

// Формирует текст сообщения, подставляя значения
// параметров в шаблоны сообщений.
//
// Параметры
//  ВидПоля       - Строка - может принимать значения:
//                  Поле, Колонка, Список
//  ВидСообщения  - Строка - может принимать значения:
//                  Заполнение, Корректность
//  Параметр1     - Строка - имя поля
//  Параметр2     - Строка - номер строки
//  Параметр3     - Строка - имя списка
//  Параметр4     - Строка - текст сообщения о некорректности заполнения
//
// Возвращаемое значение:
//   Строка - текст сообщения
//
Функция ПолучитьТекстСообщения(ВидПоля = "Поле", ВидСообщения = "Заполнение",
	Параметр1 = "", Параметр2 = "",	Параметр3 = "", Параметр4 = "") Экспорт

	ТекстСообщения = "";

	Если ВРег(ВидПоля) = "ПОЛЕ" Тогда
		Если ВРег(ВидСообщения) = "ЗАПОЛНЕНИЕ" Тогда
			Шаблон = НСтр("ru = 'Поле ""%1"" не заполнено'");
		ИначеЕсли ВРег(ВидСообщения) = "КОРРЕКТНОСТЬ" Тогда
			Шаблон = НСтр("ru = 'Поле ""%1"" заполнено некорректно.
                           |
                           |%4'");
		КонецЕсли;
	ИначеЕсли ВРег(ВидПоля) = "КОЛОНКА" Тогда
		Если ВРег(ВидСообщения) = "ЗАПОЛНЕНИЕ" Тогда
			Шаблон = НСтр("ru = 'Не заполнена колонка ""%1"" в строке %2 списка ""%3""'");
		ИначеЕсли ВРег(ВидСообщения) = "КОРРЕКТНОСТЬ" Тогда
			Шаблон = НСтр("ru = 'Некорректно заполнена колонка ""%1"" в строке %2 списка ""%3"".
                           |
                           |%4'");
		КонецЕсли;
	ИначеЕсли ВРег(ВидПоля) = "СПИСОК" Тогда
		Если ВРег(ВидСообщения) = "ЗАПОЛНЕНИЕ" Тогда
			Шаблон = НСтр("ru = 'Не введено ни одной строки в список ""%3""'");
		ИначеЕсли ВРег(ВидСообщения) = "КОРРЕКТНОСТЬ" Тогда
			Шаблон = НСтр("ru = 'Некорректно заполнен список ""%3"".
                           |
                           |%4'");
		КонецЕсли;
	КонецЕсли;

	Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(Шаблон, Параметр1, Параметр2, Параметр3, Параметр4);

КонецФункции // ПолучитьТекстСообщения()

// Функция убирает из текста сообщения служебную информацию
//
// Параметры
//  ТекстСообщения, Строка, исходный текст сообщения//
// Возвращаемое значение:
//   Строка
//
Функция СформироватьТекстСообщения(Знач ТекстСообщения) Экспорт

	НачалоСлужебногоСообщения    = Найти(ТекстСообщения, "{");
	ОкончаниеСлужебногоСообщения = Найти(ТекстСообщения, "}:");

	Если ОкончаниеСлужебногоСообщения > 0
		И НачалоСлужебногоСообщения > 0
		И НачалоСлужебногоСообщения < ОкончаниеСлужебногоСообщения Тогда

		ТекстСообщения = Лев(ТекстСообщения, (НачалоСлужебногоСообщения - 1)) +
		                 Сред(ТекстСообщения, (ОкончаниеСлужебногоСообщения + 2));

	КонецЕсли;

	Возврат СокрЛП(ТекстСообщения);

КонецФункции // ()

Процедура СообщитьОбОшибке(Знач ТекстСообщения, Отказ = Ложь, Заголовок = "", ВызыватьИсключение = Истина) Экспорт

	ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);
	Отказ = Истина;

	#Если ВнешнееСоединение Тогда

		Если ВызыватьИсключение Тогда
			Если ЗначениеЗаполнено(Заголовок) Тогда
				ТекстСообщения = Заголовок + Символы.ПС + ТекстСообщения;
				Заголовок = "";
			КонецЕсли;

			ВызватьИсключение (ТекстСообщения);
		КонецЕсли;

	#Иначе

		Если ЗначениеЗаполнено(Заголовок) Тогда
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю(НСтр(Заголовок));
			Заголовок = "";
		КонецЕсли;

		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения);

	#КонецЕсли

КонецПроцедуры // СообщитьОбОшибке()

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции работы с курсами валют

Функция ПересчитатьИзВалютыВВалюту(Сумма, ВалютаНач, ВалютаКон, ПоКурсуНач, ПоКурсуКон, 
								   ПоКратностьНач = 1, ПоКратностьКон = 1 ) Экспорт

	Если (ВалютаНач = ВалютаКон) Тогда

		// Считаем, что пересчет не нужен.
		Возврат Сумма;

	КонецЕсли;

	Если (ПоКурсуНач     = ПоКурсуКон) 
	   И (ПоКратностьНач = ПоКратностьКон) Тогда

		// ну, тут и считать нечего...
		Возврат Сумма;

	КонецЕсли;
	
	// Проверка установки значений
	ПризнакОшибки = Ложь;
	Если ПоКурсуНач     = 0  Тогда
		ОбщегоНазначенияБККлиентСервер.СообщитьОбОшибке(СтрШаблон(НСтр("ru = 'При пересчете валютных сумм обнаружен нулевой курс валюты: %1'"), СокрЛП(ВалютаНач)));
		ПризнакОшибки = Истина;
	КонецЕсли;
	
	Если ПоКурсуКон     = 0  Тогда
		ОбщегоНазначенияБККлиентСервер.СообщитьОбОшибке(СтрШаблон(НСтр("ru = 'При пересчете валютных сумм обнаружен нулевой курс валюты: %1'"), СокрЛП(ВалютаКон)));
		ПризнакОшибки = Истина;
	КонецЕсли;
	
	Если ПоКратностьНач = 0  Тогда
		ОбщегоНазначенияБККлиентСервер.СообщитьОбОшибке(СтрШаблон(НСтр("ru = 'При пересчете валютных сумм обнаружена нулевая кратность валюты: %1'"), СокрЛП(ВалютаНач)));
		ПризнакОшибки = Истина;
	КонецЕсли;
	
	Если ПоКратностьКон = 0  Тогда
		ОбщегоНазначенияБККлиентСервер.СообщитьОбОшибке(СтрШаблон(НСтр("ru = 'При пересчете валютных сумм обнаружена нулевая кратность валюты: %1'"), СокрЛП(ВалютаКон)));
		ПризнакОшибки = Истина;
	КонецЕсли;
	
	Если ПризнакОшибки Тогда
		Возврат 0;          
	КонецЕсли;

	Возврат Окр((Сумма * ПоКурсуНач * ПоКратностьКон) / (ПоКурсуКон * ПоКратностьНач), 2);

КонецФункции // ПересчитатьИзВалютыВВалюту()

// Пересчитывает Сумму из Текущей валюты в Новую валюту по параметрам их курсов. 
//   Параметры курсов валют можно получить воспользовавшись функцией 
//   РаботаСКурсамиВалют.ПолучитьКурсВалюты(Валюта, ДатаКурса).
// 
// Параметры:
//   Сумма                  (Число)     Сумма, которую следует пересчитать
//   ПараметрыТекущегоКурса (Структура) Параметры курса валюты, из которой надо пересчитать
//       |- Валюта    (СправочникСсылка.Валюты)
//       |- Курс      (Число)
//       |- Кратность (Число)
//   ПараметрыНовогоКурса   (Структура) Параметры курса валюты, в  которую надо пересчитать
//       |- Валюта    (СправочникСсылка.Валюты)
//       |- Курс      (Число)
//       |- Кратность (Число)
// 
// Возвращаемое значение: 
//   (Число) Сумма, пересчитанная в другую валюту
// 
Функция ПересчитатьПоКурсу(Сумма, ПараметрыТекущегоКурса, ПараметрыНовогоКурса) Экспорт
	Если ПараметрыТекущегоКурса.Валюта = ПараметрыНовогоКурса.Валюта
		ИЛИ (
			ПараметрыТекущегоКурса.Курс = ПараметрыНовогоКурса.Курс 
			И ПараметрыТекущегоКурса.Кратность = ПараметрыНовогоКурса.Кратность
		) Тогда
		
		Возврат Сумма;
		
	КонецЕсли;
	
	Если ПараметрыТекущегоКурса.Курс = 0
		ИЛИ ПараметрыТекущегоКурса.Кратность = 0
		ИЛИ ПараметрыНовогоКурса.Курс = 0
		ИЛИ ПараметрыНовогоКурса.Кратность = 0 Тогда
		
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
			СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
				НСтр("ru = 'При пересчете в валюту %1 сумма %2 установлена в нулевое значение, т.к. курс валюты не задан.'"), 
				ПараметрыНовогоКурса.Валюта, 
				Формат(Сумма, "ЧДЦ=2; ЧН=0")));
		
		Возврат 0;
		
	КонецЕсли;
	
	Возврат Окр((Сумма * ПараметрыТекущегоКурса.Курс * ПараметрыНовогоКурса.Кратность) / (ПараметрыНовогоКурса.Курс * ПараметрыТекущегоКурса.Кратность), 2);
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции работы с типами

// Служебная функция, предназначенная для получения описания типов числа, заданной разрядности.
// 
// Параметры:
//  Разрядность 			- число, разряд числа.
//  РазрядностьДробнойЧасти - число, разряд дробной части.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для числа указанной разрядности.
//
Функция ПолучитьОписаниеТиповЧисла(Разрядность,РазрядностьДробнойЧасти=0) Экспорт

	Массив = Новый Массив;

	Массив.Добавить(Тип("Число"));
	КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность,РазрядностьДробнойЧасти);

	Возврат Новый ОписаниеТипов(Массив, КвалификаторЧисла);

КонецФункции // ПолучитьОписаниеТиповЧисла() 

// Служебная функция, предназначенная для получения описания типов строки, заданной длины.
//
// Параметры:
//  ДлинаСтроки - число, длина строки.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для строки указанной длины.
//
Функция ПолучитьОписаниеТиповСтроки(ДлинаСтроки) Экспорт

	Массив = Новый Массив;
	Массив.Добавить(Тип("Строка"));

	КвалификаторСтроки = Новый КвалификаторыСтроки(ДлинаСтроки, ДопустимаяДлина.Переменная);

	Возврат Новый ОписаниеТипов(Массив, , КвалификаторСтроки);

КонецФункции // ПолучитьОписаниеТиповСтроки()

// Служебная функция, предназначенная для получения описания типов даты
//
// Параметры:
//  ЧастиДаты - системное перечисление ЧастиДаты.
//
Функция ПолучитьОписаниеТиповДаты(ЧастиДаты) Экспорт

	Массив = Новый Массив;
	Массив.Добавить(Тип("Дата"));

	КвалификаторДаты = Новый КвалификаторыДаты(ЧастиДаты);

	Возврат Новый ОписаниеТипов(Массив, , , КвалификаторДаты);

КонецФункции // ПолучитьОписаниеТиповДаты()

///////////////////////////////////////////////////////////////////////////////
// Процедуры и функции работы с функциональными опциями

Процедура УстановитьПараметрОрганизацияФункциональныхОпцийФормы(Форма, Организация, Период = Неопределено) Экспорт

	ПараметрыФО = Новый Структура();
	ПараметрыФО.Вставить("Организация", Организация);
	Если Период <> Неопределено Тогда
		ПараметрыФО.Вставить("Период", НачалоМесяца(Период));
		// Приводим к началу месяца для того, чтобы сократить пространство кэшируемых значений.
		// Параметр "Организация" используется в функциональных опциях, привязанных к регистрам сведений с периодичностью Месяц или реже.
	КонецЕсли;
	
	Форма.УстановитьПараметрыФункциональныхОпцийФормы(ПараметрыФО);
	
КонецПроцедуры

Процедура УстановитьПараметрыФункциональныхОпцийФормыДокумента(Форма) Экспорт
	
	УстановитьПараметрОрганизацияФункциональныхОпцийФормы(Форма, Форма.Объект.Организация, Форма.Объект.Дата);
	
КонецПроцедуры

///////////////////////////////////////////////////////////////////////////////
// Процедуры и функции работы с ценами и валютами.

// Возвращает текст надписи "Цены и валюта".
//
// Параметры:
//  ДанныеДокумента - Структура, ДанныеФормыСтруктура - Структура реквизитов, 
//   по которым будет формироваться текст надписи "Цены и валюта".
//
// Возвращаемое значение:
//  Строка - Текст надписи "Цены и валюта". 
//
// Пример:
//  ЦеныИВалюта = ОбщегоНазначенияБККлиентСервер.СформироватьНадписьЦеныИВалюта(ЭтаФорма.Объект);
//
Функция СформироватьНадписьЦеныИВалюта(ДанныеДокумента, ЭтоДокументРозничнойТорговли = Ложь) Экспорт
	
	ТекстНадписи = Новый Массив;
	
	// Валюта
	Если Не ЭтоДокументРозничнойТорговли И ОбщегоНазначенияБКВызовСервера.ИспользоватьВалютныйУчет() Тогда
		
		ВалютаДокумента = Неопределено;
		
		Если ДанныеДокумента.Свойство("ВалютаДокумента", ВалютаДокумента) Тогда
			
			Если ЗначениеЗаполнено(ВалютаДокумента) Тогда
				
				ВалютаУчета = ОбщегоНазначенияБКВызовСервераПовтИсп.ПолучитьВалютуРегламентированногоУчета();
				
				Если ВалютаДокумента = ВалютаУчета Тогда
					ТекстНадписи.Добавить(Строка(ВалютаДокумента));
					
				Иначе
					Курс      = Неопределено;
					Кратность = Неопределено;
					
					Если ДанныеДокумента.Свойство("КурсВзаиморасчетов", Курс) И ДанныеДокумента.Свойство("КратностьВзаиморасчетов", Кратность) Тогда // не во всех документах есть курс и кратность взаиморасчетов
						ТекстНадписи.Добавить(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку("%1 %2 = %3 %4", Кратность, ВалютаДокумента, Курс, ВалютаУчета));
					ИначеЕсли ДанныеДокумента.Свойство("КурсДокумента", Курс) И ДанныеДокумента.Свойство("КратностьДокумента", Кратность) Тогда // в документах где нет курса и кратности взаиморасчетов заполним надпись по курсу и кратности документа
						ТекстНадписи.Добавить(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку("%1 %2 = %3 %4", Кратность, ВалютаДокумента, Курс, ВалютаУчета));
					Иначе
						ТекстНадписи.Добавить(Строка(ВалютаДокумента));
					КонецЕсли;
				КонецЕсли;
				
			Иначе
				
				ТекстНадписи.Добавить(НСтр("ru = 'Валюта: <нет>'"));
				
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЕсли;
	
	// Тип цен
	Если ОбщегоНазначенияБКВызовСервера.ИспользоватьТипыЦенНоменклатуры() Тогда
		
		ТипЦен = Неопределено;
		
		Если ДанныеДокумента.Свойство("ТипЦен", ТипЦен) Тогда
			Если Не ЗначениеЗаполнено(ТипЦен) Тогда
				ТипЦен = НСтр("ru = '<не указан>'");
			КонецЕсли;
			ТекстНадписи.Добавить(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Тип цен: %1'"), ТипЦен));
		КонецЕсли;
		
	КонецЕсли;
	
	// НДС
	УчитыватьНДС               = Неопределено;
	СуммаВключаетНДС           = Неопределено;
	НДСВключенВСтоимость       = Неопределено;
	ОтложитьПринятиеНДСКЗачету = Неопределено;
	ОтложитьНачислениеНДС      = Неопределено;
	
	ДанныеДокумента.Свойство("УчитыватьНДС"               , УчитыватьНДС);
	ДанныеДокумента.Свойство("СуммаВключаетНДС"           , СуммаВключаетНДС);
	ДанныеДокумента.Свойство("НДСВключенВСтоимость"       , НДСВключенВСтоимость);
	ДанныеДокумента.Свойство("ОтложитьПринятиеНДСКЗачету" , ОтложитьПринятиеНДСКЗачету);
	ДанныеДокумента.Свойство("ОтложитьНачислениеНДС"      , ОтложитьНачислениеНДС);
	
	Если УчитыватьНДС = Истина Тогда
		
		ПризнакиНДС = Новый Массив;
		
		Если СуммаВключаетНДС = Истина Тогда
			ПризнакиНДС.Добавить(НСтр("ru = 'в т.ч.'"));
		ИначеЕсли СуммаВключаетНДС = Ложь Тогда
			ПризнакиНДС.Добавить(НСтр("ru = 'сверху'"));
		КонецЕсли;
		
		Если ОтложитьПринятиеНДСКЗачету = Истина Или ОтложитьНачислениеНДС = Истина Тогда
			ПризнакиНДС.Добавить(НСтр("ru = 'отложен'"));
		КонецЕсли;
		
		Если НДСВключенВСтоимость = Истина Тогда
			ПризнакиНДС.Добавить(НСтр("ru = 'включен в стоимость'"));
		КонецЕсли;
		
		Если ПризнакиНДС.Количество() Тогда
			ТекстНадписи.Добавить(СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'НДС (%1)'"), СтрСоединить(ПризнакиНДС, ", ")));
		КонецЕсли;
		
	ИначеЕсли УчитыватьНДС = Ложь Тогда
		
		ТекстНадписи.Добавить(НСтр("ru = 'Не учитывать НДС'"));
		
	КонецЕсли;
	
	// Акциз
	УчитыватьАкциз     = Неопределено;
	СуммаВключаетАкциз = Неопределено;
	
	ДанныеДокумента.Свойство("УчитыватьАкциз"    , УчитыватьАкциз);
	ДанныеДокумента.Свойство("СуммаВключаетАкциз", СуммаВключаетАкциз);
	
	Если УчитыватьАкциз = Истина Тогда
		Если СуммаВключаетАкциз = Истина Тогда
			ТекстНадписи.Добавить(НСтр("ru = 'Акциз (в т.ч.)'"));
		ИначеЕсли СуммаВключаетАкциз = Ложь Тогда
			ТекстНадписи.Добавить(НСтр("ru = 'Акциз (сверху)'"));
		КонецЕсли;
	КонецЕсли;
	
	Возврат СтрСоединить(ТекстНадписи, ", ")
	
КонецФункции

//////////////////////////////////////////////////////////////////////////////////
// Процедуры и функции работы с массивами

// Функция выполняет пропорциональное распределение суммы в соответствии
// с заданными коэффициентами распределения
//
// Параметры:
//  ИсхСумма   - распределяемая сумма
//  МассивКоэф - массив коэффициентов распределения
//  Точность   - точность округления при распределении. Необязателен.
//
//Возвращает:
//  МассивСумм - массив размерностью равный массиву коэффициентов, содержит
//               суммы в соответствии с весом коэффициента (из массива коэффициентов)
//               В случае если распределить не удалось (сумма = 0, кол-во коэф. = 0,
//               или суммарный вес коэф. = 0), тогда возвращается значение Неопределено
//
Функция РаспределитьПропорционально(Знач ИсхСумма, МассивКоэф, Знач Точность = 2, ПроверкаНулевыхЗначений=Истина) Экспорт

	Если МассивКоэф.Количество() = 0 Или (ПроверкаНулевыхЗначений И ИсхСумма = 0) Или ИсхСумма = Null Тогда
		Возврат Неопределено;
	КонецЕсли;

	ИндексМакс = 0;
	МаксЗнач   = 0;
	РаспрСумма = 0;
	СуммаКоэф  = 0;

	Для К = 0 По МассивКоэф.Количество() - 1 Цикл

		МодульЧисла = ?(МассивКоэф[К] > 0, МассивКоэф[К], - МассивКоэф[К]);

		Если МаксЗнач < МодульЧисла Тогда
			МаксЗнач   = МодульЧисла;
			ИндексМакс = К;
		КонецЕсли;

		СуммаКоэф = СуммаКоэф + МассивКоэф[К];

	КонецЦикла;

	Если СуммаКоэф = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;

	МассивСумм = Новый Массив(МассивКоэф.Количество());

	Для К = 0 По МассивКоэф.Количество() - 1 Цикл
		МассивСумм[К] = Окр(ИсхСумма * МассивКоэф[К] / СуммаКоэф, Точность, 1);
		РаспрСумма    = РаспрСумма + МассивСумм[К];
	КонецЦикла;

	// Погрешности округления отнесем на коэффицент с максимальным весом
	Если Не РаспрСумма = ИсхСумма Тогда
		МассивСумм[ИндексМакс] = МассивСумм[ИндексМакс] + ИсхСумма - РаспрСумма;
	КонецЕсли;

	Возврат МассивСумм;

КонецФункции // РаспределитьПропорционально()

// Удаление из массива пустых элементов
//
// Параметры:
//   Массив - Массив - массив элементов для обработки
//
Процедура УдалитьНеЗаполненныеЭлементыМассива(Массив) Экспорт

	Количество = Массив.Количество();
	Для Индекс = 1 По Количество Цикл
		Если НЕ ЗначениеЗаполнено(Массив[Количество - Индекс]) Тогда
			Массив.Удалить(Количество - Индекс);
		КонецЕсли;
	КонецЦикла;

КонецПроцедуры

//////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ОБРАБОТКИ СТРОК

// Функция преобразует ФИО из именительного падежа в дательный
// Параметры: 
//  СтруктураФИО - тип,Структура, ключи которой должны быть:
//		Фамилия  - значение должна соответствовать фамилии,
//		Имя      - значение должна соответствовать имени,
//		Отчество - значение должна соответствовать отчеству,
//  НеСклонятьФамилию - признак, типа Булево, по котрому опредеяем нужно склонять фамилию или нет
// Возвращаемое значение:
//	ФИО1 - Полное имя в формате "Фамилия Имя Отчество" в дательном падеже
// 
Функция ПреобразоватьФИОВДательныйПадеж(СтруктураФИО, НеСклонятьФамилию = Ложь, Пол = Неопределено) Экспорт 
	Перем Фамилия, Имя, Отчество;
	
	Фамилия ="";
	Имя = "";
	Отчество = ""; 
	ФИО = "";
		 	
	Если ТипЗнч(СтруктураФИО) = Тип("Структура") Тогда
		СтруктураФИО.Свойство("Фамилия", Фамилия);
		СтруктураФИО.Свойство("Имя", Имя);
		СтруктураФИО.Свойство("Отчество",Отчество);
	Иначе
		Возврат "";
	КонецЕсли;
		
	ОбщДлина = СтрДлина(Фамилия) + СтрДлина(Имя)+ СтрДлина(Отчество);
						
	//Проверим фио на пустоту
	Если ОбщДлина = 0 Тогда
		Фио1 = "";
		Возврат ФИО1;
	КонецЕсли;	

	ФИО = НРег(Фамилия + " " + Имя + " " + Отчество);
	
	// поделим на фамилию, имя и очество
	// позиция первого пробела
	ПервПроб = Найти(ФИО," ");
	Если ПервПроб = 0 Тогда
		Фамилия = СокрЛ(ФИО);
	Иначе
		Фамилия = Лев(ФИО,ПервПроб);
		ИО = Сред(ФИО,ПервПроб+1);
		ИО = СокрЛП(ИО);
		// позиция второго пробела
		ВтПроб = Найти(ИО," ");
		Если ВтПроб = 0 Тогда
			Имя = СокрЛП(ИО);
		Иначе
			Имя = СокрЛ(Лев(ИО,ВтПроб-1));
			Отчество = СокрЛ((Сред(ИО,ВтПроб+1)));
		КонецЕсли;
	КонецЕсли;    
	
	//определяем род  
	ДлинаОтчества = СтрДлина(СокрЛП(Отчество));
	ПослСимвОтч   = Сред(Отчество,ДлинаОтчества,1);
	
	//определим пол
	Если Пол <> Неопределено И ДлинаОтчества = 0 Или ПослСимвОтч = "." Тогда 
		МужскойПол = ПредопределенноеЗначение("Перечисление.ПолФизическихЛиц.Мужской");
		Если Пол = МужскойПол Тогда 
			Мужской = 1;
		Иначе 
			Мужской = 0;
		КонецЕсли;
	Иначе 
		Если ПослСимвОтч = "ч" ИЛИ Найти("ұлы, улы", Прав(Отчество, 3)) > 0 Тогда
			Мужской = 1;
		Иначе 
			Мужской = 0;
		КонецЕсли;
	КонецЕсли;
	
	
	Если Мужской = 1 Тогда   		
		//Проверим фамилию на вхождение точки т.е. на сокрашенния, если есть то не склоняем
		Если Найти(Фамилия,".") <> 0 Тогда
			Фамилия1 = СокрЛП(Фамилия);
		Иначе
			Если НеСклонятьФамилию Тогда
				Фамилия1 = СокрЛП(Фамилия);
			Иначе
				//фамилия
				ДлинаФам = СтрДлина(СокрЛП(Фамилия));
				ПослСимвФам = Сред(Фамилия,ДлинаФам,1);
				Если (ПослСимвФам = "о") ИЛИ (ПослСимвФам = "и") ИЛИ (ПослСимвФам = "х") ИЛИ (ПослСимвФам = "я") ИЛИ (ПослСимвФам = "а") Тогда
					//в этом случае не скланяеться  	
					Фамилия1 = Фамилия;
				ИначеЕсли (ПослСимвФам = "й") Тогда 
					Если Сред(Фамилия, ДлинаФам-1, 1) = "е" Тогда
						//для фамилий типа МАРЦЕФЕЙ
						Фамилия1 = Фамилия;    
					Иначе
						//обрезаем 2 символа и прибавляем "ому"	
						ФамилияОбрезанная = Сред(Фамилия, 1, ДлинаФам-2);
						Фамилия1 = ФамилияОбрезанная + "ому";
					КонецЕсли;
				Иначе  
					//прибавляем "у"	
					Фамилия1 = СокрЛП(Фамилия) + "у";
				КонецЕсли; 
			КонецЕсли;
		КонецЕсли;
		
		//имя 
		//Проверим имя на вхождение точки т.е. на сокрашенния, если есть то не склоняем
		Если Найти(Имя,".") <> 0 Тогда
			Имя1 = СокрЛП(Имя);
		Иначе
			ДлинаИмени = СтрДлина(СокрЛП(Имя));
			//проверем составное ли имя:
			НомерПозиции =Найти(Имя,"-");
			КоличествоИмен = 1;
			Имя1="";
			Если  НомерПозиции > 0 Тогда
				//это составное имя
				СтруктураИмен = Новый Структура;
				Имя_1 = СокрЛП(Сред(Имя,1,НомерПозиции-1));		
				Имя_2 = СокрЛП(Сред(Имя,НомерПозиции+1,ДлинаИмени));
				СтруктураИмен.Вставить("Имя_1", Имя_1);
				СтруктураИмен.Вставить("Имя_2", Имя_2);
				КоличествоИмен = 2;
			КонецЕсли;
			
			Для НомерИмени =1 По КоличествоИмен  Цикл
				Если КоличествоИмен = 1 Тогда
					Имя = Имя;
					СоеденительнаяИмен = "";
				Иначе
					ИмяКлюча = "Имя_" + Строка(НомерИмени);
					СоеденительнаяИмен = "-";
					СтруктураИмен.Свойство(ИмяКлюча, Имя);
				КонецЕсли;
				ДлинаИмени = СтрДлина(СокрЛП(Имя));
				Если ДлинаИмени <> 0 Тогда 			
					
					ПослСимвИмени = Сред(СокрЛП(Имя), ДлинаИмени, 1);
					
					Если (ПослСимвИмени = "й") ИЛИ (ПослСимвИмени = "ь") Тогда 
						//обрезаем 1 символ и прибавляем "ю"	
						ИмяОбрезанное = СокрЛП(Сред(СокрЛП(Имя), 1, ДлинаИмени-1));
						Имя1 = Имя1 + Врег(Лев(ИмяОбрезанное,1)) + Сред(ИмяОбрезанное,2)  + "ю";
					ИначеЕсли (ПослСимвИмени = "я") ИЛИ (ПослСимвИмени = "а") Тогда 
						//обрезаем 1 символ и прибавляем "е"	
						ИмяОбрезанное = СокрЛП(Сред(СокрЛП(Имя), 1, ДлинаИмени-1));
						Имя1 = Имя1 + Врег(Лев(ИмяОбрезанное,1)) + Сред(ИмяОбрезанное,2)  + "е";
					Иначе
						//прибавляем "у"
						Имя = СокрЛП(Имя); 
						Имя1 = Имя1 + Врег(Лев(Имя,1)) + Сред(Имя,2)  + "у";
					КонецЕсли;
				КонецЕсли;
				Если НомерИмени  = 1 Тогда
					Имя1= Имя1 +  СоеденительнаяИмен;
				КонецЕсли;  				
			КонецЦикла;  		 		
		КонецЕсли;
		
		//отчество  
		//Проверим отчество на вхождение точки т.е. на сокрашенния, если есть то не склоняем
		Если Найти(Отчество,".") <> 0 Тогда
			Отчество1 = СокрЛП(Отчество);
		Иначе 
			//прибавляем "у"	
			Если Найти("ұлы, улы", Прав(Отчество,3)) = 0 Тогда
				Отчество1 = СокрЛП(Отчество) + "у";
			Иначе
				Отчество1 = Отчество;
			КонецЕсли;
		КонецЕсли;
		
	ИначеЕсли Мужской = 0 Тогда
		//Проверим фамилию на вхождение точки т.е. на сокрашенния, если есть то не склоняем
		Если Найти(Фамилия,".") <> 0 Тогда
			Фамилия1 = СокрЛП(Фамилия);
		Иначе
			Если НеСклонятьФамилию Тогда
				Фамилия1 = СокрЛП(Фамилия);
			Иначе  			
				//фамилия
				ДлинаФам = СтрДлина(СокрЛП(Фамилия));
				ПослСимвФам = Сред(Фамилия,ДлинаФам,1);
				Если (ПослСимвФам = "о") ИЛИ (ПослСимвФам = "и") ИЛИ (ПослСимвФам = "х") ИЛИ (ПослСимвФам = "ч") ИЛИ (ПослСимвФам = "б") 
					ИЛИ  (ПослСимвФам = "в") ИЛИ (ПослСимвФам = "г") ИЛИ (ПослСимвФам = "д") ИЛИ (ПослСимвФам = "ж") ИЛИ (ПослСимвФам = "з")
					ИЛИ  (ПослСимвФам = "п") ИЛИ (ПослСимвФам = "н") ИЛИ (ПослСимвФам = "м") ИЛИ (ПослСимвФам = "л") ИЛИ (ПослСимвФам = "к")
					ИЛИ  (ПослСимвФам = "р") ИЛИ (ПослСимвФам = "с") ИЛИ (ПослСимвФам = "т") ИЛИ (ПослСимвФам = "ф") ИЛИ (ПослСимвФам = "ц")
					ИЛИ  (ПослСимвФам = "ь") ИЛИ (ПослСимвФам = "щ") ИЛИ (ПослСимвФам = "ш")   Тогда
					//в этом случае не склоняется  	
					Фамилия1 = СокрЛП(Фамилия);
				ИначеЕсли (ПослСимвФам = "я") Тогда 
					//обрезаем 2 символа и прибавляем "ой"	
					ФамилияОбрезанная = Сред(Фамилия, 1, ДлинаФам - 2);
					Фамилия1 = СокрЛП(ФамилияОбрезанная) + "ой";
				Иначе  
					//обрезаем 1 символа и прибавляем "ой"	
					ФамилияОбрезанная = Сред(Фамилия, 1, ДлинаФам - 1);
					Фамилия1 = СокрЛП(ФамилияОбрезанная) + "ой";
				КонецЕсли; 
			КонецЕсли;   		
		КонецЕсли;
				
		//имя    	
		//Проверим имя на вхождение точки т.е. на сокрашенния, если есть то не склоняем
		Если Найти(Имя,".") <> 0 Тогда
			Имя1 = СокрЛП(Имя);
		Иначе 	
			НомерПозиции =Найти(Имя,"-");
			ДлинаИмени = СтрДлина(СокрЛП(Имя));
			КоличествоИмен = 1;
			Имя1="";
			Если  НомерПозиции > 0 Тогда
				//это составное имя, например  Мария-Тереза
				СтруктураИмен = Новый Структура;
				Имя_1 = СокрЛП(Сред(Имя,1,НомерПозиции-1));		
				Имя_2 = СокрЛП(Сред(Имя,НомерПозиции+1,ДлинаИмени));
				СтруктураИмен.Вставить("Имя_1", Имя_1);
				СтруктураИмен.Вставить("Имя_2", Имя_2);
				КоличествоИмен = 2;
			КонецЕсли;
			
			Для НомерИмени =1 По КоличествоИмен  Цикл
				Если КоличествоИмен = 1 Тогда
					Имя = Имя;
					СоеденительнаяИмен = "";
				Иначе
					ИмяКлюча = "Имя_" + Строка(НомерИмени);
					СоеденительнаяИмен = "-";
					СтруктураИмен.Свойство(ИмяКлюча, Имя);
				КонецЕсли;
				ДлинаИмени = СтрДлина(СокрЛП(Имя));
				
				Если ДлинаИмени <> 0 Тогда  
					
					ПослСимвИмени = Сред(СокрЛП(Имя), ДлинаИмени, 1);
					ПредПослСимвИмени = Сред(СокрЛП(Имя), ДлинаИмени - 1, 1);
					Если (ПослСимвИмени = "а") ИЛИ (ПослСимвИмени = "я") Тогда
						//в этом случае разбиваем на два
						Если (ПредПослСимвИмени = "и") Тогда
							//обрезаем 1 символ и прибавляем "и"	
							ИмяОбрезанное = СокрЛП(Сред(СокрЛП(Имя), 1, ДлинаИмени - 1));
							Имя1 = Имя1 + ВРег(Лев(ИмяОбрезанное,1)) + Сред(ИмяОбрезанное,2) + "и";
						Иначе
							//обрезаем 1 символ и прибавляем "е"	
							ИмяОбрезанное = СокрЛП(Сред(СокрЛП(Имя), 1, ДлинаИмени - 1));
							Имя1 = Имя1 + ВРег(Лев(ИмяОбрезанное,1)) + Сред(ИмяОбрезанное,2) + "е";
						КонецЕсли; 
					ИначеЕсли (ПослСимвИмени = "ь") Тогда 
						//обрезаем 1 символ и прибавляем "и"	
						ИмяОбрезанное = СокрЛП(Сред(СокрЛП(Имя), 1, ДлинаИмени - 1));
						Имя1 = Имя1 + ВРег(Лев(ИмяОбрезанное,1)) + Сред(ИмяОбрезанное,2) + "и";
					Иначе  
						//не изменяется	
						Имя = СокрЛП(Имя);
						Имя1 = Имя1 + Врег(Лев(Имя,1)) + Сред(Имя,2);
					КонецЕсли;
				КонецЕсли;
				Если НомерИмени = 1 Тогда
					Имя1 = Имя1 + СоеденительнаяИмен;
				КонецЕсли;     			
			КонецЦикла;
		КонецЕсли;
	
		
		//Проверим отчество на вхождение точки т.е. на сокрашенния, если есть то не склоняем
		Если Найти(Отчество,".") <> 0 Тогда
			Отчество1 = СокрЛП(Отчество);
		Иначе 
			//отчество 
			//обрезаем 1 символа и прибавляем "е"	
			Если СтрДлина(СокрЛП(Отчество)) > 0 И Найти("кызы, қызы", Прав(Отчество, 4)) = 0 Тогда
				ОтчествоОбрезанное = Сред(Отчество, 1, ДлинаОтчества-1);
				Отчество1 = СокрЛП(ОтчествоОбрезанное) + "е";
			Иначе
				Отчество1 = Отчество;
			КонецЕсли;
		КонецЕсли;
		
	КонецЕсли;	
	
	ФИО1 = ВРег(Лев(Фамилия1,1)) + Сред(Фамилия1, 2)+ " " +
		   ВРег(Лев(Имя1,1)) + Сред(Имя1, 2) + " " +
		   ВРег(Лев(Отчество1,1)) + Сред(Отчество1, 2); 

	Возврат ФИО1;

КонецФункции //ПреобразоватьФИОВДательныйПадеж

// Функция преобразует ФИО из именительного падежа в родительный
// Параметры: 
//  СтруктураФИО - тип,Структура, ключи которой должны быть:
//		Фамилия  - значение должна соответствовать фамилии,
//		Имя      - значение должна соответствовать имени,
//		Отчество - значение должна соответствовать отчеству,
// Возвращаемое значение:  
//	ФИО1 - Полное имя в формате "Фамилия Имя Отчество" в родительном падеже
//
Функция ПреобразоватьФИОВРодительныйПадеж(СтруктураФИО, НеСклонятьФамилию = Ложь) Экспорт 
	Перем Фамилия, Имя, Отчество;
	
	Фамилия ="";
	Имя = "";
	Отчество = ""; 
	ФИО = "";
	
	
	Если ТипЗнч(СтруктураФИО) = Тип("Структура") Тогда
		СтруктураФИО.Свойство("Фамилия", Фамилия);
		СтруктураФИО.Свойство("Имя", Имя);
		СтруктураФИО.Свойство("Отчество",Отчество);
	Иначе
		Возврат "";
	КонецЕсли;
		
	ОбщДлина = СтрДлина(Фамилия) + СтрДлина(Имя)+ СтрДлина(Отчество);
	
	//Проверим фио на пустоту
	Если ОбщДлина = 0 Тогда
		Фио1 = "";
		Возврат ФИО1;
	КонецЕсли;	
	
	ФИО  	 = НРег(Фамилия + " " + Имя + " " + Отчество);
	
	//поделим на фамилию, имя и очество
	// позиция первого пробела
	ПервПроб = Найти(ФИО," ");
	Если ПервПроб = 0 Тогда
		Фамилия = СокрЛ(ФИО);
	Иначе
		Фамилия = Лев(ФИО,ПервПроб);
		ИО = Сред(ФИО,ПервПроб+1);
		ИО = СокрЛП(ИО);
		// позиция второго пробела
		ВтПроб = Найти(ИО," ");
		Если ВтПроб = 0 Тогда
			Имя = СокрЛП(ИО);
		Иначе
			Имя = СокрЛ(Лев(ИО,ВтПроб-1));
			Отчество = СокрЛ((Сред(ИО,ВтПроб+1)));
		КонецЕсли;
	КонецЕсли;    
	
	//Проверим остаток на вхождение точки т.е. на сокрашенния, 
	//если есть то дальше скланяем только фамилию
	Если Найти(ИО,".") <> 0 И Не НеСклонятьФамилию Тогда
		ДлинаФам = СтрДлина(СокрЛП(Фамилия));
		ПослСимвФам = Сред(Фамилия, ДлинаФам, 1);
		
		Если (ПослСимвФам = "а") или (ПослСимвФам = "я") Тогда  
			//женский род
			Если (ПослСимвФам = "о") или (ПослСимвФам = "и") или (ПослСимвФам = "х") или (ПослСимвФам = "ч") или (ПослСимвФам = "б") 
				или  (ПослСимвФам = "в") или (ПослСимвФам = "г") или (ПослСимвФам = "д") или (ПослСимвФам = "ж") или (ПослСимвФам = "з")
				или  (ПослСимвФам = "п") или (ПослСимвФам = "н") или (ПослСимвФам = "м") или (ПослСимвФам = "л") или (ПослСимвФам = "к")
				или  (ПослСимвФам = "р") или (ПослСимвФам = "с") или (ПослСимвФам = "т") или (ПослСимвФам = "ф") или (ПослСимвФам = "ц")
				или  (ПослСимвФам = "ь") или (ПослСимвФам = "щ") или (ПослСимвФам = "ш")   Тогда
				//в этом случае не склоняется  	
				Фамилия1 = СокрЛП(Фамилия);
			ИначеЕсли (ПослСимвФам = "я") Тогда 
				//обрезаем 2 символа и прибовляем "ой"	
				ФамилияОбрезанная = Сред(Фамилия,1,ДлинаФам-2);
				Фамилия1 = СокрЛП(ФамилияОбрезанная)+"ой";
			Иначе  
				//обрезаем 1 символа и прибавляем "ой"	
				ФамилияОбрезанная = Сред(Фамилия,1,ДлинаФам-1);
				Фамилия1 = СокрЛП(ФамилияОбрезанная)+"ой";
			КонецЕсли; 
		Иначе  
			Если (ПослСимвФам = "о") или (ПослСимвФам = "и") или (ПослСимвФам = "х") или (ПослСимвФам = "я") или (ПослСимвФам = "а") Тогда
				//в этом случае не склоняется  	
				Фамилия1 = Фамилия;
			ИначеЕсли (ПослСимвФам = "й") Тогда 
				//обрезаем 2 символа и прибавляем "ого"	
				ФамилияОбрезанная = Сред(Фамилия, 1, ДлинаФам-2);
				Фамилия1 = ФамилияОбрезанная + "ого";
			Иначе  
				//прибавляем "а"	
				Фамилия1 = СокрЛП(Фамилия) + "а";
			КонецЕсли; 
		КонецЕсли;
		Фио1 = Фамилия1 + " " + ИО;
		Возврат ФИО1;
	ИначеЕсли Найти(ИО,".") <> 0 И НеСклонятьФамилию Тогда
		Возврат Фамилия + " " + ИО;
	КонецЕсли;	         
	
	//иначе если точек нет определяем род по отчеству  
	ДлинаОтчества = СтрДлина(СокрЛП(Отчество));
	ПослСимвОтч = Сред(Отчество, ДлинаОтчества, 1);
	Если ПослСимвОтч = "ч" Или Найти("ұлы, улы", Прав(Отчество, 3)) > 0 Тогда
		Мужской = 1;
	Иначе 
		Мужской = 0;
	КонецЕсли;
	
	Если Мужской = 1 Тогда
		Если НеСклонятьФамилию Тогда
			Фамилия1 = СокрЛП(Фамилия);
		Иначе
			
			//фамилия
			ДлинаФам = СтрДлина(СокрЛП(Фамилия));
			Если ДлинаФам <> 0 Тогда  
				ПослСимвФам = Сред(Фамилия, ДлинаФам, 1);
				Если (ПослСимвФам = "о") или (ПослСимвФам = "и") или (ПослСимвФам = "х") или (ПослСимвФам = "я") или (ПослСимвФам = "а") Тогда
					//в этом случае не склоняется  	
					Фамилия1 = Фамилия;
				ИначеЕсли (ПослСимвФам = "й") Тогда 
					//обрезаем 2 символа и прибавляем "ого"	
					ФамилияОбрезанная = Сред(Фамилия, 1, ДлинаФам - 2);
					Фамилия1 = ФамилияОбрезанная + "ого";
				Иначе  
					//прибавляем "а"	
					Фамилия1 = СокрЛП(Фамилия) + "а";
				КонецЕсли; 
			КонецЕсли;
		КонецЕсли;   		
		//имя 
		
		ДлинаИмени = СтрДлина(СокрЛП(Имя));
		//проверем составное ли имя:
		НомерПозиции =Найти(Имя,"-");
		КоличествоИмен = 1;
		Имя1="";
		Если  НомерПозиции > 0 Тогда
			//это составное имя
			СтруктураИмен = Новый Структура;
			Имя_1 = СокрЛП(Сред(Имя,1,НомерПозиции-1));		
			Имя_2 = СокрЛП(Сред(Имя,НомерПозиции+1,ДлинаИмени));
			СтруктураИмен.Вставить("Имя_1", Имя_1);
			СтруктураИмен.Вставить("Имя_2", Имя_2);
			КоличествоИмен = 2;
		КонецЕсли;
		
		Для НомерИмени =1 По КоличествоИмен  Цикл
			Если КоличествоИмен = 1 Тогда
				Имя = Имя;
				СоеденительнаяИмен = "";
			Иначе
				ИмяКлюча = "Имя_" + Строка(НомерИмени);
				СоеденительнаяИмен = "-";
				СтруктураИмен.Свойство(ИмяКлюча, Имя);
			КонецЕсли;
			ДлинаИмени = СтрДлина(СокрЛП(Имя));
			
			Если ДлинаИмени <> 0 Тогда  
				ПослСимвИмени = Сред(СокрЛП(Имя), ДлинаИмени, 1);
				Если (ПослСимвИмени = "й") или (ПослСимвИмени = "ь") Тогда 
					//обрезаем 1 символ и прибавляем "я"	
					ИмяОбрезанное = СокрЛП(Сред(СокрЛП(Имя), 1, ДлинаИмени-1));
					Имя1 = Имя1 + Врег(Лев(ИмяОбрезанное,1)) + Сред(ИмяОбрезанное,2)  + "я";
				ИначеЕсли (ПослСимвИмени = "я") Тогда 
					//обрезаем 1 символ и прибавляем "и"	
					ИмяОбрезанное = СокрЛП(Сред(СокрЛП(Имя), 1, ДлинаИмени-1));
					Имя1 = Имя1 + Врег(Лев(ИмяОбрезанное,1)) + Сред(ИмяОбрезанное,2)  + "и";	
				Иначе  
					//прибавляем "а"
					Имя = СокрЛП(Имя); 
					Имя1 = Имя1 + Врег(Лев(Имя,1)) + Сред(Имя,2)  + "а";
				КонецЕсли;  
			КонецЕсли;
			Если НомерИмени  = 1 Тогда
				Имя1= Имя1 +  СоеденительнаяИмен;
			КонецЕсли;  			
		КонецЦикла;
		
		//отчество   
		Если ДлинаОтчества <> 0 И Найти("ұлы, улы", Прав(Отчество,3)) = 0 Тогда  
			//прибавляем "а"	
			Отчество1 = СокрЛП(Отчество) + "а";
		Иначе
			Отчество1 = СокрЛП(Отчество);
		КонецЕсли;
		
	ИначеЕсли Мужской = 0 Тогда 
		//фамилия
		ДлинаФам = СтрДлина(СокрЛП(Фамилия)); 
		Если ДлинаФам <> 0 Тогда  
			Если НеСклонятьФамилию Тогда
				Фамилия1 = СокрЛП(Фамилия);
			Иначе
				
				ПослСимвФам = Сред(Фамилия,ДлинаФам,1);
				Если (ПослСимвФам = "о") или (ПослСимвФам = "и") или (ПослСимвФам = "х") или (ПослСимвФам = "ч") или (ПослСимвФам = "б") 
					или  (ПослСимвФам = "в") или (ПослСимвФам = "г") или (ПослСимвФам = "д") или (ПослСимвФам = "ж") или (ПослСимвФам = "з")
					или  (ПослСимвФам = "п") или (ПослСимвФам = "н") или (ПослСимвФам = "м") или (ПослСимвФам = "л") или (ПослСимвФам = "к")
					или  (ПослСимвФам = "р") или (ПослСимвФам = "с") или (ПослСимвФам = "т") или (ПослСимвФам = "ф") или (ПослСимвФам = "ц")
					или  (ПослСимвФам = "ь") или (ПослСимвФам = "щ") или (ПослСимвФам = "ш")   Тогда
					//в этом случае не склоняется  	
					Фамилия1 = СокрЛП(Фамилия);
				ИначеЕсли (ПослСимвФам = "я") Тогда 
					//обрезаем 2 символа и прибавляем "ой"	
					ФамилияОбрезанная = Сред(Фамилия, 1, ДлинаФам - 2);
					Фамилия1 = СокрЛП(ФамилияОбрезанная) + "ой";
				Иначе  
					//обрезаем 1 символа и прибавляем "ой"	
					ФамилияОбрезанная = Сред(Фамилия, 1, ДлинаФам - 1);
					Фамилия1 = СокрЛП(ФамилияОбрезанная) + "ой";
				КонецЕсли; 
			КонецЕсли;
		КонецЕсли;  		
		//имя 
		
		//проверем составное ли имя:
		НомерПозиции =Найти(Имя,"-");
		ДлинаИмени = СтрДлина(СокрЛП(Имя));
		КоличествоИмен = 1;
		Имя1="";
		Если  НомерПозиции > 0 Тогда
			//это составное имя, например  Мария-Тереза
			СтруктураИмен = Новый Структура;
			Имя_1 = СокрЛП(Сред(Имя,1,НомерПозиции-1));		
			Имя_2 = СокрЛП(Сред(Имя,НомерПозиции+1,ДлинаИмени));
			СтруктураИмен.Вставить("Имя_1", Имя_1);
			СтруктураИмен.Вставить("Имя_2", Имя_2);
			КоличествоИмен = 2;
		КонецЕсли;
		
		Для НомерИмени =1 По КоличествоИмен  Цикл
			Если КоличествоИмен = 1 Тогда
				Имя = Имя;
				СоеденительнаяИмен = "";
			Иначе
				ИмяКлюча = "Имя_" + Строка(НомерИмени);
				СоеденительнаяИмен = "-";
				СтруктураИмен.Свойство(ИмяКлюча, Имя);
			КонецЕсли;
			ДлинаИмени = СтрДлина(СокрЛП(Имя));
			
			Если ДлинаИмени <> 0 Тогда  
				ПослСимвИмени = Сред(СокрЛП(Имя), ДлинаИмени, 1);
				ПредПослСимвИмени = Сред(СокрЛП(Имя), ДлинаИмени-1, 1);
				
				Если (ПослСимвИмени = "а")  Тогда
					//в этом случае разбиваем на два
					Если (ПредПослСимвИмени = "и") или (ПредПослСимвИмени = "г") Тогда
						//обрезаем 1 символ и прибавляем "и"	
						ИмяОбрезанное = СокрЛП(Сред(СокрЛП(Имя), 1, ДлинаИмени - 1));
						Имя1 = Имя1 + ВРег(Лев(ИмяОбрезанное,1)) + Сред(ИмяОбрезанное,2) + "и";
					Иначе
						//обрезаем 1 символ и прибавляем "ы"	
						ИмяОбрезанное = СокрЛП(Сред(СокрЛП(Имя), 1, ДлинаИмени - 1));
						Имя1 = Имя1 + ВРег(Лев(ИмяОбрезанное,1)) + Сред(ИмяОбрезанное,2) + "ы";
					КонецЕсли;
				ИначеЕсли (ПослСимвИмени = "я")  Тогда
					//в этом случае разбиваем на два
					Если (ПредПослСимвИмени = "и") Тогда
						//обрезаем 1 символ и прибавляем "и"	
						ИмяОбрезанное = СокрЛП(Сред(СокрЛП(Имя), 1, ДлинаИмени - 1));
						Имя1 = Имя1 + ВРег(Лев(ИмяОбрезанное,1)) + Сред(ИмяОбрезанное,2) + "и";
					Иначе
						//обрезаем 1 символ и прибавляем "и"	
						ИмяОбрезанное = СокрЛП(Сред(СокрЛП(Имя), 1, ДлинаИмени - 1));
						Имя1 = Имя1 + ВРег(Лев(ИмяОбрезанное,1)) + Сред(ИмяОбрезанное,2) + "и";
					КонецЕсли; 
				ИначеЕсли (ПослСимвФам = "ь") Тогда 
					//обрезаем 1 символ и прибавляем "и"	
					ИмяОбрезанное = СокрЛП(Сред(СокрЛП(Имя), 1, ДлинаИмени - 1));
						Имя1 = Имя1 + ВРег(Лев(ИмяОбрезанное,1)) + Сред(ИмяОбрезанное,2) + "и";
				Иначе  
					//не изменяется	
					Имя = СокрЛП(Имя);
					Имя1 = Имя1 + Врег(Лев(Имя,1)) + Сред(Имя,2) ; 										
				КонецЕсли;
				Если  НомерИмени = 1 Тогда
					Имя1 = Имя1 + СоеденительнаяИмен;
				КонецЕсли;	
				
			КонецЕсли;
		КонецЦикла;
		
		//отчество  
		Если ДлинаОтчества<>0 И Найти("кызы, қызы", Прав(Отчество, 4)) = 0 Тогда  
			//обрезаем 1 символа и прибавляем "ы"	
			ОтчествоОбрезанное = Сред(Отчество, 1, ДлинаОтчества - 1);
			Отчество1 = СокрЛП(ОтчествоОбрезанное) + "ы";
		Иначе
			Отчество1 = СокрЛП(Отчество);
		КонецЕсли;	
	КонецЕсли;
	
	ФИО1 = ВРег(Лев(Фамилия1,1)) + Сред(Фамилия1, 2)+ " " +
	ВРег(Лев(Имя1,1)) + Сред(Имя1, 2) + " " +
	ВРег(Лев(Отчество1,1)) + Сред(Отчество1, 2); 
	
	Возврат ФИО1;
	
КонецФункции //ПреобразоватьФИОВРодительныйПадеж()

///////////////////////////////////////////////////////////////////////////////
// Процедуры и функции работы со списками

// Заменяет отбор, установленный пользователем в сохраненной настройке списка, на отбор, установленный программно при создании формы списка.
// Вызывается при восстановлении пользовательских настроек динамического списка
// из обработчика списка ПередЗагрузкойПользовательскихНастроекНаСервере.
//
// Параметры
//  Список      - ДинамическийСписок
//  Настройки   - ПользовательскиеНастройкиКомпоновкиДанных - восстанавливаемые настройки списка
//  ИмяОтбора   - Строка - имя элемента отбора
//
Процедура ВосстановитьОтборСписка(Список, Настройки, ИмяОтбора) Экспорт

	ОтборыКомпоновкиДанных = Неопределено;
	Для Каждого ЭлементНастроек Из Настройки.Элементы Цикл
		Если ТипЗнч(ЭлементНастроек) = Тип("ОтборКомпоновкиДанных") Тогда
			ОтборыКомпоновкиДанных = ЭлементНастроек;
		КонецЕсли;
	КонецЦикла;
	
	// пользователем не устанавливались отборы
	Если ОтборыКомпоновкиДанных = Неопределено Тогда 
		Возврат;
	КонецЕсли;
	
	ФиксированныеОтборы = ОбщегоНазначенияКлиентСервер.НайтиЭлементыИГруппыОтбора(
		Список.КомпоновщикНастроек.ФиксированныеНастройки.Отбор, ИмяОтбора);
		
	// если элемент отбора найден в фиксированных настройках, то удалим его из настроек пользователя
	Если ФиксированныеОтборы.Количество() <> 0 Тогда
		ОбщегоНазначенияКлиентСервер.УдалитьЭлементыГруппыОтбора(ОтборыКомпоновкиДанных, ИмяОтбора);
	КонецЕсли;
		
	Отборы = ОбщегоНазначенияКлиентСервер.НайтиЭлементыИГруппыОтбора(
		Список.КомпоновщикНастроек.Настройки.Отбор, ИмяОтбора);
	
	Если Отборы.Количество() = 0 Тогда
		Возврат;
	КонецЕсли;
	
	ЭлементОтбора = Отборы[0];
	ИдентификаторНастройки = ЭлементОтбора.ИдентификаторПользовательскойНастройки;
	
	Если ТипЗнч(ЭлементОтбора.ПравоеЗначение) = Тип("СправочникСсылка.Организации") Тогда 
		Если ПользователиБКВызовСервераПовтИсп.ПолучитьЗначениеПоУмолчанию(ПользователиКлиентСервер.АвторизованныйПользователь(), "УчетПоВсемОрганизациям") Тогда
			Возврат;
		КонецЕсли;
	КонецЕсли;
	
	Для каждого ЭлементНастроек Из ОтборыКомпоновкиДанных.Элементы Цикл
		Если ТипЗнч(ЭлементНастроек) = Тип("ЭлементОтбораКомпоновкиДанных") 
			И ЭлементНастроек.ИдентификаторПользовательскойНастройки = ИдентификаторНастройки Тогда
			ЭлементНастроек.ПравоеЗначение = ЭлементОтбора.ПравоеЗначение;
			ЭлементНастроек.Использование  = ЭлементОтбора.Использование;
			Прервать;
		КонецЕсли;
	КонецЦикла;

	Для каждого ЭлементНастроек Из Настройки.Элементы Цикл
		Если ТипЗнч(ЭлементНастроек) = Тип("ЭлементОтбораКомпоновкиДанных") 
			И ЭлементНастроек.ИдентификаторПользовательскойНастройки = ИдентификаторНастройки Тогда
			ЭлементНастроек.ПравоеЗначение = ЭлементОтбора.ПравоеЗначение;
			ЭлементНастроек.Использование  = ЭлементОтбора.Использование;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ОПИСАНИЕ МЕТАДАННЫХ

Функция ПолноеИмяРеквизита(ИмяРеквизита, ИмяТабличнойЧасти = "") Экспорт
	
	ПолноеИмяРеквизита = ИмяРеквизита;
	Если Не ПустаяСтрока(ИмяТабличнойЧасти) Тогда
		ПолноеИмяРеквизита = ИмяТабличнойЧасти + "." + ПолноеИмяРеквизита;
	КонецЕсли;
	
	Возврат ПолноеИмяРеквизита;
	
КонецФункции

Функция РазложитьПолноеИмяРеквизита(ПолноеИмяРеквизита) Экспорт
	
	Результат = Новый Структура;
	Результат.Вставить("Реквизит",       ПолноеИмяРеквизита);
	Результат.Вставить("ТабличнаяЧасть", "");
	
	ЭлементыИмени = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ПолноеИмяРеквизита, ".", Истина);
	Если ЭлементыИмени.Количество() = 2 Тогда
		Результат.ТабличнаяЧасть = ЭлементыИмени[0];
		Результат.Реквизит       = ЭлементыИмени[1];
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Возвращает признак, является ли конфигурация Простой.
// Возвращаемое значение:
//   Булево - Истина, если конфигурация - Простая.
//
Функция ЭтоПростаяВерсияКонфигурации() Экспорт
	
	Возврат ОбщегоНазначенияБКВызовСервераПовтИсп.ЭтоПростаяВерсияКонфигурации();
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// МАТЕМАТИКА

// Округляет число по заданному порядку. Если задан метод "ОкруглятьВБольшуюСторону",
// то число 123.37 при порядке округление 0.5 превратиться в 123.50, а число 0.1 
// при порядке округления 5 станет равным 5.
//
// Параметры:
//  Число                    - исходное число
//  ПорядокОкругления        - элемент перечисления Порядки окгугления: 
//                             "шаг" округления (0.01 (арифметическое), 0.01, 0.05, 0.1, 0.5, 1, 5, 10, 50, 100)
//	МетодОкругления			 - значение перечисления МетодыОкругления или булево (Истина = ВсегдаВБольшуюСторону, Ложь = ПоАрифметическимПравилам)
//  						   если Истина, то при порядке округления "5" 0.01 будет округлена до 5, 
//                             Ложь - округление по арифметическим правилам
//
// Возвращаемое значение:
//  Округленное по заданному порядку значение
//
Функция ОкруглитьЧисло(ЧислоДляОкругления, Знач ПорядокОкругления, Знач МетодОкругления) Экспорт

	Перем Результат;

	// Преобразуем порядок округления числа.
	// Если передали пустое значение порядка, то округлим до копеек. 
	Если НЕ ЗначениеЗаполнено(ПорядокОкругления) Тогда
		ПорядокОкругления = ПредопределенноеЗначение("Перечисление.ПорядкиОкругления.Окр0_01"); 
	КонецЕсли;

	Если Не ЗначениеЗаполнено(МетодОкругления) Тогда
		МетодОкругления = ПредопределенноеЗначение("Перечисление.МетодыОкругления.ПоАрифметическимПравилам");
	КонецЕсли;

	Если ТипЗнч(МетодОкругления) = Тип("Булево") Тогда
		// в типах цен метод округления задается как булево (Истина - в большую сторону, Ложь - по арифметрическим правилам)
		Если МетодОкругления Тогда
			МетодОкругления = ПредопределенноеЗначение("Перечисление.МетодыОкругления.ВсегдаВБольшуюСторону");
		Иначе
			МетодОкругления = ПредопределенноеЗначение("Перечисление.МетодыОкругления.ПоАрифметическимПравилам");
		КонецЕсли;
	КонецЕсли;

	Порядок = Число(Строка(ПорядокОкругления));

	// вычислим количество интервалов, входящих в число
	КоличествоИнтервал = ЧислоДляОкругления / Порядок;

	// вычислим целое количество интервалов.
	КоличествоЦелыхИнтервалов = Цел(КоличествоИнтервал);

	Если КоличествоИнтервал = КоличествоЦелыхИнтервалов Тогда
		
		// Числа поделились нацело. Округлять не нужно.
		Результат = ЧислоДляОкругления;
	Иначе
		Если МетодОкругления = ПредопределенноеЗначение("Перечисление.МетодыОкругления.ВсегдаВБольшуюСторону") Тогда

			// При порядке округления "0.05" 0.371 должно округлитья до 0.4
			Результат = Порядок * (КоличествоЦелыхИнтервалов + 1);
			
		ИначеЕсли МетодОкругления = ПредопределенноеЗначение("Перечисление.МетодыОкругления.ВсегдаВМеньшуюСторону") Тогда
			
			// При порядке округления "0.05" 0.371 и 0.376 должно округлиться до 0.35
			Результат = Порядок * КоличествоЦелыхИнтервалов;
			
		Иначе

			// При порядке округления "0.05" 0.371 должно округлитья до 0.35,
			// а 0.376 до 0.4
			Результат = Порядок * Окр(КоличествоИнтервал,0,РежимОкругления.Окр15как20);
		КонецЕсли;

	КонецЕсли;

	Возврат Результат;

КонецФункции // ОкруглитьЧисло()

// Преобразует шестнадцатиричное число в десятичное
// 
// Параметры:
//	Источник - строка с шестнадцатиричным числом
//
// Возвращаемое значение:
//	Число - десятичное число
//
Функция ШестнадцатиричноеВДесятичное(Источник) Экспорт
	
	Результат = 0;
	
	Для Поз = 1 По СтрДлина(Источник) Цикл
		ТекКод = КодСимвола(Источник, Поз);
		
		Если ТекКод >= КодСимвола("0") И ТекКод <= КодСимвола("9") Тогда
			ТекКод = ТекКод - КодСимвола("0");
		ИначеЕсли ТекКод >= КодСимвола("a") И ТекКод <= КодСимвола("f") Тогда
			ТекКод = ТекКод +10 - КодСимвола("a");
		ИначеЕсли ТекКод >= КодСимвола("A") И ТекКод <= КодСимвола("F") Тогда
			ТекКод = ТекКод +10 - КодСимвола("A");
		КонецЕсли;
		
		Результат = Результат * 16 + ТекКод;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции // ШестнадцатиричноеВДесятичное()

// Преобразует десятичное число в шестнадцатиричное
// 
// Параметры:
//	Источник - число (десятичное) от 0 до 255
//
// Возвращаемое значение:
//	Строка - десятичное число
//
Функция ДесятичноеВШестнадцатиричное(Источник) Экспорт
	
	ШестнадцатиричныеСимволы = "0123456789ABCDEF";
	
	Если Источник < 0 Тогда
		Возврат "00";
	КонецЕсли;
	Если Источник > 255 Тогда
		Возврат "FF";
	КонецЕсли;
	
	ПервыйСимвол	= Цел(Источник / 16) + 1;
	ВторойСимвол	= Источник % 16;
	
	Возврат Сред(ШестнадцатиричныеСимволы, ПервыйСимвол, 1) + Сред(ШестнадцатиричныеСимволы, ВторойСимвол, 1);
	
КонецФункции // ДесятичноеВШестнадцатиричное()

////////////////////////////////////////////////////////////////////////////////
// СЛУЖЕБНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ

// Возвращает индекс пиктограммы элемента справочника 
// в коллекции картинок "ПиктограммыЭлементов".
//
// Возвращаемое значение:
//  Число - Индекс пиктограммы элемента справочника.
//
Функция ИндексПиктограммыЭлемент() Экспорт
	Возврат 3;	
КонецФункции

// Возвращает индекс пиктограммы элемента справочника, помеченного на удаление, 
// в коллекции картинок "ПиктограммыЭлементов".
//
// Возвращаемое значение:
//  Число - Индекс пиктограммы элемента справочника, помеченного на удаление.
//
Функция ИндексПиктограммыЭлементПомеченныйНаУдаление() Экспорт
	Возврат 4;	
КонецФункции

// Выводит сообщение об ограничении
// 
//
//
Процедура ВывестиСообщениеОграничениеВерсии(Отказ = Ложь) Экспорт
	
	Отказ = Истина;
	ОбщегоНазначенияКлиентСервер.СообщитьПользователю(НСтр("ru = 'Механизм временно не поддерживается'"));
	
КонецПроцедуры


////////////////////////////////////////////////////////////////////////////////
// УПРАВЛЕНИЕ СВОЙСТВАМИ ЭЛЕМЕНТОВ ФОРМЫ

// Устанавливает значение свойства элемента формы, если находит элемент на форме
//
// Параметры
//  ЭлементыФормы - ВсеЭлементыФормы - элементы формы, среди которых содержится искомый элемент.
//  ИмяЭлемента   - Строка - имя искомого элемента.
//  ИмяСвойства   - Строка - имя свойства, для которого будет устанавливаться значение.
//  Значение      - Произвольный - значение, которое будет установлено
//  УстанавливатьДляПодчиненных - Булево - установить аналогичное свойство для подчиненных элементов искомого элемента
//
Процедура УстановитьСвойствоЭлементаФормы(ЭлементыФормы, ИмяЭлемента, ИмяСвойства, Значение, УстанавливатьДляПодчиненных = Ложь) Экспорт
	
	Элемент = ЭлементыФормы.Найти(ИмяЭлемента);
	Если Элемент = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если НРег(ИмяСвойства) = "толькопросмотр"
		И ТипЗнч(Элемент) = Тип("КнопкаФормы") Тогда
			
		ИмяСвойстваЭлемента = "Доступность";
		ЗначениеСвойства    = НЕ Значение;
	Иначе
		ИмяСвойстваЭлемента = ИмяСвойства;
		ЗначениеСвойства    = Значение;
	КонецЕсли;
	
	Если Элемент[ИмяСвойстваЭлемента] <> ЗначениеСвойства Тогда
		Элемент[ИмяСвойстваЭлемента] = ЗначениеСвойства;
	КонецЕсли;
	
	ТипыЭлементовФормыСПодчиненнымиЭлементами = Новый ОписаниеТипов("ФормаКлиентскогоПриложения, ГруппаФормы, ТаблицаФормы");
	
	Если УстанавливатьДляПодчиненных И ТипыЭлементовФормыСПодчиненнымиЭлементами.СодержитТип(ТипЗнч(Элемент)) Тогда
		Для Каждого ПодчиненныйЭлемент Из Элемент.ПодчиненныеЭлементы Цикл
			УстановитьСвойствоЭлементаФормы(ЭлементыФормы, ПодчиненныйЭлемент.Имя, ИмяСвойства, Значение, Истина);
		КонецЦикла;
 	КонецЕсли;
 	
КонецПроцедуры // УстановитьСвойствоЭлементаФорма()

// Устанавливает значение свойства элементов формы, если находит элемент на форме
//
// Параметры
//  ЭлементыФормы  - ВсеЭлементыФормы - элементы формы, среди которых содержится искомый элемент.
//  ИменаЭлементов - Массив, Строка, Структура - имена искомых элементов.
//  ИмяСвойства    - Строка - имя свойства, для которого будет устанавливаться значение.
//  Значение       - Произвольный - значение, которое будет установлено
//  УстанавливатьДляПодчиненных - Булево - установить аналогичное свойство для подчиненных элементов искомых элементов
//
Процедура УстановитьСвойствоЭлементовФормы(ЭлементыФормы, ИменаЭлементов, ИмяСвойства, Значение, УстанавливатьДляПодчиненных = Ложь) Экспорт
	
	Если ТипЗнч(ИменаЭлементов) = Тип("Массив") Тогда
		
		Для Каждого ИмяЭлемента Из ИменаЭлементов Цикл
			УстановитьСвойствоЭлементаФормы(ЭлементыФормы, ИмяЭлемента, ИмяСвойства, Значение, УстанавливатьДляПодчиненных);
		КонецЦикла
		
	Иначе
		
		Если ТипЗнч(ИменаЭлементов) = Тип("Строка") Тогда
			СтруктураИменЭлементов = Новый Структура(ИменаЭлементов);
		Иначе
			СтруктураИменЭлементов = ИменаЭлементов;
		КонецЕсли;
		
		Для Каждого ИмяЭлемента Из СтруктураИменЭлементов Цикл
			УстановитьСвойствоЭлементаФормы(ЭлементыФормы, ИмяЭлемента.Ключ, ИмяСвойства, Значение, УстанавливатьДляПодчиненных);
		КонецЦикла
		
	КонецЕсли;
	
КонецПроцедуры // УстановитьСвойствоЭлементовФормы()


// Приводит номер версии формата фискальных данных с произвольным числом разрядов 
// до стандартного представления версий вида X.X.X.X
// Параметры
//   Номер версии - Строка - строка вида X, X.X или X.X.X
// Результат
//   Строка формата - X.X.X.X
Функция ДополнитьНомерВерсииФФД(НомерВерсии) Экспорт
	Если НЕ ЗначениеЗаполнено(НомерВерсии) Тогда
		Возврат "1.0.0.0";
	КонецЕсли;
	
	НомерВерсииВМассив = СтрРазделить(НомерВерсии, ".");
	
	Для НомерРазряда = НомерВерсииВМассив.Количество() По 3 Цикл
		НомерВерсииВМассив.Добавить("0");
	КонецЦикла;
	
	Возврат СтрСоединить(НомерВерсииВМассив, ".");
КонецФункции



Функция ПолучитьВерсиюФФД(Знач ВерсияФН, Знач ВерсияККТ) Экспорт
	ВерсияККТ = ДополнитьНомерВерсииФФД(ВерсияККТ);
	ВерсияФН  = ДополнитьНомерВерсииФФД(ВерсияФН);
	
	// Определеляем максимальную версию ФФД поддерживаемую ФН
	ВерсияФН = ?(ОбщегоНазначенияКлиентСервер.СравнитьВерсии(ВерсияФН, "1.0.5.0") > 0, ВерсияФН, "1.0.5.0");
	
	// Итоговая версия определяется минимальной из версий поддерживаемых ФН и ККТ
	ВерсияФормата = ?(ОбщегоНазначенияКлиентСервер.СравнитьВерсии(ВерсияФН, ВерсияККТ) > 0, ВерсияККТ, ВерсияФН);
	
	Возврат ВерсияФормата;
КонецФункции
