////////////////////////////////////////////////////////////////////////////////
// РегламентированнаяОтчетность: 
//  
////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// ПРОГРАММНЫЙ ИНТЕРФЕЙС

// Определяет, с учетом кэша, является ли отчет, заданный строкой-идентификатором ИдентификаторОтчета, внешним.
// Параметры:
//		ИдентификаторОтчета - Строка - идентификатор отчета.
//
// ВозвращаемоеЗначение:
//		Булево - Истина, если для заданной строки-идентификатора используется внешний отчет.
//				 Ложь - в противном случае.
//				 Неопределено - информация по отчету, заданному строкой-идентификатором 
//  			 отсутствует в справочнике РегламентированныеОтчеты.
Функция ЭтоВнешнийОтчет(ИдентификаторОтчета) Экспорт
	
	НайденныйЭлемент = Справочники.РегламентированныеОтчеты.НайтиПоРеквизиту("ИсточникОтчета", ИдентификаторОтчета);
	
	Если НайденныйЭлемент = Справочники.РегламентированныеОтчеты.ПустаяСсылка() Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если ПризнакИспользованияВнешнегоОтчетаСУчетомКэша(НайденныйЭлемент) <> Истина 
		ИЛИ НайденныйЭлемент.ВнешнийОтчетХранилище = Неопределено Тогда // внутренний отчет
		Возврат Ложь;
	Иначе // внешний отчет
		Возврат Истина;
	КонецЕсли;
	
КонецФункции

// Возвращает таблицу возможных форматов для сохранения табличного документа.
//
// Возвращаемое значение
//  ТаблицаЗначений:
//                   ТипФайлаТабличногоДокумента - ТипФайлаТабличногоДокумента                 - значение в платформе, соответствующее формату;
//                   Ссылка                      - ПеречислениеСсылка.ФорматыСохраненияОтчетов - ссылка на метаданные, где хранится представление;
//                   Представление               - Строка -                                    - представление типа файла (заполняется из перечисления);
//                   Расширение                  - Строка -                                    - тип файла для операционной системы;
//                   Картинка                    - Картинка                                    - значок формата.
//
// Примечание: таблица форматов может быть переопределена в процедуре УправлениеПечатьюПереопределяемый.ПриЗаполненииНастроекФорматовСохранения().
//
Функция НастройкиФорматовСохраненияТабличногоДокумента() Экспорт
	
	ТаблицаФорматов = Новый ТаблицаЗначений;
	
	ТаблицаФорматов.Колонки.Добавить("ТипФайлаТабличногоДокумента", Новый ОписаниеТипов("ТипФайлаТабличногоДокумента"));
	ТаблицаФорматов.Колонки.Добавить("Ссылка", Новый ОписаниеТипов("ПеречислениеСсылка.ФорматыСохраненияОтчетов"));
	ТаблицаФорматов.Колонки.Добавить("Представление", Новый ОписаниеТипов("Строка"));
	ТаблицаФорматов.Колонки.Добавить("Расширение", Новый ОписаниеТипов("Строка"));
	ТаблицаФорматов.Колонки.Добавить("Картинка", Новый ОписаниеТипов("Картинка"));
	
	// Документ PDF (.pdf)
	НовыйФормат = ТаблицаФорматов.Добавить();
	НовыйФормат.ТипФайлаТабличногоДокумента = ТипФайлаТабличногоДокумента.PDF;
	НовыйФормат.Ссылка = Перечисления.ФорматыСохраненияОтчетов.PDF;
	НовыйФормат.Расширение = "pdf";
	НовыйФормат.Картинка = БиблиотекаКартинок.ФорматPDF;
	
	// Лист Microsoft Excel 2007 (.xlsx)
	НовыйФормат = ТаблицаФорматов.Добавить();
	НовыйФормат.ТипФайлаТабличногоДокумента = ТипФайлаТабличногоДокумента.XLSX;
	НовыйФормат.Ссылка = Перечисления.ФорматыСохраненияОтчетов.XLSX;
	НовыйФормат.Расширение = "xlsx";
	НовыйФормат.Картинка = БиблиотекаКартинок.ФорматExcel2007;
	
	// Лист Microsoft Excel 97-2003 (.xls)
	НовыйФормат = ТаблицаФорматов.Добавить();
	НовыйФормат.ТипФайлаТабличногоДокумента = ТипФайлаТабличногоДокумента.XLS;
	НовыйФормат.Ссылка = Перечисления.ФорматыСохраненияОтчетов.XLS;
	НовыйФормат.Расширение = "xls";
	НовыйФормат.Картинка = БиблиотекаКартинок.ФорматExcel;
	
	// Электронная таблица OpenDocument (.ods)
	НовыйФормат = ТаблицаФорматов.Добавить();
	НовыйФормат.ТипФайлаТабличногоДокумента = ТипФайлаТабличногоДокумента.ODS;
	НовыйФормат.Ссылка = Перечисления.ФорматыСохраненияОтчетов.ODS;
	НовыйФормат.Расширение = "ods";
	НовыйФормат.Картинка = БиблиотекаКартинок.ФорматOpenOfficeCalc;
	
	// Табличный документ (.mxl)
	НовыйФормат = ТаблицаФорматов.Добавить();
	НовыйФормат.ТипФайлаТабличногоДокумента = ТипФайлаТабличногоДокумента.MXL;
	НовыйФормат.Ссылка = Перечисления.ФорматыСохраненияОтчетов.MXL;
	НовыйФормат.Расширение = "mxl";
	НовыйФормат.Картинка = БиблиотекаКартинок.ФорматMXL;
	
	// Документ Word 2007 (.docx)
	НовыйФормат = ТаблицаФорматов.Добавить();
	НовыйФормат.ТипФайлаТабличногоДокумента = ТипФайлаТабличногоДокумента.DOCX;
	НовыйФормат.Ссылка = Перечисления.ФорматыСохраненияОтчетов.DOCX;
	НовыйФормат.Расширение = "docx";
	НовыйФормат.Картинка = БиблиотекаКартинок.ФорматWord2007;
	
	// Веб-страница (.html)
	НовыйФормат = ТаблицаФорматов.Добавить();
	НовыйФормат.ТипФайлаТабличногоДокумента = ТипФайлаТабличногоДокумента.HTML;
	НовыйФормат.Ссылка = Перечисления.ФорматыСохраненияОтчетов.HTML;
	НовыйФормат.Расширение = "html";
	НовыйФормат.Картинка = БиблиотекаКартинок.ФорматHTML;
	
	// Текстовый документ UTF-8 (.txt)
	НовыйФормат = ТаблицаФорматов.Добавить();
	НовыйФормат.ТипФайлаТабличногоДокумента = ТипФайлаТабличногоДокумента.TXT;
	НовыйФормат.Ссылка = Перечисления.ФорматыСохраненияОтчетов.TXT;
	НовыйФормат.Расширение = "txt";
	НовыйФормат.Картинка = БиблиотекаКартинок.ФорматTXT;
	
	// Текстовый документ ANSI (.txt)
	НовыйФормат = ТаблицаФорматов.Добавить();
	НовыйФормат.ТипФайлаТабличногоДокумента = ТипФайлаТабличногоДокумента.ANSITXT;
	НовыйФормат.Ссылка = Перечисления.ФорматыСохраненияОтчетов.ANSITXT;
	НовыйФормат.Расширение = "txt";
	НовыйФормат.Картинка = БиблиотекаКартинок.ФорматTXT;
	
	Для Каждого ФорматСохранения Из ТаблицаФорматов Цикл
		ФорматСохранения.Представление = Строка(ФорматСохранения.Ссылка);
	КонецЦикла;
	
	Возврат ТаблицаФорматов;
	
КонецФункции

// Возвращает сокращенный уникальный идентификатор текущей конфигурации
//
Функция ИДКонфигурации() Экспорт
	
	СтандартнаяОбработка = Истина;
	Результат = РегламентированнаяОтчетностьПереопределяемый.ИДКонфигурации(СтандартнаяОбработка);
	Если НЕ СтандартнаяОбработка Тогда
		Возврат Результат;
	КонецЕсли;
	
	МетаданныеИмя = Метаданные.Имя;
	
	Если МетаданныеИмя = "БухгалтерияДляКазахстана" ИЛИ МетаданныеИмя = "БухгалтерияДляКазахстанаБазовая" Тогда
		Возврат "БК";
	ИначеЕсли МетаданныеИмя = "ЗарплатаИУправлениеПерсоналомДляКазахстана" Тогда
		Возврат "ЗУПК";
	ИначеЕсли МетаданныеИмя = "УправлениеТорговлейДляКазахстана" ИЛИ МетаданныеИмя = "УправлениеТорговлейДляКазахстанаБазовая" Тогда
		Возврат "УТК";
	ИначеЕсли МетаданныеИмя = "УправлениеТорговымПредприятиемДляКазахстана" Тогда
		Возврат "УТПК";
	ИначеЕсли МетаданныеИмя = "УправлениеПроизводственнымПредприятиемДляКазахстана" Тогда
		Возврат "УППК";
	Иначе
		Возврат МетаданныеИмя;
	КонецЕсли;
	
КонецФункции

Функция ПолучитьИнформациюДляПеремещенияОМетаданных(Ссылка) Экспорт
	
	Информация = Новый Структура;
	
	МетаданныеОбъекта = Ссылка.Метаданные();
	МетаданныеРеквизита = МетаданныеОбъекта.СтандартныеРеквизиты.Код;
	
	Информация.Вставить("ПолноеИмя",    МетаданныеОбъекта.ПолноеИмя());
	
	ЭтоСправочник = Метаданные.Справочники.Содержит(МетаданныеОбъекта);
	ЭтоПВХ        = Метаданные.ПланыВидовХарактеристик.Содержит(МетаданныеОбъекта);
	
	Если ЭтоСправочник ИЛИ ЭтоПВХ Тогда
		
		Информация.Вставить("ЕстьГруппы",
		МетаданныеОбъекта.Иерархический И 
		?(ЭтоПВХ, Истина, МетаданныеОбъекта.ВидИерархии = Метаданные.СвойстваОбъектов.ВидИерархии.ИерархияГруппИЭлементов));
		
		Информация.Вставить("ДляГрупп",     Истина);
		Информация.Вставить("ДляЭлементов", Истина);
		Информация.Вставить("ЕстьРодитель",  МетаданныеОбъекта.Иерархический);
		Информация.Вставить("ГруппыСверху", ?(НЕ Информация.ЕстьРодитель, Ложь, МетаданныеОбъекта.ГруппыСверху));
		Информация.Вставить("ЕстьВладелец", ?(ЭтоПВХ, Ложь, (МетаданныеОбъекта.Владельцы.Количество() <> 0)));
		
	Иначе
		
		Информация.Вставить("ЕстьГруппы",   Ложь);
		Информация.Вставить("ДляГрупп",     Ложь);
		Информация.Вставить("ДляЭлементов", Истина);
		Информация.Вставить("ЕстьРодитель", Ложь);
		Информация.Вставить("ЕстьВладелец", Ложь);
		Информация.Вставить("ГруппыСверху", Ложь);
		
	КонецЕсли;
	
	Возврат Информация;
	
КонецФункции

Функция РеглОтчеты(Наим, НеЗапоминатьВКэше = Ложь) Экспорт
	
	Перем ВременныйФайл;
	Перем ПараметрыОтчета;
	
	НайденныйЭлемент = Справочники.РегламентированныеОтчеты.НайтиПоРеквизиту("ИсточникОтчета", Наим);
	Если НайденныйЭлемент = Справочники.РегламентированныеОтчеты.ПустаяСсылка() Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если НайденныйЭлемент.ВнешнийОтчетИспользовать Тогда

	  Возврат ПодключитьВнешнийРеглОтчет(НайденныйЭлемент);
	  
	ИначеЕсли Метаданные.Документы.Найти(Наим) <> Неопределено Тогда
		
		Возврат Документы[Наим];
		
	ИначеЕсли Метаданные.Отчеты.Найти(Наим) <> Неопределено Тогда
		
		Возврат Отчеты[Наим];
		
	Иначе
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='Не найден отчет %1!'"), СокрП(Наим));
		ОбщегоНазначения.СообщитьПользователю(ТекстСообщения);
		
		Возврат Неопределено;
		
	КонецЕсли; 
	
	Возврат Неопределено;
	
КонецФункции

Функция ФормаРеглОтчета(Наим, ВыбраннаяФорма = Неопределено, Владелец = Неопределено, КлючУникальности = Неопределено) Экспорт
	Перем ВременныйФайл;
	
	НайденныйЭлемент = Справочники.РегламентированныеОтчеты.НайтиПоРеквизиту("ИсточникОтчета", Наим);
	Если НайденныйЭлемент = Справочники.РегламентированныеОтчеты.ПустаяСсылка() Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если Метаданные.Документы.Найти(Наим) <> Неопределено Тогда
		
		Возврат Документы[Наим];
		
	ИначеЕсли Метаданные.Отчеты.Найти(Наим) <> Неопределено Тогда
		
		Возврат Отчеты[Наим];
		
	Иначе
		
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='Не найден отчет %1!'"), СокрП(Наим));
		ОбщегоНазначения.СообщитьПользователю(ТекстСообщения);
		
		Возврат Неопределено;
		
	КонецЕсли; 
	
	Возврат Неопределено;
	
КонецФункции

Функция ЭтоВнешнийОбъект(ОтчетОбъект) Экспорт
	
	Если Найти(ОтчетОбъект, "ВнешнийОтчетОбъект.") > 0 Тогда
		ЭтоВнешнийОтчет = Истина;
	Иначе 
		ЭтоВнешнийОтчет = Ложь;
	КонецЕсли;
	
	Возврат ЭтоВнешнийОтчет;
КонецФункции

Функция ЕстьРеквизитФормы(Форма, ИмяРеквизита) Экспорт
	
	Для Каждого РеквизитФормы Из Форма.ПолучитьРеквизиты() Цикл
		Если ВРег(РеквизитФормы.Имя) = ВРег(ИмяРеквизита) Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ ВЫБОРКИ ДАННЫХ 

// Функция возвращает наименование строки из макета классификатора по ее коду
//
// Параметры:
//	ТабличныйМакет - табличный документ, содеджащий данные классификатора
//	Область - область табличного документа, по строкам которой осуществляется поиск
//	КодСтроки - строковый код 
//	НомерКолонкиКода - число - номер колонки, в которой содержатся коды строк
//	НомерКолонкиНаименования - число - номер колонки, в которой содержатся наименование строк
//
Функция ПолучитьНаименованиеСтрокиКлассификатораПоКоду(МакетКлассификатора, Область, Знач КодСтроки, НомерКолонкиКода = 1, НомерКолонкиНаименования = 2) Экспорт
	
	НаименованиеСтроки = "";
	КодСтроки = ВРег(СокрЛП(КодСтроки));
	
	Для НомерСтроки = Область.Верх По Область.Низ Цикл
		
		Если КодСтроки = ВРег(СокрЛП(МакетКлассификатора.Область(НомерСтроки, НомерКолонкиКода).Текст)) Тогда
			НаименованиеСтроки = МакетКлассификатора.Область(НомерСтроки, НомерКолонкиНаименования).Текст;
			Прервать;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат НаименованиеСтроки;
	
КонецФункции // ПолучитьНаименованиеСтрокиПоКоду()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ СО СТРУКТУРОЙ ХРАНЕНИЯ ДАННЫХ РЕГЛАМЕНТИРОВАННЫХ ОТЧЕТОВ

// Процедура создает общую структуру хранения данных
// 
// Параметры: Объект - объект регламентированного отчета
//
Процедура ЗаполнитьСтруктуруФормРегОтчета(Объект) Экспорт
	
	СписокФормБезИерархии = Объект.РеквизитФормыВЗначение("мСписокФормБезИерархии");
	мСтруктураМногострочныхРазделов = Объект.РеквизитФормыВЗначение("мСтруктураМногострочныхРазделов");
	
	СписокФормБезИерархии.Строки.Очистить();
	мСтруктураМногострочныхРазделов.Строки.Очистить();
	мВыбраннаяФорма = Объект.мВыбраннаяФорма;
	
	ЗаполнитьДеревоСтраниц(Объект);
	
	ЗаполнитьТаблицуПередачиДанных(Объект);
	
	//также создадим дерево значений  без иерархии, для выгрузки данных
	//и отображения в форме настройки страниц
	
	Для Каждого Строка Из Объект.РеквизитФормыВЗначение("СписокФормДерева").Строки Цикл                
		НоваяСтрока = СписокФормБезИерархии.Строки.Добавить();       
		НоваяСтрока.КодФормы            = Строка.КодФормы;
		НоваяСтрока.ПоказатьСтраницу    = Строка.ПоказатьСтраницу;
		НоваяСтрока.Выгружать           = Строка.Выгружать;
		НоваяСтрока.АвтополучениеИтогов = Строка.АвтополучениеИтогов;  
		НоваяСтрока.АвтоЗаполнение      = Строка.АвтоЗаполнение;  
		НоваяСтрока.Страницы            = Строка.Страницы;
		НоваяСтрока.ИмяФормы            = Строка.ИмяФормы;
		НоваяСтрока.Многострочность     = Строка.Многострочность;
		НоваяСтрока.КоличествоНаЛисте   = Строка.КоличествоНаЛисте; 
		НоваяСтрока.ОриентацияСтр       = Строка.ОриентацияСтр; 
		НоваяСтрока.ПризнакОсновной     = Строка.ПризнакОсновной; 
		НоваяСтрока.ЗаголовокФормы      = Строка.ЗаголовокФормы;  		
		НоваяСтрока.ИспользуетсяМакет   = Строка.ИспользуетсяМакет;  		
		НоваяСтрока.ВсегоСтраниц        = 1;  		
		Если Строка.Строки.Количество() > 0 Тогда
			Для Каждого ПодчиненнаяСтрока Из Строка.Строки Цикл
				НоваяСтрока = СписокФормБезИерархии.Строки.Добавить();
				НоваяСтрока.КодФормы            = ПодчиненнаяСтрока.КодФормы;
				НоваяСтрока.ПоказатьСтраницу    = ПодчиненнаяСтрока.ПоказатьСтраницу;
				НоваяСтрока.Выгружать           = ПодчиненнаяСтрока.Выгружать;
				НоваяСтрока.АвтополучениеИтогов = ПодчиненнаяСтрока.АвтополучениеИтогов;  
				НоваяСтрока.АвтоЗаполнение      = ПодчиненнаяСтрока.АвтоЗаполнение;  
				НоваяСтрока.Страницы            = ПодчиненнаяСтрока.Страницы;
				НоваяСтрока.ИмяФормы            = ПодчиненнаяСтрока.ИмяФормы;
				НоваяСтрока.Многострочность     = ПодчиненнаяСтрока.Многострочность;				
				НоваяСтрока.КоличествоНаЛисте   = ПодчиненнаяСтрока.КоличествоНаЛисте;				
				НоваяСтрока.ОриентацияСтр       = ПодчиненнаяСтрока.ОриентацияСтр; 
				НоваяСтрока.ПризнакОсновной     = ПодчиненнаяСтрока.ПризнакОсновной;
				НоваяСтрока.ЗаголовокФормы      = ПодчиненнаяСтрока.ЗаголовокФормы;
				НоваяСтрока.ВсегоСтраниц        = 1;  		
				Если ПодчиненнаяСтрока.Строки.Количество() > 0 Тогда
					Для Каждого ПодчиненнаяСтрока2 Из ПодчиненнаяСтрока.Строки Цикл
						НоваяСтрока = СписокФормБезИерархии.Строки.Добавить();
						НоваяСтрока.КодФормы            = ПодчиненнаяСтрока2.КодФормы;
						НоваяСтрока.ПоказатьСтраницу    = ПодчиненнаяСтрока2.ПоказатьСтраницу;
						НоваяСтрока.Выгружать           = ПодчиненнаяСтрока2.Выгружать;
						НоваяСтрока.АвтополучениеИтогов = ПодчиненнаяСтрока2.АвтополучениеИтогов; 
						НоваяСтрока.АвтоЗаполнение      = ПодчиненнаяСтрока2.АвтоЗаполнение; 
						НоваяСтрока.Страницы            = ПодчиненнаяСтрока2.Страницы;
						НоваяСтрока.ИмяФормы            = ПодчиненнаяСтрока2.ИмяФормы;
						НоваяСтрока.Многострочность     = ПодчиненнаяСтрока2.Многострочность;
						НоваяСтрока.КоличествоНаЛисте   = ПодчиненнаяСтрока2.КоличествоНаЛисте;
						НоваяСтрока.ОриентацияСтр       = ПодчиненнаяСтрока2.ОриентацияСтр; 
						НоваяСтрока.ПризнакОсновной     = ПодчиненнаяСтрока2.ПризнакОсновной;
						НоваяСтрока.ЗаголовокФормы      = ПодчиненнаяСтрока2.ЗаголовокФормы;
						НоваяСтрока.ВсегоСтраниц        = 1;  		
					КонецЦикла; 
				КонецЕсли; 
			КонецЦикла;
		КонецЕсли;
	КонецЦикла; 
	
	ФормаПериода = Объект.ЭтаФорма;
	// заполним структуру значений для всех заполняемых форм из макетов
	Попытка 
		Макет = Объект.РеквизитФормыВЗначение("ОтчетОбъект").ПолучитьМакет("Макет"+мВыбраннаяФорма);    
	Исключение
		Макет = Неопределено; // для форм, в которых нет многострочных форм, в них не создаются макеты
	КонецПопытки;
	
	Объект.мМакет = Макет;
	Для Каждого Форма Из СписокФормБезИерархии.Строки Цикл 		    		
		Если Форма.Многострочность = 1 Тогда
			ТекСтраница = Форма.КодФормы;
		
			Результат = СформироватьСтруктуруМногострочнойФормы(ТекСтраница,ФормаПериода,Макет, мСтруктураМногострочныхРазделов);
		
			Если Результат = Неопределено Тогда
				ОбщегоНазначения.СообщитьПользователю(СтрШаблон(НСтр("ru = 'Для формы %1 не сформирована структура хранения данных'"), Форма.КодФормы));
			КонецЕсли;
		Иначе
			Если ФормаПериода.Элементы.Найти("Панель" + Форма.КодФормы) = Неопределено Тогда
				ОбщегоНазначения.СообщитьПользователю(СтрШаблон(НСтр("ru = 'Для формы %1 не сформирована структура хранения данных'"), Форма.КодФормы));
			Иначе
				ТаблицаИмен = Новый ТаблицаЗначений;
				ТаблицаИмен.Колонки.Добавить("ИмяОбласти");
				ТаблицаИмен.Колонки.Добавить("Значение");
				ТаблицаИмен.Индексы.Добавить("ИмяОбласти");
				
				Если Форма.ИспользуетсяМакет = Истина Тогда
					ФормаПериода.ЗагрузитьМакетВТабличныйДокумент();
				КонецЕсли;
				
				ИмяПанелиФормы = "Панель" + Форма.КодФормы;
				Для Каждого Страница Из ФормаПериода.Элементы[ИмяПанелиФормы].ПодчиненныеЭлементы Цикл					
					ИмяСтраницыБезПрефиксаПанели =  СтрЗаменить(Страница.Имя, ИмяПанелиФормы, ""); // ИмяСтраницыБезПерфиксаПанели
					Если ФормаПериода.Элементы.Найти(Форма.КодФормы + "ПолеТабличногоДокумента" + ИмяСтраницыБезПрефиксаПанели) = Неопределено Тогда
						ОбщегоНазначения.СообщитьПользователю(СтрШаблон(НСтр("ru = 'Для формы %1 не сформирована структура хранения данных'"), Форма.КодФормы));
						Прервать;
					Иначе
						ТекПоле = ФормаПериода[Форма.КодФормы + "ПолеТабличногоДокумента" + ИмяСтраницыБезПрефиксаПанели];
						Для Каждого Область Из ТекПоле.Области Цикл
							Если Лев(Врег(Область.Имя),8) = Врег("Страница") Тогда
								Продолжить;
							КонецЕсли;
							Если Найти(Врег(Область.Имя), Врег("ОбластьФорматирования")) <> 0 Тогда
								Продолжить;
							КонецЕсли;
							// проверяем добавлялась ли строка ранее с таким же названием области
							СуществующаяСтрока = ТаблицаИмен.Найти(Область.Имя,"ИмяОбласти");
							Если СуществующаяСтрока = Неопределено Тогда
								Строка = ТаблицаИмен.Добавить();
								Строка.ИмяОбласти = Область.Имя;					
								Если ((ТипЗнч(Область) = Тип("ОбластьЯчеекТабличногоДокумента") И Область.ТипОбласти = ТипОбластиЯчеекТабличногоДокумента.Прямоугольник)
										ИЛИ (ТипЗнч(Область) = Тип("РисунокТабличногоДокумента") И Область.ТипРисунка = ТипРисункаТабличногоДокумента.Текст)) 
									И Область.СодержитЗначение Тогда									
									Строка.Значение = Область.ТипЗначения.ПривестиЗначение(Строка.Значение);
									//Строка.Значение = Область.Значение;
								Иначе
									Строка.Значение = "";
									//Строка.Значение = Область.Текст;
								КонецЕсли;
							КонецЕсли;
						КонецЦикла;
					КонецЕсли;
				КонецЦикла;   				
				Форма.Значение = ТаблицаИмен;    				
			КонецЕсли;	
		КонецЕсли;
	КонецЦикла;	
	
	Объект.ЗначениеВРеквизитФормы(СписокФормБезИерархии, "мСписокФормБезИерархии");
	Объект.ЗначениеВРеквизитФормы(мСтруктураМногострочныхРазделов, "мСтруктураМногострочныхРазделов");	
КонецПроцедуры

// Функция получает значение таблицы данных обычной формы
//
Функция ЗначениеТаблицыДанныхОбычнойФормы(ТаблицаДанных, ИмяОбласти) Экспорт    
	
	СтрокаОбласти = ТаблицаДанных.Найти(ИмяОбласти,"ИмяОбласти");
	Если СтрокаОбласти <> Неопределено Тогда
		ЗначениеОбласти = СтрокаОбласти.Значение;
	Иначе
		ЗначениеОбласти = 0;
	КонецЕсли;
	
	Возврат ЗначениеОбласти;
	
КонецФункции

// Процедура заполняет значение в таблице данных обычной формы
//
Процедура ПередатьЗначениеВТаблицуДанных(ТаблицаДанных, ИмяОбласти, Значение, ТабличноеПоле = Неопределено) Экспорт    
	
	СтрокаОбласти = ТаблицаДанных.Найти(ИмяОбласти,"ИмяОбласти");
	Если СтрокаОбласти <> Неопределено Тогда
		СтрокаОбласти.Значение = Значение;	
	КонецЕсли;		
	
	Если ТабличноеПоле <> Неопределено Тогда 	
		ТекОбласть = ТабличноеПоле.Области.Найти(ИмяОбласти);
		Если ТекОбласть <> Неопределено Тогда 
			Если ТекОбласть.СодержитЗначение Тогда
				ТекОбласть.Значение = Значение;
			Иначе
				ТекОбласть.Текст = Значение;
			КонецЕсли;			
		КонецЕсли;    
	КонецЕсли;	
КонецПроцедуры

// Функция получает таблицу расшифровки для многострочной формы
//
Функция ПолучитьТаблицуРасшифровки(Форма, КодФормы = Неопределено) Экспорт
	
	мСтруктураМногострочныхРазделов = Форма.РеквизитФормыВЗначение("мСтруктураМногострочныхРазделов");
	
	Если КодФормы = Неопределено Тогда
		КодФормы = Форма.КодФормы;
	КонецЕсли;
	
	Строка = мСтруктураМногострочныхРазделов.Строки.Найти(КодФормы, "КодФормы");
	
	Возврат Строка.ТаблицаРасшифровки;
	
КонецФункции

// Функция получает таблицу данных обычной формы из
// общей структуры хранения данных
//
Функция ПолучитьТаблицуДанныхОбычнойФормы(Форма, КодФормы) Экспорт
	
	СтрокаФормы = Форма.РеквизитФормыВЗначение("мСписокФормБезИерархии").Строки.Найти(КодФормы,"КодФормы");
	ТаблицаДанных = СтрокаФормы.Значение;
	
	Возврат ТаблицаДанных;
	
КонецФункции

Процедура ОбновитьТаблицуДанныхОбычнойФормы(Форма, КодФормы, ТаблицаДанных) Экспорт
	
	мСписокФормБезИерархии = Форма.РеквизитФормыВЗначение("мСписокФормБезИерархии");
	
	СтрокаФормы = мСписокФормБезИерархии.Строки.Найти(КодФормы,"КодФормы");
	СтрокаФормы.Значение = ТаблицаДанных;
	
	Форма.ЗначениеВРеквизитФормы(мСписокФормБезИерархии, "мСписокФормБезИерархии");
КонецПроцедуры

// Процедура обеспечивает передачу данных и в поле табличного документа, и в 
// структуру хранения данных для обычных форм и для многострочных форм
// для реквизитов шапки, итога и подвала по именам параметров в макете
//
// Параметры:       Форма - форма регламентированного отчета
//                  КодФормы - имя формы передаваемой или код формы
//                  ИмяОбласти - имя области поля табличного документа
//                  Значение - значение
//                  ПередаватьВТабличноеПоле - отображать ли переданное значение на форме
//                  ПередаватьВМногострочнуюЧасть - значение передается во все строки Таблиц строк каждой группы
//  
Процедура ПередатьЗначениеВСтруктуру(Форма, КодФормы, ИмяОбласти, Значение = "", ПередаватьВТабличноеПоле = Истина, ПередаватьВМногострочнуюЧасть = Ложь, ПараметрРасшифровкиСтроки = Неопределено) Экспорт
	СписокФормБезИерархии = Форма.РеквизитФормыВЗначение("мСписокФормБезИерархии");
	
	НайденнаяСтрока = СписокФормБезИерархии.Строки.Найти(КодФормы,"КодФормы");
	
	ТаблицаДанных = НайденнаяСтрока.Значение;
	
	Если НайденнаяСтрока.Многострочность = 1 Тогда
		// параметр ИмяОбласти выступает в качестве параметра		
		мСтруктураМногострочныхРазделов = Форма.РеквизитФормыВЗначение("мСтруктураМногострочныхРазделов");
		МногострочнаяСтруктура = мСтруктураМногострочныхРазделов.Строки.Найти(КодФормы,"КодФормы");
		Для Каждого СтруктураГруппы Из МногострочнаяСтруктура.Строки Цикл			
			Если НЕ ПередаватьВМногострочнуюЧасть Тогда
				ОбщиеЭлементыГруппы = СтруктураГруппы.ОбщиеЭлементыГруппы;
				СтруктураПоиска = Новый Структура("ИмяПараметра",ИмяОбласти);
				Строки = ОбщиеЭлементыГруппы.НайтиСтроки(СтруктураПоиска);
				Если Строки.Количество() <> 0 Тогда
					Для каждого Строка Из Строки Цикл
						Строка.Значение = Значение;					
					КонецЦикла;                                             
				КонецЕсли;							
			Иначе
				ТаблицаСтрокГруппы = Форма.РеквизитФормыВЗначение(СтруктураГруппы.ИмяРеквизитаТаблицыСтрокГруппы);
				Если ТаблицаСтрокГруппы.Колонки.Найти(ИмяОбласти) <> Неопределено Тогда
					Для Каждого Строка Из ТаблицаСтрокГруппы Цикл
						Строка[ИмяОбласти] = Значение;
						Если ЗначениеЗаполнено(ПараметрРасшифровкиСтроки) Тогда
							Строка[ИмяОбласти + "_Расшифровка"] = ПараметрРасшифровкиСтроки;
						КонецЕсли;						
					КонецЦикла;
				КонецЕсли;
				Форма.ЗначениеВРеквизитФормы(ТаблицаСтрокГруппы, СтруктураГруппы.ИмяРеквизитаТаблицыСтрокГруппы);
			КонецЕсли;
		КонецЦикла;
		
		Форма.ЗначениеВРеквизитФормы(мСтруктураМногострочныхРазделов, "мСтруктураМногострочныхРазделов");
		
		Если ПередаватьВТабличноеПоле Тогда	
			ПередатьДанныеИзСтруктурыВТабличноеПоле(Форма, КодФормы);
		КонецЕсли;				
		
	Иначе // обычная форма
		
		Строка = ТаблицаДанных.Найти(ИмяОбласти,"ИмяОбласти");
		Если Строка <> Неопределено Тогда
			Строка.Значение = Значение;
		Иначе
			ОбщегоНазначения.СообщитьПользователю(СтрШаблон(НСтр("ru = 'В структуре формы ""%1"" не найдена область ""%2"".'"), КодФормы, ИмяОбласти));
		КонецЕсли;
		
		Если ПередаватьВТабличноеПоле Тогда
			// передаем значение из структуры в табличное поле, если в данный момент активна форма под именем "КодФормы"			
			ИмяПанелиФормы = "Панель" + КодФормы;
			Для Каждого Страница Из Форма.Элементы[ИмяПанелиФормы].ПодчиненныеЭлементы  Цикл
				ИмяСтраницыБезПрефиксаПанели =  СтрЗаменить(Страница.Имя, ИмяПанелиФормы, ""); // ИмяСтраницыБезПерфиксаПанели
				ТекПоле = Форма[КодФормы + "ПолеТабличногоДокумента" + ИмяСтраницыБезПрефиксаПанели];				
				ТекОбласть = ТекПоле.Области.Найти(ИмяОбласти);
				Если ТекОбласть <> Неопределено Тогда 
					Если ТекОбласть.СодержитЗначение Тогда
						ТекОбласть.Значение = Значение;
					Иначе
						ТекОбласть.Текст = Значение;
					КонецЕсли;
					//Прервать; 
				КонецЕсли;
			КонецЦикла;			
		КонецЕсли;
	КонецЕсли;
	
	Форма.ЗначениеВРеквизитФормы(СписокФормБезИерархии, "мСписокФормБезИерархии");
КонецПроцедуры

// Процедура обеспечивает передачу данных из структуры хранения данных
// в поле табличного документа для форм
//
Процедура ПередатьДанныеИзСтруктурыВТабличноеПоле(Форма, КодФормы)  Экспорт 	                                                       
	Перем СтруктураГруппы;
	
	мСписокФормБезИерархии = Форма.РеквизитФормыВЗначение("мСписокФормБезИерархии");
	НайденнаяСтрока = мСписокФормБезИерархии.Строки.Найти(КодФормы,"КодФормы");
	
	Если НайденнаяСтрока = Неопределено Тогда
		// структура формы еще не сформирована
		Возврат;
	КонецЕсли;
	ВсегоСтраницДоВывода = НайденнаяСтрока.ВсегоСтраниц;
	
	ТаблицаДанных = НайденнаяСтрока.Значение;
	ИмяПанелиФормы = "Панель" + КодФормы;
	Если НайденнаяСтрока.Многострочность = 1 Тогда
		мМногострочнаяСтруктура = ПолучитьМногострочнуюСтруктуру(Форма, КодФормы);		
		Для Каждого Страница Из Форма.Элементы["Панель" + КодФормы].ПодчиненныеЭлементы Цикл
			ИмяСтраницыБезПрефиксаПанели =  СтрЗаменить(Страница.Имя, ИмяПанелиФормы, ""); // ИмяСтраницыБезПерфиксаПанели					
			мМногострочнаяСтруктура.Свойство(ИмяСтраницыБезПрефиксаПанели, СтруктураГруппы);
			//уже выводим записанные значения в табличный документ	    
			ТекСтраница = Форма.ТекущаяСтраница; 
			Если ТекСтраница > 0 Тогда
				ВывестиРазделВТабличныйДокументФормы(Форма, ТекСтраница, ИмяСтраницыБезПрефиксаПанели, СтруктураГруппы, КодФормы, НайденнаяСтрока.ВсегоСтраниц);
			КонецЕсли;
		КонецЦикла; 
		
	Иначе		
		Для Каждого Страница Из Форма.Элементы["Панель" + КодФормы].ПодчиненныеЭлементы Цикл
			ИмяСтраницыБезПрефиксаПанели =  СтрЗаменить(Страница.Имя, ИмяПанелиФормы, ""); // ИмяСтраницыБезПерфиксаПанели
			ТекПоле = Форма[КодФормы + "ПолеТабличногоДокумента" + ИмяСтраницыБезПрефиксаПанели];
			
			Для Каждого Строка Из ТаблицаДанных Цикл
				ТекОбласть = ТекПоле.Области.Найти(Строка.ИмяОбласти);
				Если ТекОбласть <> Неопределено Тогда 
					Если ТекОбласть.СодержитЗначение Тогда
						ТекОбласть.Значение = Строка.Значение;
					Иначе
						ТекОбласть.Текст = Строка.Значение;
					КонецЕсли;
				КонецЕсли;									      
			КонецЦикла;
		КонецЦикла;   
	КонецЕсли;
	
	Если ВсегоСтраницДоВывода <> НайденнаяСтрока.ВсегоСтраниц  Тогда
		Форма.ЗначениеВРеквизитФормы(мСписокФормБезИерархии, "мСписокФормБезИерархии");
	КонецЕсли;

//	Форма.ИзменитьОтображениеДанныхФормы();
	
КонецПроцедуры

// Процедура обеспечивает передачу всех данных из табличного документа
// в структуру хранения данных для обычных форм
// Данную процедуру можно использовать только когда активная закладка 
// главной панели регламентированного отчета, имеющая имя Форма.ИмяФормы
//
Процедура ПередатьДанныеИзТабличногоПоляВСтруктуру(Форма) Экспорт        
	
	мСписокФормБезИерархии = Форма.РеквизитФормыВЗначение("мСписокФормБезИерархии");
	НайденнаяСтрока = мСписокФормБезИерархии.Строки.Найти(Форма.КодФормы,"КодФормы");	
	
	ТаблицаДанных = НайденнаяСтрока.Значение;
	ИмяПанелиФормы = "Панель" + Форма.КодФормы;
	Для Каждого Страница Из Форма.Элементы["Панель" + Форма.КодФормы].ПодчиненныеЭлементы Цикл
		ИмяСтраницыБезПрефиксаПанели =  СтрЗаменить(Страница.Имя, ИмяПанелиФормы, ""); // ИмяСтраницыБезПерфиксаПанели
		ТекПоле = Форма[Форма.КодФормы + "ПолеТабличногоДокумента" + ИмяСтраницыБезПрефиксаПанели];
		
		Для Каждого ТекОбласть Из ТекПоле.Области Цикл
			Если Лев(Врег(ТекОбласть.Имя),8) = Врег("Страница") Тогда
				Продолжить;
			КонецЕсли;
			Строка = ТаблицаДанных.Найти(ТекОбласть.Имя, "ИмяОбласти");
			Если Строка <> Неопределено Тогда 
				Если ТекОбласть.СодержитЗначение Тогда
					Строка.Значение = ТекОбласть.Значение;
				Иначе
					Строка.Значение = ТекОбласть.Текст;
				КонецЕсли;
			КонецЕсли;		
		КонецЦикла;
	КонецЦикла;   
	
	Форма.ЗначениеВРеквизитФормы(мСписокФормБезИерархии, "мСписокФормБезИерархии");		
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ СВЯЗАННЫЕ С ОБРАБОТКОЙ МНОГОСТРОЧНОЙ ЧАСТИ РЕГЛАМЕНТИРОВАННЫХ ОТЧЕТОВ

//Процедура выводит в табличные документы области макета
//
//Параметры:
// ИмяГруппы       - Имя текущего табличного документа
// СтруктураГруппы - Тип: ТаблицаЗначений, содержит данные для текущего листа
// Страница        - Номер страницы
//
//Возврат
//   ТабличныйДокумент.
//
Функция ВывестиОбластиВТабличныйДокумент(Форма, ИмяГруппы, СтруктураГруппы, Страница, ВыводитьСтроки = Истина, ТекущееИмяФормы, ВсегоСтраниц) 
	
	ОбщиеЭлементыГруппы = СтруктураГруппы.ШапкаИПодвал;
	ТаблицаСтрокГруппы  = СтруктураГруппы.Строки;          
	
	//вычисляем количество страниц
	КоличествоЗаписей = ТаблицаСтрокГруппы.Количество();
	
	мКоличествоНаЛисте = ПолучитьКоличествоНаЛисте(ТекущееИмяФормы,Форма.РеквизитФормыВЗначение("мСписокФормБезИерархии"));
	
	Стр =  Цел(КоличествоЗаписей/мКоличествоНаЛисте);
	Если Стр = КоличествоЗаписей/мКоличествоНаЛисте  Тогда
		ВсегоСтраниц = Стр;
	Иначе
		ВсегоСтраниц = Стр + 1;
	КонецЕсли;
	
	Если (Страница > ВсегоСтраниц И ВсегоСтраниц <> 0) ИЛИ Страница = 0 Тогда
		Страница = ВсегоСтраниц;		 
	КонецЕсли;
	
	//заполняем области из макета в табличные документы	
	Поле = ТекущееИмяФормы + "ПолеТабличногоДокумента" + ИмяГруппы;
	ТекТабличноеПоле = Форма[Поле];
	ТекТабличноеПоле.Очистить();     
	
	ОбластьШапка  = Неопределено;
	ОбластьИтог   = Неопределено;
	ОбластьСтрока = Неопределено;
	ОбластьПодвал = Неопределено;
	
	Макет = Форма.мМакет;
	
	Если Макет.Области.Найти("Шапка" + ТекущееИмяФормы + ИмяГруппы) <> Неопределено Тогда
		ОбластьШапка  = Макет.ПолучитьОбласть("Шапка"  + ТекущееИмяФормы + ИмяГруппы);	 
	КонецЕсли;
	Если Макет.Области.Найти("Итог" + ТекущееИмяФормы + ИмяГруппы) <> Неопределено Тогда
		ОбластьИтог   = Макет.ПолучитьОбласть("Итог"   + ТекущееИмяФормы + ИмяГруппы);	
	КонецЕсли;
	Если Макет.Области.Найти("Строка" + ТекущееИмяФормы + ИмяГруппы) <> Неопределено Тогда
		ОбластьСтрока = Макет.ПолучитьОбласть("Строка" + ТекущееИмяФормы + ИмяГруппы);
	КонецЕсли;
	Если Макет.Области.Найти("Подвал" + ТекущееИмяФормы + ИмяГруппы) <> Неопределено Тогда
		ОбластьПодвал = Макет.ПолучитьОбласть("Подвал" + ТекущееИмяФормы + ИмяГруппы);
	КонецЕсли;
	
	Если ОбластьШапка <> Неопределено Тогда
		СписокПараметровШапки = Новый СписокЗначений;
		Для Каждого Область Из ОбластьШапка.Области Цикл			 
			Если Область.Заполнение = ТипЗаполненияОбластиТабличногоДокумента.Параметр Тогда
				СписокПараметровШапки.Добавить(Область.Параметр);
			КонецЕсли;
		КонецЦикла;
		Если Найти(СписокПараметровШапки,"Стр")<>0 Тогда
			ОбластьШапка.Параметры.Стр = Страница;
		КонецЕсли;
		
		ТекТабличноеПоле.Вывести(ОбластьШапка);
	КонецЕсли;
	
	Если ОбластьИтог <> Неопределено Тогда
		// итог выводиться только на первой странице
		Если Страница = 1 И ВыводитьСтроки Тогда		 
			ТекТабличноеПоле.Вывести(ОбластьИтог);
			ЗаполнитьДанныеИтоговВСтруктуре(Форма, ТаблицаСтрокГруппы, ОбщиеЭлементыГруппы);
		КонецЕсли;
	КонецЕсли;
	
	Если ОбластьСтрока <> Неопределено Тогда
		Если ВыводитьСтроки Тогда		 		 
			//вставляем порядковый номер для строки			
			Для Каждого Область Из ОбластьСтрока.Области Цикл			 
				Если Область.Заполнение = ТипЗаполненияОбластиТабличногоДокумента.Параметр Тогда
					Если Область.Параметр = "НомерСтроки" Тогда
						НачальноеЗначение = Область.ПараметрРасшифровки;	                	
						Если ЗначениеЗаполнено(НачальноеЗначение) Тогда
							НомерПервойЗаписи = Число(Прав(НачальноеЗначение,1));
						Иначе
							НомерПервойЗаписи = 2;
						КонецЕсли;
						ИмяКолонки = ТаблицаСтрокГруппы.Колонки[0].Имя; 
						НовыйПорядковыйНомер = КоличествоЗаписей + НомерПервойЗаписи - 1;
						ТаблицаСтрокГруппы[КоличествоЗаписей - 1][ИмяКолонки] = Формат(НовыйПорядковыйНомер,Форма.мФорматНомераСтроки);						
						Прервать;
					КонецЕсли;					
				КонецЕсли;
			КонецЦикла;   			 				
			
			ТекТабличноеПоле.Вывести(ОбластьСтрока);
		КонецЕсли;
	КонецЕсли;
	
	Если ОбластьПодвал <> Неопределено Тогда
		
		ТекТабличноеПоле.Вывести(ОбластьПодвал);
		
	КонецЕсли;
	
	// выводим сохраненные значения шапки, итога и подвала из ТЗ в поле табличного документа
	Для Каждого Элемент Из ОбщиеЭлементыГруппы Цикл
		Если ТекТабличноеПоле.Области.Найти(Элемент.ИмяОбласти) <> Неопределено И Элемент.Значение <> Неопределено Тогда 
			ТекОбласть = ТекТабличноеПоле.Области[Элемент.ИмяОбласти];
			Если ТекОбласть.СодержитЗначение Тогда
				ТекОбласть.Значение = Элемент.Значение;
			Иначе
				ТекОбласть.Текст = Элемент.Значение;
			КонецЕсли;
		КонецЕсли;                                                                  		 
	КонецЦикла;
	
	Возврат ТекТабличноеПоле;
	
КонецФункции // ВывестиОбластиВТабличныйДокумент()

// Процедура выводит строки многострочного раздела в табличный документ.
// При отсутствии в табличном документе необходимого количества строк
// добавляет отсутствующие строки.
//
// Параметры:
//  ИмяГруппы       - строка, имя многострочного раздела;
//  СтруктураГруппы - таблица значений, содержащая значения показателей многострочного раздела.
//
Процедура ВывестиРазделВТабличныйДокументФормы(Форма, Страница, ИмяГруппы, СтруктураГруппы, ТекИмяФормы, ВсегоСтраниц) Экспорт     
	
	ОбщиеЭлементыГруппы = СтруктураГруппы.ШапкаИПодвал;
	ТаблицаСтрокГруппы  = СтруктураГруппы.Строки;
	
	мКоличествоНаЛисте = ПолучитьКоличествоНаЛисте(ТекИмяФормы,Форма.РеквизитФормыВЗначение("мСписокФормБезИерархии"));
	
	ТекущееКоличество = ТаблицаСтрокГруппы.Количество();                                        
	Если ТекущееКоличество = 0 Тогда
		Поле = ТекИмяФормы + "ПолеТабличногоДокумента" + ИмяГруппы;
		ТекТабличноеПоле = Форма[Поле];
		ТекТабличноеПоле.Очистить();		 
		Возврат;		
	КонецЕсли;
	
	ТекТабличноеПоле = ВывестиОбластиВТабличныйДокумент(Форма, ИмяГруппы, СтруктураГруппы,Страница,,ТекИмяФормы, ВсегоСтраниц);
	
	НомерСтроки       = 1;
	
	Если ВсегоСтраниц = 1  Тогда	//если всего одна страница	
		ТекущееКоличествоСтрокГруппы = ТаблицаСтрокГруппы.Количество();
		ИсходноеКоличествоСтрокГруппы = 1;
	ИначеЕсли Страница = 1 Тогда     //если первая страница из множества
		ТекущееКоличествоСтрокГруппы = мКоличествоНаЛисте;
		ИсходноеКоличествоСтрокГруппы = 1;
	Иначе //все другие страницы, кроме первой			
		ИсходноеКоличествоСтрокГруппы = Цел((Страница) * мКоличествоНаЛисте) - мКоличествоНаЛисте;
		КоличествоНаЛисте = Страница * мКоличествоНаЛисте;
		Если КоличествоНаЛисте < ТекущееКоличество Тогда
			ТекущееКоличествоСтрокГруппы = КоличествоНаЛисте;
		Иначе
			ТекущееКоличествоСтрокГруппы = ТекущееКоличество;
		КонецЕсли;
	КонецЕсли;	
	
	//если всего строк = 1 на странице, то вставлять новые области не надо
	//нужно только переименовать их соотвественно со страницей
	Если мКоличествоНаЛисте = 1 Тогда
		НомНовойСтроки = Страница;
		// переопределяем имена вставленной области
		Для Каждого Колонка Из ТаблицаСтрокГруппы.Колонки Цикл
			ИмяКолонки          = Колонка.Имя;
			
			Если Найти(ИмяКолонки, "_Расшифровка") > 0 Тогда
                Продолжить;
			КонецЕсли;
			
			ИмяОбластиЯчейки    = ИмяКолонки + "__" + 1;
			ИмяНовОбластиЯчейки = ИмяКолонки + "__" + НомНовойСтроки;
			
			ОбластьЯчейки = ТекТабличноеПоле.Области[ИмяОбластиЯчейки];
			ОбластьЯчейки.Имя = ИмяНовОбластиЯчейки;
			
			// очищаем значения ячеек вставленной области
			Если ОбластьЯчейки.СодержитЗначение Тогда
				ОбластьЯчейки.Очистить();
			КонецЕсли;
		КонецЦикла; 
	Иначе
		// Выводим данные, относящиеся к данной странице		
		Для  НомСтроки = ИсходноеКоличествоСтрокГруппы + 1  По ТекущееКоличествоСтрокГруппы  Цикл
			
			НомИсходнойСтроки = НомСтроки - 1;
			НомНовойСтроки    = НомСтроки;
			
			// определяем имя первой ячейки последней из исходных строк
			ИмяПервойЯчейкиПоследнейСтроки = ТаблицаСтрокГруппы.Колонки[0].Имя + "__" + НомИсходнойСтроки;
			
			// область первой ячейки последней из исходных строк
			Если ТекТабличноеПоле.Области.Найти(ИмяПервойЯчейкиПоследнейСтроки) = Неопределено Тогда
				ВставитьНовуюСтраницу(ТекТабличноеПоле,ТаблицаСтрокГруппы,1, НомНовойСтроки);
			Иначе
				
				ОбластьЯчейки = ТекТабличноеПоле.Области[ИмяПервойЯчейкиПоследнейСтроки];
				// номера строк исходной области
				НомерВерхЯчейкиОбласти = ОбластьЯчейки.Верх;
				НомерНижнЯчейкиОбласти = ОбластьЯчейки.Низ + 1;
				
				СдвигСтрок = НомерНижнЯчейкиОбласти - НомерВерхЯчейкиОбласти + 1;
				
				// Строки многострочного раздела должны входят в именованную секцию
				// для предотвращения вывода на печать пустых строк.
				// Определим именованую секцию, куда входит добавляемая строка.
				ИмяПервойЯчейкиПервойСтроки = ТаблицаСтрокГруппы.Колонки[0].Имя + "__" + 1;
				// область первой ячейки первой строки многострочного раздела
				ОбластьЯчейки               = ТекТабличноеПоле.Области[ИмяПервойЯчейкиПервойСтроки];
				// номер первой строки именованной секции
				НомерВерхЯчейкиСекции       = ОбластьЯчейки.Верх;
				// область именованной секции
				ОбластьИменованСекции       = ТекТабличноеПоле.Область(НомерВерхЯчейкиСекции, , НомерНижнЯчейкиОбласти, );
				ИмяСекции                   = ОбластьИменованСекции.Имя;
				// предварительно очищаем прежнюю секцию, так как она смещается вниз вместе с добавляемой строкой
				ОбластьИменованСекции.Имя   = "";
				
				// номера строк вставляемой области
				НомерВерхЯчейкиНовойОбласти = НомерВерхЯчейкиОбласти + СдвигСтрок;
				НомерНижнЯчейкиНовойОбласти = НомерНижнЯчейкиОбласти + СдвигСтрок;
				
				// определяем вставляемую область
				ВставляемаяОбласть = ТекТабличноеПоле.Область(НомерВерхЯчейкиОбласти, , НомерНижнЯчейкиОбласти, );
				//ВставляемаяОбласть.Защита = Защита;
				// добавляем в таблицу новую строку
				ТекТабличноеПоле.ВставитьОбласть(ВставляемаяОбласть, ,ТипСмещенияТабличногоДокумента.ПоВертикали);
				// переопределяем имена вставленной области
				Для Каждого Колонка Из ТаблицаСтрокГруппы.Колонки Цикл					
					ИмяКолонки          = Колонка.Имя;
					Если Найти(ИмяКолонки, "_Расшифровка") > 0 Тогда
						Продолжить;
					КонецЕсли;
					
					ИмяОбластиЯчейки    = ИмяКолонки + "__" + НомИсходнойСтроки;
					ИмяНовОбластиЯчейки = ИмяКолонки + "__" + НомНовойСтроки;
					
					ОбластьЯчейки     = ТекТабличноеПоле.Области[ИмяОбластиЯчейки];
 					ОбластьЯчейки.Имя = ИмяНовОбластиЯчейки;
					
					// определяем границы ячейки исходной области
					НомерВерхСтрокиЯчейки  = ОбластьЯчейки.Верх - СдвигСтрок;
					НомерНижнСтрокиЯчейки  = ОбластьЯчейки.Низ  - СдвигСтрок;
					НомерЛевоКолонкиЯчейки = ОбластьЯчейки.Лево;
					НомерПравКолонкиЯчейки = ОбластьЯчейки.Право;
					
					// Назначаем имя ячейки исходной области,
					// (т.к. в результате вставки новой области оно было очищено)
					ОбластьЯчейкиИсходнойОбласти = ТекТабличноеПоле.Область(НомерВерхСтрокиЯчейки, НомерЛевоКолонкиЯчейки, НомерНижнСтрокиЯчейки, НомерПравКолонкиЯчейки);
					ОбластьЯчейкиИсходнойОбласти.Имя = ИмяОбластиЯчейки;
					
					// очищаем значения ячеек вставленной области
					Если ОбластьЯчейки.СодержитЗначение Тогда
						ОбластьЯчейки.Очистить();
					КонецЕсли;
				КонецЦикла;
				
				НомерСтроки = НомерСтроки + 1;
			КонецЕсли;
			
		КонецЦикла;
	КонецЕсли;
	
	ИндексПоследнейСтрокиНаСтранице = Страница * мКоличествоНаЛисте - 1;
	ИндексПервойСтрокиНаСтранице = ИндексПоследнейСтрокиНаСтранице - мКоличествоНаЛисте + 1;
	
	Если ИндексПоследнейСтрокиНаСтранице > ТаблицаСтрокГруппы.Количество() - 1 Тогда
		ИндексПоследнейСтрокиНаСтранице = ТаблицаСтрокГруппы.Количество() - 1;
	КонецЕсли;
	Для ИндексТекущейСтроки = ИндексПервойСтрокиНаСтранице По ИндексПоследнейСтрокиНаСтранице Цикл
		СтрокаТаблицы = ТаблицаСтрокГруппы[ИндексТекущейСтроки];
		
		Для Каждого КолонкаТаблицы Из ТаблицаСтрокГруппы.Колонки Цикл
			
			Если Найти(КолонкаТаблицы.Имя, "_Расшифровка") > 0 Тогда
				Продолжить;
			КонецЕсли;	
			
			НомерСтрокиВТаблице      = ТаблицаСтрокГруппы.Индекс(СтрокаТаблицы);
			НомерСтрокиВФормеТаблицы = НомерСтрокиВТаблице + 1 ;
			ИмяЯчейки                = КолонкаТаблицы.Имя + "__" + НомерСтрокиВФормеТаблицы;
			Если  ТекТабличноеПоле.Области.Найти(ИмяЯчейки) <> Неопределено Тогда
				ОбластьЯчейкиТаблицы = ТекТабличноеПоле.Области[ИмяЯчейки];
			Иначе
				Продолжить;
			КонецЕсли;
			
			ЗначениеЯчейки           = СтрокаТаблицы[КолонкаТаблицы.Имя];
			
			Если ОбластьЯчейкиТаблицы.СодержитЗначение Тогда
				// задаем значение ячейки
				ОбластьЯчейкиТаблицы.Значение = ЗначениеЯчейки;				
				Попытка
					ПараметрРасшифровки = СтрокаТаблицы[КолонкаТаблицы.Имя +"_Расшифровка"];
					Если ЗначениеЗаполнено(ПараметрРасшифровки) Тогда
						ОбластьЯчейкиТаблицы.Расшифровка = ПараметрРасшифровки;
					КонецЕсли;	
				Исключение
				КонецПопытки
			Иначе
				// задаем текст для ячейки
				ОбластьЯчейкиТаблицы.Текст    = ЗначениеЯчейки;
			КонецЕсли;
			
			ОбластьЯчейкиТаблицы.Защита = Истина;
			
		КонецЦикла;
	КонецЦикла;
	
КонецПроцедуры // ВывестиРазделВТабличныйДокумент()

//Процедура  заполняет итоговые данные  табличного документа
//
//Параметры:
//  ТаблицаСтрокГруппы - Тип: ТаблицаЗначений, по данным которой
//                    вычисляються итоговые данные
//  ОбщиеЭлементыГруппы - Тип: ТаблицаЗначений, куда записываются итоговые данные
//                        в строки, где в колонке "Итог" значение строки равно Истина
//
Процедура ЗаполнитьДанныеИтоговВСтруктуре(Форма, ТаблицаСтрокГруппы, ОбщиеЭлементыГруппы) 
	
	Отбор = Новый Структура();
	Отбор.Вставить("Итог",Истина);
	СтрокиИтоговыхЯчеек = ОбщиеЭлементыГруппы.НайтиСтроки(Отбор);
	Для Каждого Строка Из СтрокиИтоговыхЯчеек Цикл
		ТекЗначение = Строка.ИмяОбласти;
		Если ТаблицаСтрокГруппы.Колонки.Найти(ТекЗначение) <> Неопределено Тогда
			Строка.Значение = ТаблицаСтрокГруппы.Итог(ТекЗначение);
		КонецЕсли;                                		
	КонецЦикла;
	
КонецПроцедуры //ЗаполнитьДанныеИтоговВСтруктуре()

Процедура ВставитьНовуюСтраницу(ТекТабличноеПоле, СтруктураГруппы, НомИсходнойСтроки, НомНовойСтроки)
	
	// переопределяем имена вставленной области
	
	ИмяПервойЯчейкиПоследнейСтроки = СтруктураГруппы.Колонки[0].Имя + "__" + НомИсходнойСтроки;
	ОбластьЯчейки = ТекТабличноеПоле.Области[ИмяПервойЯчейкиПоследнейСтроки]; 
	НомерВерхЯчейкиОбласти = ОбластьЯчейки.Верх;
	НомерНижнЯчейкиОбласти = ОбластьЯчейки.Низ + 1;
	СдвигСтрок = НомерНижнЯчейкиОбласти - НомерВерхЯчейкиОбласти + 1;
	
	Для Каждого Колонка Из СтруктураГруппы.Колонки Цикл		
		ИмяКолонки          = Колонка.Имя;
			
		Если Найти(ИмяКолонки, "_Расшифровка") > 0 Тогда
			Продолжить;
		КонецЕсли;

		ИмяОбластиЯчейки    = ИмяКолонки + "__" + НомИсходнойСтроки;
		ИмяНовОбластиЯчейки = ИмяКолонки + "__" + НомНовойСтроки;
		
		ОбластьЯчейки = ТекТабличноеПоле.Области[ИмяОбластиЯчейки];
		ОбластьЯчейки.Имя = ИмяНовОбластиЯчейки;
		
		// определяем границы ячейки исходной области
		НомерВерхСтрокиЯчейки  = ОбластьЯчейки.Верх - СдвигСтрок;
		НомерНижнСтрокиЯчейки  = ОбластьЯчейки.Низ  - СдвигСтрок;
		НомерЛевоКолонкиЯчейки = ОбластьЯчейки.Лево;
		НомерПравКолонкиЯчейки = ОбластьЯчейки.Право;
		
		// Назначаем имя ячейки исходной области,
		// (т.к. в результате вставки новой области оно было очищено)
		ОбластьЯчейкиИсходнойОбласти = ТекТабличноеПоле.Область(НомерВерхСтрокиЯчейки, НомерЛевоКолонкиЯчейки, НомерНижнСтрокиЯчейки, НомерПравКолонкиЯчейки);
		ОбластьЯчейкиИсходнойОбласти.Имя = ИмяОбластиЯчейки;
		
		Если ОбластьЯчейки.СодержитЗначение Тогда
			ОбластьЯчейки.Очистить();					
		КонецЕсли; 		
	КонецЦикла;
	
КонецПроцедуры // ВставитьНовуюСтраницу()

//Процедура инициализирует текущую страницу
//Параметры:
//     Порядок - управляет порядком обхода страница
//     может принимать значения "+1" - вверх по страницам
//                              "-1" - вниз по страницам
//
Процедура ВывестиСтраницуМногострочнойФормы(Форма) Экспорт
	
	ПередатьДанныеИзСтруктурыВТабличноеПоле(Форма, Форма.КодФормы);
	ПоказатьСтраницыМногострочнойФормы(Форма); 		
	
КонецПроцедуры   //ВывестиСтраницуМногострочнойФормы()

// Создает новую строку многострочной формы.
//
Процедура ДобавитьСтрокуМногострочнойФормы(Форма) Экспорт
	
	Перем СтруктураГруппы;
	
	ТекущееИмяФормы = Форма.КодФормы;
		
	мСтруктураМногострочныхРазделов = Форма.РеквизитФормыВЗначение("мСтруктураМногострочныхРазделов");	
	СтрокаФормы = мСтруктураМногострочныхРазделов.Строки.Найти(ТекущееИмяФормы,"КодФормы");	
	    	
	ИмяПанелиФормы = "Панель" + ТекущееИмяФормы;
	мСписокФормБезИерархии = Форма.РеквизитФормыВЗначение("мСписокФормБезИерархии");                 
	
	ТекФормыВСпискеБезИерархии = мСписокФормБезИерархии.Строки.Найти(ТекущееИмяФормы,"КодФормы");
	
	Если ТекФормыВСпискеБезИерархии = Неопределено Тогда
		Возврат;
	КонецЕсли;

	ОбновлениеВсегоСтраниц = Ложь;
	Для Каждого Страница Из Форма.Элементы[ИмяПанелиФормы].ПодчиненныеЭлементы Цикл
		ИмяСтраницыБезПрефиксаПанели =  СтрЗаменить(Страница.Имя, ИмяПанелиФормы, ""); // ИмяСтраницыБезПерфиксаПанели 		
		ИмяГруппы = ИмяСтраницыБезПрефиксаПанели;
		
		СтруктураГруппы = СтрокаФормы.Строки.Найти(ИмяГруппы);				
		ОбщиеЭлементыГруппы = СтруктураГруппы.ОбщиеЭлементыГруппы;		
		ТаблицаСтрокГруппы  = Форма.РеквизитФормыВЗначение(СтруктураГруппы.ИмяРеквизитаТаблицыСтрокГруппы);
		
		Строка = ТаблицаСтрокГруппы.Добавить();
		
		//если мы добавили первую строку и в шапке не содержится данных
		Если ТаблицаСтрокГруппы.Количество() = 1 Тогда
			// Заполним шапку и подвал текущего листа
		Иначе // сохраняем шапку и подвал текущего листа
			Поле = ТекущееИмяФормы + "ПолеТабличногоДокумента" + ИмяГруппы;
			Поле = Форма[Поле];
			Для Каждого Область Из Поле.Области Цикл
				Строка = ОбщиеЭлементыГруппы.Найти(Область.Имя,"ИмяОбласти");
				Если Строка <> Неопределено Тогда
					Если Область.СодержитЗначение Тогда
						Строка.Значение = Область.Значение;
					Иначе
						Строка.Значение = Область.Текст;
					КонецЕсли;				 
				КонецЕсли;
			КонецЦикла;
			// перенесем итоговые данные в ТЗ
			ЗаполнитьДанныеИтоговВСтруктуре(Форма, ТаблицаСтрокГруппы,ОбщиеЭлементыГруппы); 			 
		КонецЕсли;   				
		
		Форма.ЗначениеВРеквизитФормы(ТаблицаСтрокГруппы, СтруктураГруппы.ИмяРеквизитаТаблицыСтрокГруппы);
							                                                                
		// Заполним шапку и подвал текущего листа
		Форма.ЗаполнитьПараметры(ТекущееИмяФормы);		
		ТаблицаСтрокГруппы  = Форма.РеквизитФормыВЗначение(СтруктураГруппы.ИмяРеквизитаТаблицыСтрокГруппы);
							
		ВывестиРазделВТабличныйДокументФормы(Форма, ТекФормыВСпискеБезИерархии.ВсегоСтраниц, ИмяГруппы, Новый Структура("ШапкаИПодвал, Строки", ОбщиеЭлементыГруппы, ТаблицаСтрокГруппы), ТекущееИмяФормы, ТекФормыВСпискеБезИерархии.ВсегоСтраниц);
		
		Если Не ОбновлениеВсегоСтраниц Тогда 
			Форма.ЗначениеВРеквизитФормы(мСписокФормБезИерархии, "мСписокФормБезИерархии");
			Форма.ТекущаяСтраница = ТекФормыВСпискеБезИерархии.ВсегоСтраниц;			
			ОбновлениеВсегоСтраниц = Истина; 
		КонецЕсли;

		// Обновим в структуре 
		Форма.ЗначениеВРеквизитФормы(ТаблицаСтрокГруппы, СтруктураГруппы.ИмяРеквизитаТаблицыСтрокГруппы);
	КонецЦикла; 	
	
	Форма.ЗначениеВРеквизитФормы(мСтруктураМногострочныхРазделов, "мСтруктураМногострочныхРазделов");

	ПоказатьСтраницыМногострочнойФормы(Форма);
	Форма.Модифицированность = Истина;	
	
КонецПроцедуры  //ВставитьСтроку()

Процедура ДобавитьРасшифровкуСтрокиМногострочнойФормы(ТаблицаСтрок, Элемент, ИмяЯчейки, ЗначениеРасшифровки) Экспорт
    
    ИмяРасшифровкиСтроки = ИмяЯчейки + "_Расшифровка";
    Если ТаблицаСтрок.Колонки.Найти(ИмяРасшифровкиСтроки) <> Неопределено Тогда
        Элемент[ИмяРасшифровкиСтроки] = ЗначениеРасшифровки;
    КонецЕсли;
        
Конецпроцедуры

// Процедура удаляет строку из многострочной части.
//
// Параметры:
//  Форма - ФормаКлиентскогоПриложения - Форма, в которой необходимо удалить строку.
//  КоличествоСтрокШапки - Число - Количество строк в шапке многостройчной формы.
//
Процедура УдалитьСтрокуМногострочнойФормы(Форма, Знач КоличествоСтрокШапки = 1) Экспорт
	
	Перем СтруктураГруппы;
	
	ИмяФормы = Форма.КодФормы;
	
	мСписокФормБезИерархии = Форма.РеквизитФормыВЗначение("мСписокФормБезИерархии");	
	ТекФорма               = мСписокФормБезИерархии.Строки.Найти(ИмяФормы, "КодФормы");
	Если ТекФорма = Неопределено Тогда 		
		мКоличествоНаЛисте 		= 1;  
		ВсегоСтраниц    		= 1;  
	Иначе
		мКоличествоНаЛисте 		= ТекФорма.КоличествоНаЛисте;  
		ВсегоСтраниц    		= ТекФорма.ВсегоСтраниц;  		
	КонецЕсли;	  	
		
	ТекущаяПанель 	= Форма.Элементы["Панель" + ИмяФормы];	
	ТекСтраница  	= ТекущаяПанель.ТекущаяСтраница;
		
	мМногострочнаяСтруктура = ПолучитьМногострочнуюСтруктуру(Форма);	
	ТаблицаРасшифровки 		= ПолучитьТаблицуРасшифровки(Форма); 
	
	ИмяСтраницыБезПрефиксаПанели =  СтрЗаменить(ТекСтраница.Имя, ТекущаяПанель.Имя, ""); // ИмяСтраницыБезПерфиксаПанели
	мМногострочнаяСтруктура.Свойство(ИмяСтраницыБезПрефиксаПанели, СтруктураГруппы);
	
	ОбщиеЭлементыГруппы = СтруктураГруппы.ШапкаИПодвал;
	ТаблицаСтрокГруппы  = СтруктураГруппы.Строки;
	
	Если мКоличествоНаЛисте > 1 Тогда
		ИмяПоля = ИмяФормы + "ПолеТабличногоДокумента" + ИмяСтраницыБезПрефиксаПанели;
		ТекОбласть = Форма.Элементы[ИмяПоля].ТекущаяОбласть;
		
		Если Найти(ТекОбласть.Имя, "__") <> 0 Тогда
			
			НомерСтроки = Сред(ТекОбласть.Имя, Найти(ТекОбласть.Имя, "__") + 2);
			Номер 	= Формат(Число(НомерСтроки) + КоличествоСтрокШапки,  Форма.мФорматНомераСтроки);
			Строка 	= ТаблицаСтрокГруппы.Найти(Номер);
			Если Строка <> Неопределено Тогда
				ИндексСтроки = ТаблицаСтрокГруппы.Индекс(Строка) ; 
			Иначе
				Возврат;
			КонецЕсли;
								
			Для Каждого Страница Из ТекущаяПанель.ПодчиненныеЭлементы Цикл                 		 				
				ИмяСтраницыБезПрефиксаПанели =  СтрЗаменить(Страница.Имя, ТекущаяПанель.Имя, ""); // ИмяСтраницыБезПерфиксаПанели
				
				мМногострочнаяСтруктура.Свойство(ИмяСтраницыБезПрефиксаПанели, СтруктураГруппы);
				ОбщиеЭлементыГруппы = СтруктураГруппы.ШапкаИПодвал;
				ТаблицаСтрокГруппы  = СтруктураГруппы.Строки;
				СтрокаГруппы = ТаблицаСтрокГруппы.Получить(ИндексСтроки);
				ТаблицаСтрокГруппы.Удалить(СтрокаГруппы); 
				
				// Обновить номера всех строк, так как одна из строк была удалена.
				НомерСтроки = КоличествоСтрокШапки + 1;
				Для Каждого Элемент Из ТаблицаСтрокГруппы Цикл
					Элемент[0] = Формат(НомерСтроки, Форма.мФорматНомераСтроки);
					НомерСтроки = НомерСтроки + 1;				  
				КонецЦикла;
				
				//если удалены все данные с листа
				//то продолжаем выполнение процедуры
				Если ТаблицаСтрокГруппы.Количество() = 0 Тогда
					// очистим значения шапки (подвала) в Таблице значений
					Для Каждого Элемент Из ОбщиеЭлементыГруппы Цикл
						Элемент.Значение = Неопределено;						 
					КонецЦикла;
					Форма.ТекущаяСтраница = 0;
					ВсегоСтраниц = 0;
				Иначе
					// перенесем итоговые данные в ТЗ
					ЗаполнитьДанныеИтоговВСтруктуре(Форма, ТаблицаСтрокГруппы, ОбщиеЭлементыГруппы); 			 
				КонецЕсли;
				ВывестиРазделВТабличныйДокументФормы(Форма, Форма.ТекущаяСтраница, ИмяСтраницыБезПрефиксаПанели, СтруктураГруппы, ИмяФормы, ВсегоСтраниц);
				Форма.ЗначениеВРеквизитФормы(ТаблицаСтрокГруппы, СтруктураГруппы.ИмяРеквизитаТаблицыСтрокГруппы)
			КонецЦикла; 	
		Иначе
			ОбщегоНазначения.СообщитьПользователю(НСтр("ru = 'Удаление невозможно, не выбрана строка многострочной части формы!'"));
		КонецЕсли;
		
		Если Форма.ТекущаяСтраница > ВсегоСтраниц И ВсегоСтраниц <> 0 Тогда
			Форма.ТекущаяСтраница = ВсегоСтраниц;
		КонецЕсли;
		
	Иначе // если на листе 1 страница, то удаляем страницу
		
		НомерСтроки = Форма.ТекущаяСтраница -1;
		Если ТаблицаСтрокГруппы.Количество() < Форма.ТекущаяСтраница Тогда
			Возврат;
		КонецЕсли;
		
		Если ТаблицаСтрокГруппы.Количество() = 0 Тогда
			Возврат;
		КонецЕсли;
		
		Строка = ТаблицаСтрокГруппы[НомерСтроки];
		Если Строка <> Неопределено Тогда
			ИндексСтроки = ТаблицаСтрокГруппы.Индекс(Строка) ; 
		Иначе
			Возврат;
		КонецЕсли;
					
		Для Каждого Страница Из ТекущаяПанель.ПодчиненныеЭлементы Цикл                 		 
			ИмяСтраницыБезПрефиксаПанели =  СтрЗаменить(Страница.Имя, ТекущаяПанель.Имя, ""); // ИмяСтраницыБезПерфиксаПанели
			
			мМногострочнаяСтруктура.Свойство(ИмяСтраницыБезПрефиксаПанели, СтруктураГруппы);
			ОбщиеЭлементыГруппы = СтруктураГруппы.ШапкаИПодвал;
			ТаблицаСтрокГруппы  = СтруктураГруппы.Строки;
			
			СтрокаГруппы = ТаблицаСтрокГруппы.Получить(ИндексСтроки);
			ТаблицаСтрокГруппы.Удалить(СтрокаГруппы); 
			
			//если удалены все данные с листа
			//то продолжаем выполнение процедуры
			Если ТаблицаСтрокГруппы.Количество() = 0 Тогда
				// очистим значения шапки (подвала) в Таблице значений
				Для Каждого Элемент Из ОбщиеЭлементыГруппы Цикл
					Элемент.Значение = Неопределено;						 
				КонецЦикла;
				Форма.ТекущаяСтраница = 0;
				ВсегоСтраниц = 0;
			Иначе
				// перенесем итоговые данные в ТЗ
				ЗаполнитьДанныеИтоговВСтруктуре(Форма, ТаблицаСтрокГруппы, ОбщиеЭлементыГруппы); 			 
			КонецЕсли; 
			ВывестиРазделВТабличныйДокументФормы(Форма, Форма.ТекущаяСтраница, ИмяСтраницыБезПрефиксаПанели, СтруктураГруппы, ИмяФормы,ВсегоСтраниц);
			Форма.ЗначениеВРеквизитФормы(ТаблицаСтрокГруппы, СтруктураГруппы.ИмяРеквизитаТаблицыСтрокГруппы)
		КонецЦикла;
		
	КонецЕсли;

	Если Не ТекФорма = Неопределено И НЕ ТекФорма.ВсегоСтраниц   = ВсегоСтраниц Тогда 		
		ТекФорма.ВсегоСтраниц = ВсегоСтраниц;  		
		Форма.ЗначениеВРеквизитФормы(мСписокФормБезИерархии, "мСписокФормБезИерархии");	
	КонецЕсли;	  	

	ОбновитьМногострочнуюСтруктуру(Форма, ИмяФормы, мМногострочнаяСтруктура);

	ПоказатьСтраницыМногострочнойФормы(Форма);
	Форма.Модифицированность = Истина;   
	
КонецПроцедуры // УдалитьСтрокуМногострочнойФормы()

Функция ПолучитьМногострочнуюСтруктуру(Форма, ТекущееИмяФормы = Неопределено) Экспорт            
	
	Если ТекущееИмяФормы = Неопределено тогда
		ТекущееИмяФормы = Форма.КодФормы;
	КонецЕсли;	
	
	мСтруктураМногострочныхРазделов = Форма.РеквизитФормыВзначение("мСтруктураМногострочныхРазделов");
									   
	МногострочнаяСтруктура = Новый Структура;
	СтрокаФормы = мСтруктураМногострочныхРазделов.Строки.Найти(ТекущееИмяФормы,"КодФормы");	
	Если СтрокаФормы = Неопределено Тогда
		Возврат Неопределено
	КонецЕсли;	
	
	Для Каждого СтрокаДанных Из СтрокаФормы.Строки Цикл
		ДанныеСтраницы = Новый Структура;
		ДанныеСтраницы.Вставить("ШапкаИПодвал", СтрокаДанных.ОбщиеЭлементыГруппы);		
		ДанныеСтраницы.Вставить("Строки",       Форма.РеквизитФормыВЗначение(СтрокаДанных.ИмяРеквизитаТаблицыСтрокГруппы));
		ДанныеСтраницы.Вставить("ИмяРеквизитаТаблицыСтрокГруппы", СтрокаДанных.ИмяРеквизитаТаблицыСтрокГруппы);
		
		МногострочнаяСтруктура.Вставить(СтрокаДанных.ИмяГруппы, ДанныеСтраницы);
	КонецЦикла;		
		
	Возврат МногострочнаяСтруктура;
	
КонецФункции

// Обновляет структуру многострочных частей формы.
// Заполняет таблицу значений значениями соответствующих ячеек.
//
//Параметры:
//  ИмяГруппы          - строка, имя текущего табличного поля
//  ИмяПоказателя      - строка, имя именованнй ячейки
//  ЗначениеПоказателя - значение, которое было изменено в данной ячейки и его нужно
//                       перезаписать в структуру
//
Процедура ПередатьЗначениеВМногострочнуюСтруктуру(Форма, ИмяГруппы, ИмяПоказателя, ЗначениеПоказателя, Расчет = Ложь, ПоказательРасшифровки  = Неопределено) Экспорт
	
	Перем СтруктураГруппы;
	
	ИмяФормы = Форма.КодФормы;
	
	мСтруктураМногострочныхРазделов = Форма.РеквизитФормыВзначение("мСтруктураМногострочныхРазделов");
	
	СтрокаФормы  = мСтруктураМногострочныхРазделов.Строки.Найти(ИмяФормы, "КодФормы");
	СтрокаДанных = СтрокаФормы.Строки.Найти(ИмяГруппы, "ИмяГруппы");
	
	Если СтрокаДанных = Неопределено Тогда
		// группа отсутствует в структуре данных
		ТекстСообщения = СтрШаблон(НСтр("ru = 'Группа %1 не найдена в структуре формы'"), ИмяГруппы);
		ОбщегоНазначения.СообщитьПользователю(ТекстСообщения);
		Возврат;
	КонецЕсли;
	
	ОбщиеЭлементыГруппы = СтрокаДанных.ОбщиеЭлементыГруппы;
	ТаблицаСтрокГруппы = Форма.РеквизитФормыВЗначение(СтрокаДанных.ИмяРеквизитаТаблицыСтрокГруппы);
	
	// Сначала ищем показатель в шапке(подвале), если не найден, то в многострочной части
	НайденнаяСтрока = ОбщиеЭлементыГруппы.Найти(ИмяПоказателя, "ИмяОбласти");
	Если НайденнаяСтрока <> Неопределено Тогда // это шапка, сохраняем значение
		НайденнаяСтрока.Значение = ЗначениеПоказателя;
		Форма.ЗначениеВРеквизитФормы(мСтруктураМногострочныхРазделов, "мСтруктураМногострочныхРазделов");
		Если Расчет Тогда
			Форма.ВыборРасчета(ИмяФормы, 0, ИмяПоказателя);
		КонецЕсли;
	Иначе
		// Возможно, это таблица строк
		
		Инд = Сред(ИмяПоказателя, Найти(ИмяПоказателя, "__")+2);
		Индекс = Инд-1;
		Колонка = Лев(ИмяПоказателя, СтрДлина(ИмяПоказателя) - (СтрДлина(Инд) + 2));
		Если ТаблицаСтрокГруппы.Колонки.Найти(Колонка) = Неопределено Тогда
			// Графа не найдена
			ТекстСообщения = СтрШаблон(НСтр("ru = 'Графа %1 не найдена в структуре формы'"), Колонка);
			ОбщегоНазначения.СообщитьПользователю(ТекстСообщения);
			Возврат;
		КонецЕсли;
		
		Строка = ТаблицаСтрокГруппы.Получить(Индекс);
		//Заносим новое значение в структуру группы
		Строка[Колонка] = ЗначениеПоказателя;
		ИмяЯчейкиРасшифровки = Колонка + "_Расшифровка"; 
		
		Если Не ПоказательРасшифровки = Неопределено И НЕ ТаблицаСтрокГруппы.Колонки.Найти(ИмяЯчейкиРасшифровки) = Неопределено Тогда
			Строка[ИмяЯчейкиРасшифровки] = ПоказательРасшифровки;
		КонецЕсли;   
		
		// обновляем реквизиты формы
		Форма.ЗначениеВРеквизитФормы(ТаблицаСтрокГруппы,СтрокаДанных.ИмяРеквизитаТаблицыСтрокГруппы); 
		Форма.ЗначениеВРеквизитФормы(мСтруктураМногострочныхРазделов, "мСтруктураМногострочныхРазделов");
		
		Если Расчет Тогда 			
			Форма.ВыборРасчета(ИмяФормы, Инд, Колонка);			
		КонецЕсли;
		
		ИмяТПоле = ИмяФормы + "ПолеТабличногоДокумента" + ИмяГруппы;
		ТПоле = Форма[ИмяТПоле];
		Если тПоле.Области.Найти(Колонка) <> Неопределено Тогда 
			тПоле.Области[Колонка].Значение = ТаблицаСтрокГруппы.Итог(Колонка);				
		КонецЕсли;
	
	КонецЕсли;
	
	мМногострочнаяСтруктура = ПолучитьМногострочнуюСтруктуру(Форма, ИмяФормы);
	
	Если мМногострочнаяСтруктура.Свойство(ИмяГруппы, СтруктураГруппы) Тогда
		ОбщиеЭлементыГруппы = СтруктураГруппы.ШапкаИПодвал;
		ТаблицаСтрокГруппы  = СтруктураГруппы.Строки;
		
		//Заносим итоговое значение в общие элементы группы
		ЗаполнитьДанныеИтоговВСтруктуре(Форма, ТаблицаСтрокГруппы,ОбщиеЭлементыГруппы); 			
		ОбновитьМногострочнуюСтруктуру(Форма, ИмяФормы, мМногострочнаяСтруктура);
	КонецЕсли;
	                                                                                        
	Форма.Модифицированность = Истина;	
	
КонецПроцедуры  //ОбновитьМногострочнуюСтруктуруФормы()

// Обновляет структуру многострочных частей формы.
Процедура ОбновитьМногострочнуюСтруктуру(Форма, ТекущееИмяФормы, МногострочнаяСтруктура) Экспорт
	мСтруктураМногострочныхРазделов = Форма.РеквизитФормыВзначение("мСтруктураМногострочныхРазделов");
	
	СтрокаФормы = мСтруктураМногострочныхРазделов.Строки.Найти(ТекущееИмяФормы,"КодФормы");		
	
	СтрокаФормы.Строки.Очистить();		
	Для Каждого ЭлементСтруктуры Из МногострочнаяСтруктура Цикл
		ИмяТекущейГруппы = ЭлементСтруктуры.Ключ;					
		СтруктураДанных	 = ЭлементСтруктуры.Значение;
		
		ДанныеСтраницы = СтрокаФормы.Строки.Добавить();		
		ДанныеСтраницы.КодФормы = ТекущееИмяФормы;
		ДанныеСтраницы.ИмяГруппы = ИмяТекущейГруппы;  				
		ДанныеСтраницы.ОбщиеЭлементыГруппы 				= СтруктураДанных.ШапкаИПодвал;
		ДанныеСтраницы.ИмяРеквизитаТаблицыСтрокГруппы 	= СтруктураДанных.ИмяРеквизитаТаблицыСтрокГруппы;
	//	ДанныеСтраницы.ТаблицаРасшифровки 				= СтруктураДанных.ТаблицаРасшифровки;
		
		// Обновим таблицу строк группы
		Форма.ЗначениеВРеквизитФормы(СтруктураДанных.Строки, СтруктураДанных.ИмяРеквизитаТаблицыСтрокГруппы);		
	КонецЦикла;		
	
    Форма.ЗначениеВРеквизитФормы(мСтруктураМногострочныхРазделов, "мСтруктураМногострочныхРазделов");
КонецПроцедуры  //ОбновитьМногострочнуюСтруктуруФормы()

Процедура ОбновитьТаблицуСтрокГруппыВМногострочнойСтруктуре(Форма, ТекущееИмяФормы, ИмяГруппы, ТаблицаСтрокГруппы) Экспорт
	мСтруктураМногострочныхРазделов = Форма.РеквизитФормыВзначение("мСтруктураМногострочныхРазделов");	
	
	СтрокаФормы = мСтруктураМногострочныхРазделов.Строки.Найти(ТекущееИмяФормы,"КодФормы");	
	
	СтрокаГруппы = СтрокаФормы.Строки.Найти(ИмяГруппы);
	
	Если СтрокаГруппы = Неопределено Тогда
		Возврат;
	КонецЕсли;
			
    Форма.ЗначениеВРеквизитФормы(ТаблицаСтрокГруппы, СтрокаГруппы.ИмяРеквизитаТаблицыСтрокГруппы);
КонецПроцедуры  //ОбновитьТаблицуСтрокГруппыВМногострочнойСтруктуре()

// Функция получает из общей структуры хранения данных
// количество строк на листе. Используется для многострочных форм.
//
Функция ПолучитьКоличествоНаЛисте(ТекущееИмяФормы, мСписокФормБезИерархии) Экспорт
	
	НайденнаяСтрока = мСписокФормБезИерархии.Строки.Найти(ТекущееИмяФормы, "КодФормы");
	
	Если НайденнаяСтрока <> Неопределено Тогда 
		Возврат НайденнаяСтрока.КоличествоНаЛисте;
	Иначе
		Возврат 1;
	КонецЕсли;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ СОХРАНЕНИЯ ДАННЫХ РЕГЛАМЕНТИРОВАННЫХ ОТЧЕТОВ

&НаСервере
Процедура СохранитьОтчет(Форма) Экспорт
	
	ДатаНачалаЗамераВремени = ОценкаПроизводительности.НачатьЗамерВремени();
	
	// обновляем данные структуры
	РегламентированнаяОтчетность.ПередатьДанныеИзТабличногоПоляВСтруктуру(Форма);
	
	СтруктураРеквизитовФормы = Форма.СтруктураРеквизитовФормы;
	
	// формируем список показателей для списка сохранения
	мСписокСохранения = Новый Структура;
	Если Не ЗначениеЗаполнено(СтруктураРеквизитовФормы.мСохраненныйДок) ИЛИ (СтруктураРеквизитовФормы.мСохраненныйДок = Неопределено) Тогда
		// создаем новый документ вида РегламентированныйОтчет
		ДокументРеглОтчет = Документы.РегламентированныйОтчет.СоздатьДокумент();
				
		ДокументРеглОтчет.Дата = ТекущаяДатаСеанса();
		ДокументРеглОтчет.УстановитьВремя();
		ДокументРеглОтчет.УстановитьНомерДокументаОтчета();
		
	Иначе
		ДокументРеглОтчет = СтруктураРеквизитовФормы.мСохраненныйДок.ПолучитьОбъект();
	КонецЕсли;
	                          	
	// установим значения реквизитов документа
	МетаданныеОтчета = Форма.РеквизитФормыВЗначение("ОтчетОбъект"). Метаданные();
	ДокументРеглОтчет.ИсточникОтчета           = МетаданныеОтчета.Имя;
	ДокументРеглОтчет.НаименованиеОтчета       = МетаданныеОтчета.Формы.ОсновнаяФорма.Представление();
	ДокументРеглОтчет.ДатаНачала               = СтруктураРеквизитовФормы.мДатаНачалаПериодаОтчета;
	ДокументРеглОтчет.ДатаОкончания            = СтруктураРеквизитовФормы.мДатаКонцаПериодаОтчета;
	ДокументРеглОтчет.Периодичность            = СтруктураРеквизитовФормы.мПериодичность;  
	ДокументРеглОтчет.ДатаПодписи              = Форма.ДатаПодписи;
	ДокументРеглОтчет.ВыбраннаяФорма           = Форма.мВыбраннаяФорма;
	ДокументРеглОтчет.Организация              = Форма.Налогоплательщик;
	ДокументРеглОтчет.НалоговыйКомитет         = СтруктураРеквизитовФормы.НалоговыйКомитет;
	ДокументРеглОтчет.ЕдиницаИзмерения         = СтруктураРеквизитовФормы.ЕдиницаИзмерения;
	ДокументРеглОтчет.ТочностьЕдиницыИзмерения = СтруктураРеквизитовФормы.ТочностьЕдиницыИзмерения;
	ДокументРеглОтчет.ВидОтчетности            = Перечисления.ВидыОтчетности.РегламентированнаяОтчетность;
	ДокументРеглОтчет.Комментарий              = Форма.Комментарий;
	 	
		
	// сохраним реквизиты формы
	СтруктураДополнительныхРеквизитовФормы = Новый Структура();	
	МассивРеквизитовФормы = Форма.ПолучитьРеквизиты();
	Для Счетчик = 0 По МассивРеквизитовФормы.Количество()-1 Цикл		
		РеквизитФормы = МассивРеквизитовФормы[Счетчик];
		Если РеквизитФормы.Имя = "ОтчетОбъект" или РеквизитФормы.ТипЗначения.СодержитТип(Тип("ОтчетОбъект")) Тогда
			Продолжить;
		КонецЕсли;	
		
		Если РеквизитФормы.ТипЗначения.СодержитТип(Тип("ДеревоЗначений")) ИЛИ РеквизитФормы.ТипЗначения.СодержитТип(Тип("ТаблицаЗначений")) Тогда
			СтруктураДополнительныхРеквизитовФормы.Вставить(РеквизитФормы.Имя, Форма.РеквизитФормыВЗначение(РеквизитФормы.Имя));
		Иначе
			СтруктураДополнительныхРеквизитовФормы.Вставить(РеквизитФормы.Имя, Форма[РеквизитФормы.Имя]);
		КонецЕсли;
	КонецЦикла;	
	
	мСписокСохранения.Вставить("СтруктураДополнительныхРеквизитовФормы", СтруктураДополнительныхРеквизитовФормы);
	
	// Сохраняем документ
	Если ДокументРеглОтчет <> Неопределено Тогда
		
		ХранилищеДанных = Новый ХранилищеЗначения(мСписокСохранения);
		ДокументРеглОтчет.ДанныеОтчета = ХранилищеДанных;
		
		СохранитьОшибка = 1;
		
		// записываем документ, хранящий данные отчета
		Попытка
			ДокументРеглОтчет.Записать();
		Исключение
			ОбщегоНазначения.СообщитьПользователю(НСтр("ru = 'Не удается сохранить регламентированный отчет!'") + Символы.ПС + ОписаниеОшибки());
			СохранитьОшибка = 0;
		КонецПопытки;
		
		Если СохранитьОшибка = 1 Тогда
			// всё прошло без ошибок
			Форма.Модифицированность = Ложь;
		КонецЕсли;		
	КонецЕсли;
	
	СтруктураРеквизитовФормы.мСохраненныйДок = ДокументРеглОтчет.Ссылка;
	
	Сообщение = Новый СообщениеПользователю;
	Сообщение.Текст = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Записан документ %1 %2'"), ДокументРеглОтчет.Ссылка, ДокументРеглОтчет.Ссылка.Комментарий);
	Сообщение.ИдентификаторНазначения = Форма.УникальныйИдентификатор;
	Сообщение.Сообщить();
	
	КлючеваяОперация = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Документ ""%1"" (запись)'"), НРег(МетаданныеОтчета.Синоним));
	ОценкаПроизводительности.ЗакончитьЗамерВремени(КлючеваяОперация, ДатаНачалаЗамераВремени);
	
КонецПроцедуры

Процедура ВосстановитьСохраненныйОтчет(Форма) Экспорт 
	Перем ПоказателиОтчета;
	Перем Автозаполнение;	
	
	мСохраненныйДок = Форма.СтруктураРеквизитовФормы.мСохраненныйДок;
	
	Форма.СтруктураРеквизитовФормы.Организация = мСохраненныйДок.Организация;
		
	Форма.ДатаПодписи	                              		= мСохраненныйДок.ДатаПодписи;
	Форма.СтруктураРеквизитовФормы.ЕдиницаИзмерения   		= мСохраненныйДок.ЕдиницаИзмерения;
	Форма.СтруктураРеквизитовФормы.ТочностьЕдиницыИзмерения = мСохраненныйДок.ТочностьЕдиницыИзмерения;
	Форма.Комментарий					              		= мСохраненныйДок.Комментарий;
	Форма.Налогоплательщик					         		= мСохраненныйДок.Организация;
	
	// восстанавливаем сохраненные данные отчета
	СписокСохранения = мСохраненныйДок.ДанныеОтчета.Получить();
	
	//Если есть "ПоказателиОтчета", значит сохранение было отчета в структуре данных, редакции, ниже 3.0
	
	Если СписокСохранения.Свойство("ПоказателиОтчета") Тогда
		ВосстановитьСохраненныеДанныеСтруктурыРедакцийНиже3_0(Форма, СписокСохранения);
	Иначе
		СтруктураДополнительныхРеквизитовФормы = СписокСохранения.СтруктураДополнительныхРеквизитовФормы;	
		Для Каждого СохраненныйРеквизит из СтруктураДополнительныхРеквизитовФормы Цикл
			// Для внутреннего использования
			Для Каждого РеквизитФормы Из Форма.ПолучитьРеквизиты() Цикл
				Если ВРег(РеквизитФормы.Имя) <> ВРег(СохраненныйРеквизит.Ключ) Тогда
					Продолжить;
				КонецЕсли;	                                                                                                                       
				
				Если РеквизитФормы.ТипЗначения.СодержитТип(Тип("ТабличныйДокумент")) Тогда
					Продолжить;
				КонецЕсли;				
				
				Если РеквизитФормы.ТипЗначения.СодержитТип(Тип("ДеревоЗначений")) ИЛИ РеквизитФормы.ТипЗначения.СодержитТип(Тип("ТаблицаЗначений")) Тогда					
					Форма.ЗначениеВРеквизитФормы(СохраненныйРеквизит.Значение, СохраненныйРеквизит.Ключ);
				Иначе
					Форма[РеквизитФормы.Имя] = СохраненныйРеквизит.Значение;
				КонецЕсли;			
				
			КонецЦикла;
		КонецЦикла;
	КонецЕсли;

	Если ЕстьРеквизитФормы(Форма,"ЯзыкФормирования") = Истина Тогда
		Форма.ЗагрузитьМакетВТабличныйДокумент();
	КонецЕсли;
	
	//обновим мСохраненныйДок
	Форма.СтруктураРеквизитовФормы.мСохраненныйДок = мСохраненныйДок;
	
	Для Каждого ТекФорма из Форма.мСписокФормБезИерархии.ПолучитьЭлементы() Цикл
		//Форма.ЗаполнитьПараметры(ТекФорма.КодФормы);
		РегламентированнаяОтчетность.ПередатьДанныеИзСтруктурыВТабличноеПоле(Форма, ТекФорма.КодФормы);
	КонецЦикла;	
	
	Форма.Модифицированность   = Ложь;
	
КонецПроцедуры

Процедура ВосстановитьСохраненныеДанныеСтруктурыРедакцийНиже3_0(Форма, СписокСохранения)
	                   	
	СписокФормБезИерархии = Форма.РеквизитФормыВЗначение("мСписокФормБезИерархии");
	СписокФормБезИерархииИсточник = СписокСохранения.ПоказателиОтчета;	
	МассивПрефиксовФорм = Новый Массив();
	
	Если СписокФормБезИерархииИсточник <> Неопределено И ТипЗнч(СписокФормБезИерархииИсточник) = Тип("ДеревоЗначений") Тогда
		
		Для Каждого Строка Из СписокФормБезИерархии.Строки Цикл
			МассивПрефиксовФорм.Добавить(Сред(Строка.КодФормы,6));
			СтрокаИсточник = СписокФормБезИерархииИсточник.Строки.Найти(Строка.КодФормы,"КодФормы");
			Если СтрокаИсточник <> Неопределено Тогда
				Строка.Автозаполнение = СтрокаИсточник.Автозаполнение;
				Строка.АвтополучениеИтогов = СтрокаИсточник.АвтополучениеИтогов;
				Строка.Выгружать = СтрокаИсточник.Выгружать;
				Строка.ПоказатьСтраницу = СтрокаИсточник.ПоказатьСтраницу;
				//Перенесем сохраненные значения в дерево значений
				ЗначениеСтроки = Строка.Значение;
				ЗначениеИсточника = СтрокаИсточник.Значение;
						
				Если Строка.Многострочность = 1 Тогда                                               	
					ДанныеСтрокиИсточника = ЗначениеИсточника[0].Данные;
					
					СтруктураГруппы = Неопределено;
					мМногострочнаяСтруктура = ПолучитьМногострочнуюСтруктуру(Форма, Строка.КодФормы);										
					// данные (структура)
					Для Каждого Элемент Из ДанныеСтрокиИсточника Цикл
						ИмяГруппы    = Элемент.Ключ;
						ЗначениеЛиста = Элемент.Значение;			
						
						//найдем по ключу сохраненные данные для данного листа многостр.формы
						Если мМногострочнаяСтруктура.Свойство(ИмяГруппы, СтруктураГруппы) Тогда
							СтрокиЛиста       = СтруктураГруппы.Строки;
							СтрокиЛиста.Очистить();
							ШапкаИПодвалЛиста = СтруктураГруппы.ШапкаИПодвал;                  
							
							ЗначениеЛистаИсточника    = Неопределено; // также тип "Структура"
							ДанныеСтрокиИсточника.Свойство(ИмяГруппы,ЗначениеЛистаИсточника);
							СтрокиЛистаИсточника       = ЗначениеЛистаИсточника.Строки; // тип "ТаблицаЗначений"
							ШапкаИПодвалЛистаИсточника = ЗначениеЛистаИсточника.ШапкаИПодвал; // тип "ТаблицаЗначений"
							
							ТаблицаРасшифровкиСтрокиИсточника = ЗначениеИсточника[0].ТаблицаРасшифровки;
																			
							Для Каждого СтрокаЛистаИсточника Из СтрокиЛистаИсточника Цикл
								НоваяСтрока  = СтрокиЛиста.Добавить() ;
								ЗаполнитьЗначенияСвойств(НоваяСтрока,СтрокаЛистаИсточника);																		
							КонецЦикла;      						    						
							
							// заменим ШАПКАиПОДВАЛ многострочной формы данного листа сохраненными данными
							Для Каждого СтрокаШапки Из ШапкаИПодвалЛиста Цикл
								// ищем сохраненное значение в таблице ШапкаИПодвалЛистаИсточника
								НайденнаяСтрокаШапки = ШапкаИПодвалЛистаИсточника.Найти(СтрокаШапки.ИмяОбласти,"ИмяОбласти");
								Если НайденнаяСтрокаШапки <> Неопределено Тогда
									СтрокаШапки.Значение = НайденнаяСтрокаШапки.Значение;							
								КонецЕсли;                  							
							КонецЦикла;
												            							
							//Строки расшифровки
							Для Каждого Колонка Из СтрокиЛистаИсточника.Колонки Цикл
								Для Индекс = 0 По СтрокиЛиста.Количество() - 1 Цикл
									СтруктураПоиска = Новый Структура();
									СтруктураПоиска.Вставить("ИмяГруппы", ИмяГруппы);
									СтруктураПоиска.Вставить("ИмяЯчейки", Колонка.Имя);
									СтруктураПоиска.Вставить("НомерСтроки", Индекс + 1);
									СтрокиРасшифровки = ТаблицаРасшифровкиСтрокиИсточника.НайтиСтроки(СтруктураПоиска);
									Если СтрокиРасшифровки.Количество() <> 0 Тогда
										Расшифровка = СтрокиРасшифровки[0].ПолеПоиска;
										ИмяРасшифровки = Колонка.Имя + "_Расшифровка";		
										ТекСтрока = СтрокиЛиста[Индекс];
										ТекСтрока[ИмяРасшифровки] = Расшифровка;										
									КонецЕсли;									
								КонецЦикла;								
							КонецЦикла  							
						КонецЕсли;						
					КонецЦикла;
					
					ОбновитьМногострочнуюСтруктуру(Форма, Строка.КодФормы,мМногострочнаяСтруктура); 
					     					
										      				
				Иначе // форма обычная
					ЗначениеИсточника.Индексы.Добавить("ИмяОбласти");
					Для Каждого СтрокаТаблицы Из ЗначениеСтроки Цикл
						// ищем сохраненное значение в таблице ЗначениеИсточника
						НайденнаяСтрока = ЗначениеИсточника.Найти(СтрокаТаблицы.ИмяОбласти,"ИмяОбласти");
						Если НайденнаяСтрока <> Неопределено Тогда
							СтрокаТаблицы.Значение = НайденнаяСтрока.Значение;							
						КонецЕсли;
					КонецЦикла;					
				КонецЕсли;	
				КонецЕсли;
			КонецЦикла;
		//восстанавливаем фин.отчетность		
	ИначеЕсли СписокФормБезИерархииИсточник <> Неопределено И ТипЗнч(СписокФормБезИерархииИсточник) = Тип("Структура")  Тогда		
		
		Для Каждого ЭлементТП Из  СписокФормБезИерархииИсточник Цикл
			Для Каждого ОбластьТП Из ЭлементТП.Значение  Цикл 				
				Для Каждого Строка Из СписокФормБезИерархии.Строки Цикл
					ТаблицаОбластей = Строка.Значение;
					Если НЕ ТипЗнч(ТаблицаОбластей) = Тип("ТаблицаЗначений") Тогда
						Продолжить;
					КонецЕсли;
					ИскомаяОбласть = ТаблицаОбластей.Найти(ОбластьТП.Ключ, "ИмяОбласти");
					Если  ИскомаяОбласть = Неопределено Тогда
						Продолжить;
					Иначе
						ИскомаяОбласть.Значение = ОбластьТП.Значение;
						Прервать;						
					КонецЕсли;
					
				КонецЦикла;
			КонецЦикла;			
		КонецЦикла; 	
	КонецЕсли;
	
	Форма.ЗначениеВРеквизитФормы(СписокФормБезИерархии, "мСписокФормБезИерархии");
	Форма.ТекущаяСтраница = 1;
		
	//восстановим реквизиты формы
	Для Каждого ЭлементСохранения Из СписокСохранения Цикл
		
		Если ВРег(ЭлементСохранения.Ключ) = ВРег("ПоказателиОтчета") И ТипЗнч(СписокФормБезИерархииИсточник) = Тип("ДеревоЗначений") Тогда
			Продолжить;
		КонецЕсли;	
		
		Если ЭлементСохранения.Ключ = ("СписокСтруктурныхЕдиниц")  Тогда
			Ключ = "мСписокСтруктурныхЕдиниц" ;
		Иначе
			Ключ = ЭлементСохранения.Ключ;
		КонецЕсли;
		
		Если ЕстьРеквизитФормы(Форма, Ключ) Тогда
			Форма[Ключ] = ЭлементСохранения.Значение;
			Если ВРег(Ключ) = Врег("мСписокСтруктурныхЕдиниц") И ЕстьРеквизитФормы(Форма,"ПредставлениеСпискаСтруктурныхЕдиниц") Тогда
				Форма.ПредставлениеСпискаСтруктурныхЕдиниц	= БухгалтерскиеОтчетыКлиентСервер.ВыгрузитьСписокВСтроку(ЭлементСохранения.Значение);
			КонецЕсли;	
		Иначе
			Для Каждого ЭлементПрефиксов Из МассивПрефиксовФорм	Цикл
				СтрокаПоиска = Найти(ЭлементСохранения.Ключ, "_" +ЭлементПрефиксов);
				Если  СтрокаПоиска > 0 Тогда
					//берем реквизит без префикса
					Ключ = Сред(ЭлементСохранения.Ключ,1,СтрокаПоиска-1);					
					Если ЕстьРеквизитФормы(Форма, Ключ) Тогда					
						Форма[Ключ] = ЭлементСохранения.Значение;
					КонецЕсли; 
				КонецЕсли;				
			КонецЦикла;	
		КонецЕсли; 		
	КонецЦикла; 	
	
КонецПроцедуры


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ПЕЧАТИ РЕГЛАМЕНТИРОВАННЫХ ОТЧЕТОВ

Функция ОпределитьОриентациюСтраницы(ТекущееИмяФормы, мСписокФормБезИерархии) Экспорт 
	
	НайденнаяСтрока = мСписокФормБезИерархии.Строки.Найти(ТекущееИмяФормы, "КодФормы");
	
	Если НайденнаяСтрока <> Неопределено Тогда 
		Если НайденнаяСтрока.ОриентацияСтр = "Портрет" Тогда
			ТекОриентация = ОриентацияСтраницы.Портрет;
		Иначе
			ТекОриентация = ОриентацияСтраницы.Ландшафт;
		КонецЕсли;
		Возврат ТекОриентация;
	Иначе
		Возврат ОриентацияСтраницы.Портрет;
	КонецЕсли;
	
КонецФункции

Функция ПринтерДоступен() Экспорт
	
	ТаблДок = Новый ТабличныйДокумент;
	Возврат ОбщегоНазначения.ПроверитьВыводТабличногоДокумента(ТаблДок, ТаблДок, Ложь);
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// СЛУЖЕБНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ

// Возвращает признак использования внешнего отчета с учетом кэша (реквизит ВнешнийОтчетИспользовать), 
// для переданного в качестве параметра элемента справочника РегламентированныеОтчеты.
// Параметры:
//		РеглОтч - СправочникСсылка.РегламентированныеОтчеты - ссылка на элемент справочника РегламентированныеОтчеты.
//
// Возвращаемое значение:
//		Признак использования внешнего отчета для заданного элемента справочника с учетом кэша.
//
Функция ПризнакИспользованияВнешнегоОтчетаСУчетомКэша(РеглОтч)
	
	Перем ОтчетВКэше;
	
	Попытка
		Кэш = ПараметрыСеанса.ХранилищеПараметровВнешнихРегламентированныхОтчетов.Получить();
	Исключение
		Кэш = Новый Структура;
	КонецПопытки;
	
	Если Кэш.Свойство(РеглОтч.ИсточникОтчета, ОтчетВКэше) Тогда
		Возврат ОтчетВКэше.Признак;
	Иначе
		Попытка
			ВнешнийОтчетИспользовать = РеглОтч.ВнешнийОтчетИспользовать;
			Кэш.Вставить(РеглОтч.ИсточникОтчета, Новый Структура("Отчет, Признак", РеглОтч.ВнешнийОтчетХранилище.Получить(), ВнешнийОтчетИспользовать));
			ПараметрыСеанса.ХранилищеПараметровВнешнихРегламентированныхОтчетов = Новый ХранилищеЗначения(Кэш);
			Возврат ВнешнийОтчетИспользовать;
		Исключение
			Возврат Неопределено;
		КонецПопытки;
	КонецЕсли;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ МЕХАНИЗМА ПОДДЕРЖКИ ВНЕШНИХ РЕГЛАМЕНТИРОВАННЫХ ОТЧЕТОВ

Функция ПродолжитьПриНесоответствииВерсийФорм(Знач ВерсияФормы, Знач мВерсияФормы) Экспорт
	
	ПервыйСлеш = Найти(ВерсияФормы, "/");
	ВторойСлеш = Найти(Лев(ВерсияФормы, ПервыйСлеш - 1) + " " + Сред(ВерсияФормы, ПервыйСлеш + 1), "/");
	Если ПервыйСлеш = Неопределено ИЛИ ВторойСлеш = Неопределено Тогда
		Возврат Истина;
	КонецЕсли;
	ГодВерсияФормы = Сред(ВерсияФормы, ВторойСлеш + 1);
	МесяцВерсияФормы = Сред(ВерсияФормы, ПервыйСлеш + 1, ВторойСлеш - ПервыйСлеш - 1);
	ДеньВерсияФормы = Сред(ВерсияФормы, 1, ПервыйСлеш - 1);
	Если СтрДлина(ГодВерсияФормы) = 2 Тогда
		ГодВерсияФормы = "20" + ГодВерсияФормы;
	КонецЕсли;
	Если СтрДлина(МесяцВерсияФормы) = 1 Тогда
		МесяцВерсияФормы = "0" + МесяцВерсияФормы;
	КонецЕсли;
	Если СтрДлина(ДеньВерсияФормы) = 1 Тогда
		ДеньВерсияФормы = "0" + ДеньВерсияФормы;
	КонецЕсли;
	ДатаВерсияФормы = Дата(ГодВерсияФормы + МесяцВерсияФормы + ДеньВерсияФормы);
	
	ПервыйСлеш = Найти(мВерсияФормы, "/");
	ВторойСлеш = Найти(Лев(мВерсияФормы, ПервыйСлеш - 1) + " " + Сред(мВерсияФормы, ПервыйСлеш + 1), "/");
	Если ПервыйСлеш = Неопределено ИЛИ ВторойСлеш = Неопределено Тогда
		Возврат Истина;
	КонецЕсли;
	ГодмВерсияФормы = Сред(мВерсияФормы, ВторойСлеш + 1);
	МесяцмВерсияФормы = Сред(мВерсияФормы, ПервыйСлеш + 1, ВторойСлеш - ПервыйСлеш - 1);
	ДеньмВерсияФормы = Сред(мВерсияФормы, 1, ПервыйСлеш - 1);
	Если СтрДлина(ГодмВерсияФормы) = 2 Тогда
		ГодмВерсияФормы = "20" + ГодмВерсияФормы;
	КонецЕсли;
	Если СтрДлина(МесяцмВерсияФормы) = 1 Тогда
		МесяцмВерсияФормы = "0" + МесяцмВерсияФормы;
	КонецЕсли;
	Если СтрДлина(ДеньмВерсияФормы) = 1 Тогда
		ДеньмВерсияФормы = "0" + ДеньмВерсияФормы;
	КонецЕсли;
	ДатамВерсияФормы = Дата(ГодмВерсияФормы + МесяцмВерсияФормы + ДеньмВерсияФормы);
	
	Если ДатамВерсияФормы < ДатаВерсияФормы Тогда
		
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='Сохраненные данные не могут быть открыты текущей версией отчета!
		|Версия отчета - от %1
		|Версия данных - от %2'"), Формат(ДатамВерсияФормы, "ДЛФ=DD; ДП='Пустая дата'"), Формат(ДатаВерсияФормы,  "ДЛФ=DD; ДП='Пустая дата'"));
		ОбщегоНазначения.СообщитьПользователю(ТекстСообщения);
		
		Возврат Ложь;
		
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ СО СТРУКТУРОЙ ХРАНЕНИЯ ДАННЫХ РЕГЛАМЕНТИРОВАННЫХ ОТЧЕТОВ

//Процедура заполняет дерево значений списком форм данного приложения
// 
// Параметры: Объект - объект регламентированного отчета
// 
Процедура ЗаполнитьДеревоСтраниц(Объект)
	
	Префикс = Прав(Объект.мВыбраннаяФорма, 7);
	
	СписокФорм = Объект.РеквизитФормыВЗначение("СписокФормДерева");
	//очищаем все данные
	СписокФорм.Строки.Очистить();
	
	ТаблицаУпорядочивания = Новый ТаблицаЗначений;
	ТаблицаУпорядочивания.Колонки.Добавить("Страницы");                     
	ТаблицаУпорядочивания.Колонки.Добавить("КодФормы");
	ТаблицаУпорядочивания.Колонки.Добавить("ИмяФормы");
	ТаблицаУпорядочивания.Колонки.Добавить("ПоказатьСтраницу");
	ТаблицаУпорядочивания.Колонки.Добавить("Выгружать");
	ТаблицаУпорядочивания.Колонки.Добавить("Многострочность");
	ТаблицаУпорядочивания.Колонки.Добавить("ПризнакОсновной");
	ТаблицаУпорядочивания.Колонки.Добавить("ЗаголовокФормы");   
	ТаблицаУпорядочивания.Колонки.Добавить("АвтополучениеИтогов");  
	ТаблицаУпорядочивания.Колонки.Добавить("АвтоЗаполнение");  
	ТаблицаУпорядочивания.Колонки.Добавить("КоличествоНаЛисте");  
	ТаблицаУпорядочивания.Колонки.Добавить("ОриентацияСтр");  
	ТаблицаУпорядочивания.Колонки.Добавить("Верх"); 
	ТаблицаУпорядочивания.Колонки.Добавить("ФормаРодитель");
	ТаблицаУпорядочивания.Колонки.Добавить("ИспользуетсяМакет");	
	ТаблицаУпорядочивания.Колонки.Добавить("ВыводНаПечать");	
	
	Макет = Объект.РеквизитФормыВЗначение("ОтчетОбъект").ПолучитьМакет("Показатели");
	
	Для  НомерОбласти = 0 По  Макет.Области.Количество() -1 Цикл
		Область = Макет.Области[НомерОбласти];
		
		Если Прав(Область.Имя,7) = Префикс Тогда
			
			ИмяФормыXML      	= СокрП(Макет.Область(Область.Верх, 1).Текст);
			ИмяСтраницы      	= СокрП(Макет.Область(Область.Верх, 2).Текст);
			ПоказатьСтраницу 	= СокрП(Макет.Область(Область.Верх, 3).Текст);
			Выгружать        	= СокрП(Макет.Область(Область.Верх, 4).Текст);
			Признакосновной  	= СокрП(Макет.Область(Область.Верх, 5).Текст);
			Многострочность  	= СокрП(Макет.Область(Область.Верх, 6).Текст);
			КодФормы        	= СокрП(Макет.Область(Область.Верх, 7).Текст);
			ФормаРодитель    	= СокрП(Макет.Область(Область.Верх, 8).Текст);  
			ЗаголовокФормы      = СокрП(Макет.Область(Область.Верх, 9).Текст);  
			КоличествоНаЛисте   = СокрП(Макет.Область(Область.Верх, 10).Текст);  		
			ОриентацияСтр       = СокрП(Макет.Область(Область.Верх, 11).Текст);  
			ИспользуетсяМакет   = СокрП(Макет.Область(Область.Верх, 13).Текст);  
			
			
			НоваяСтрока = ТаблицаУпорядочивания.Добавить();
			НоваяСтрока.Верх = Область.Верх;	
			НоваяСтрока.ИмяФормы            = ИмяФормыXML;
			НоваяСтрока.КодФормы            = КодФормы;
			НоваяСтрока.Страницы            = ИмяСтраницы;
			НоваяСтрока.Многострочность     = Многострочность;
			НоваяСтрока.Выгружать           = Выгружать;
			НоваяСтрока.Признакосновной     = ПризнакОсновной;
			НоваяСтрока.ПоказатьСтраницу    = ПоказатьСтраницу;	
			НоваяСтрока.ФормаРодитель       = ФормаРодитель;	
			НоваяСтрока.ЗаголовокФормы      = ЗаголовокФормы;  
			НоваяСтрока.АвтополучениеИтогов = 1;           
			НоваяСтрока.АвтоЗаполнение      = 1;           
			НоваяСтрока.КоличествоНаЛисте   = КоличествоНаЛисте;           
			НоваяСтрока.ОриентацияСтр       = ОриентацияСтр;          
			НоваяСтрока.ИспользуетсяМакет 	= ?(ВРЕГ(ИспользуетсяМакет) = "ИСТИНА", Истина, Ложь);
			НоваяСтрока.ВыводНаПечать       = Истина;          
		КонецЕсли;
	КонецЦикла;  	
	ТаблицаУпорядочивания.Сортировать("Верх");
	Для Каждого СтрокаТаблицы ИЗ ТаблицаУпорядочивания Цикл
		
		Если СтрокаТаблицы.ФормаРодитель = "Дерево" Тогда
			Строка = СписокФорм.Строки.Добавить();
		Иначе
			СтрокаРодитель = СписокФорм.Строки.Найти(СтрокаТаблицы.ФормаРодитель, "КодФормы", Истина);
			Если СтрокаРодитель <> Неопределено Тогда
				Строка = СтрокаРодитель.Строки.Добавить();
			Иначе
				Строка = СписокФорм.Строки.Добавить();			
			КонецЕсли;
		КонецЕсли;   	
		Строка.ИмяФормы              = СтрокаТаблицы.ИмяФормы;
		Строка.КодФормы        		 = СтрокаТаблицы.КодФормы;
		Строка.Страницы       		 = СтрокаТаблицы.Страницы;
		Строка.ЗаголовокФормы  		 = СтрокаТаблицы.ЗаголовокФормы; 
		Строка.КоличествоНаЛисте     = Число(СтрокаТаблицы.КоличествоНаЛисте); 
		Строка.ОриентацияСтр         = СтрокаТаблицы.ОриентацияСтр; 
		Строка.АвтополучениеИтогов   = СтрокаТаблицы.АвтополучениеИтогов; 
		Строка.АвтоЗаполнение        = СтрокаТаблицы.АвтоЗаполнение; 
		Строка.Многострочность 		 = Число(СтрокаТаблицы.Многострочность);
		Строка.Выгружать       		 = Число(СтрокаТаблицы.Выгружать);
		Строка.Признакосновной 		 = Число(СтрокаТаблицы.ПризнакОсновной);
		Строка.ПоказатьСтраницу		 = Число(СтрокаТаблицы.ПоказатьСтраницу);			
		Строка.ИспользуетсяМакет 	 = СтрокаТаблицы.ИспользуетсяМакет; 
		Строка.ВыводНаПечать         = СтрокаТаблицы.ВыводНаПечать;         
		
	КонецЦикла;
	
	Объект.ЗначениеВРеквизитФормы(СписокФорм, "СписокФормДерева");	
КонецПроцедуры

// Процедура заполняет таблицу значений списком показателей
// для передачи данных из форм в формы
//
// Параметры: Объект - объект регламентированного отчета
//
Процедура ЗаполнитьТаблицуПередачиДанных(Объект)
	
	Префикс = Прав(Объект.мВыбраннаяФорма, 7);
	ТаблицаПоказателей = Объект.РеквизитФормыВЗначение("мТаблицаПоказателейДляПередачиДанных");
	//ТаблицаПоказателей = Объект.мТаблицаПоказателейДляПередачиДанных;
	//очищаем все данные
	ТаблицаПоказателей.Очистить();
	
	ТаблицаУпорядочивания = Новый ТаблицаЗначений;
	ТаблицаУпорядочивания.Колонки.Добавить("КодФормыИсточник");                     
	ТаблицаУпорядочивания.Колонки.Добавить("ИмяОбластиИсточник");
	ТаблицаУпорядочивания.Колонки.Добавить("КодФормыПриемник");
	ТаблицаУпорядочивания.Колонки.Добавить("ИмяОбластиПриемник");
	ТаблицаУпорядочивания.Колонки.Добавить("Верх");
	
	Макет = Объект.РеквизитФормыВЗначение("ОтчетОбъект").ПолучитьМакет("ПередачаДанных");
	
	Для  НомерОбласти = 0 По  Макет.Области.Количество() -1 Цикл
		Область = Макет.Области[НомерОбласти];
		
		Если Прав(Область.Имя,7) = Префикс Тогда
			
			Для Ном = Область.Верх По Область.Низ Цикл
				// перебираем строки области
				ФормаИсточник      	= СокрП(Макет.Область(Ном, 1).Текст);
				ОбластьИсточник    	= СокрП(Макет.Область(Ном, 2).Текст);
				ФормаПриемник		= СокрП(Макет.Область(Ном, 3).Текст);
				ОбластьПриемник    	= СокрП(Макет.Область(Ном, 4).Текст);
				
				НоваяСтрока = ТаблицаУпорядочивания.Добавить();
				НоваяСтрока.Верх = Ном;	
				НоваяСтрока.КодФормыИсточник    = ФормаИсточник;
				НоваяСтрока.ИмяОбластиИсточник  = ОбластьИсточник;
				НоваяСтрока.КодФормыПриемник    = ФормаПриемник;
				НоваяСтрока.ИмяОбластиПриемник  = ОбластьПриемник;
			КонецЦикла;
			
		КонецЕсли;
	КонецЦикла;  	
	ТаблицаУпорядочивания.Сортировать("Верх");
	Для Каждого СтрокаТаблицы ИЗ ТаблицаУпорядочивания Цикл
		
		Строка = ТаблицаПоказателей.Добавить();
		
		Строка.КодФормыИсточник    = СтрокаТаблицы.КодФормыИсточник;
		Строка.ИмяОбластиИсточник  = СтрокаТаблицы.ИмяОбластиИсточник;
		Строка.КодФормыПриемник    = СтрокаТаблицы.КодФормыПриемник;
		Строка.ИмяОбластиПриемник  = СтрокаТаблицы.ИмяОбластиПриемник; 
		
	КонецЦикла;
	
	Объект.ЗначениеВРеквизитФормы(ТаблицаПоказателей, "мТаблицаПоказателейДляПередачиДанных");	
КонецПроцедуры // ЗаполнитьТаблицуПередачиДанных()

// Процедура формирует структуру хранения данных
// для многострочных форм
//
Функция СформироватьСтруктуруМногострочнойФормы(мТекущаяЗакладка, ФормаПериода,Макет, мСтруктураМногострочныхРазделов) Экспорт
	
	Если Макет = Неопределено Тогда
		ОбщегоНазначения.СообщитьПользователю(НСтр("ru = 'Не найден макет для многострочных форм!!!'"));
		Возврат Неопределено;
	КонецЕсли;
	СтрокаФормы = мСтруктураМногострочныхРазделов.Строки.Добавить();
	СтрокаФормы.КодФормы = мТекущаяЗакладка;
	
	//Формируем структуры групп для многострочных форм 
	ДанныеМногострочнойФормы = Новый ТаблицаЗначений;
	ДанныеМногострочнойФормы.Колонки.Добавить("ИмяГруппы");
	ДанныеМногострочнойФормы.Колонки.Добавить("ОбщиеЭлементыГруппы");
	ДанныеМногострочнойФормы.Колонки.Добавить("ТаблицаСтрокГруппы");
	
	ТаблицаРасшифровки = Новый ТаблицаЗначений;         
	ТаблицаРасшифровки.Колонки.Добавить("ИмяГруппы");   
	ТаблицаРасшифровки.Колонки.Добавить("ИмяЯчейки");   
	ТаблицаРасшифровки.Колонки.Добавить("ПолеПоиска");  
	ТаблицаРасшифровки.Колонки.Добавить("НомерСтроки");
	ТаблицаРасшифровки.Индексы.Добавить("НомерСтроки");
	ТаблицаРасшифровки.Индексы.Добавить("ИмяЯчейки");
			

	// структура многострочных разделов формы              	
	мМногострочнаяСтруктура = Новый Структура;
	ИмяПанелиФормы = "Панель" + мТекущаяЗакладка;
	Для Каждого Страница Из ФормаПериода.Элементы[ИмяПанелиФормы].ПодчиненныеЭлементы Цикл
		ИмяСтраницыБезПрефиксаПанели =  СтрЗаменить(Страница.Имя, ИмяПанелиФормы, ""); // ИмяСтраницыБезПерфиксаПанели
		ИмяГруппы = ИмяСтраницыБезПрефиксаПанели;
		ОбластьШапка  = Неопределено;
		ОбластьИтог   = Неопределено;
		ОбластьСтрока = Неопределено;
		ОбластьПодвал = Неопределено;
		Если Макет.Области.Найти("Шапка"   + мТекущаяЗакладка + ИмяГруппы) <> Неопределено Тогда
			ОбластьШапка  = Макет.ПолучитьОбласть("Шапка"  + мТекущаяЗакладка + ИмяГруппы);	 
		КонецЕсли;
		Если Макет.Области.Найти("Итог"   + мТекущаяЗакладка + ИмяГруппы) <> Неопределено Тогда
			ОбластьИтог   = Макет.ПолучитьОбласть("Итог"   + мТекущаяЗакладка + ИмяГруппы);	
		КонецЕсли;
		Если Макет.Области.Найти("Строка"   + мТекущаяЗакладка + ИмяГруппы) <> Неопределено Тогда
			ОбластьСтрока = Макет.ПолучитьОбласть("Строка" + мТекущаяЗакладка + ИмяГруппы);
		КонецЕсли;
		Если Макет.Области.Найти("Подвал"   + мТекущаяЗакладка + ИмяГруппы) <> Неопределено Тогда
			ОбластьПодвал = Макет.ПолучитьОбласть("Подвал" + мТекущаяЗакладка + ИмяГруппы); 
		КонецЕсли;
		
		ТаблицаСтрокГруппы = Новый ТаблицаЗначений;
		Если ОбластьСтрока <> Неопределено Тогда
			Для каждого Область Из ОбластьСтрока.Области Цикл
				// Область может включать саму себ. исключаем ее из структуры
				Если Врег(Область.Имя) = Врег("Строка" + мТекущаяЗакладка + ИмяГруппы) Тогда
					Продолжить;
				КонецЕсли;
				//отсекаем 3 последних символа "__1"
				ИмяКолонки = Лев(Область.Имя,СтрДлина(Область.Имя) - 3);
				ТаблицаСтрокГруппы.Колонки.Добавить(ИмяКолонки);
							
				ИмяКолонкиРасшифровки = ИмяКолонки + "_Расшифровка";
				ТаблицаСтрокГруппы.Колонки.Добавить(ИмяКолонкиРасшифровки);
			КонецЦикла;
		КонецЕсли;
		// добавим реквизит этого типа
		МассивРеквизитов = Новый Массив;
		МассивТипаВыбора = Новый Массив;
		МассивТипаВыбора.Добавить(Тип("ТаблицаЗначений"));
		ОписаниеТипаВыбора = Новый ОписаниеТипов(МассивТипаВыбора);
		
		ИмяРеквизитаТаблицыСтрокГруппы = "ТаблицаСтрокГруппы" + мТекущаяЗакладка + ИмяГруппы;
		// Создаем новые реквизиты формы в структуре формы
		Если НЕ ЕстьРеквизитФормы(ФормаПериода, ИмяРеквизитаТаблицыСтрокГруппы) Тогда
			МассивРеквизитов.Добавить(Новый РеквизитФормы(ИмяРеквизитаТаблицыСтрокГруппы, ОписаниеТипаВыбора, "", ИмяРеквизитаТаблицыСтрокГруппы));
			
			Для Каждого Колонка Из ТаблицаСтрокГруппы.Колонки Цикл			
				МассивРеквизитов.Добавить(Новый РеквизитФормы(Колонка.Имя, Колонка.ТипЗначения, ИмяРеквизитаТаблицыСтрокГруппы));
			КонецЦикла;
			
			ФормаПериода.ИзменитьРеквизиты(МассивРеквизитов);
		КонецЕсли;
		
		// заполняем именами областей подвала, шапки и итогов таблицу значений ОбщиеЭлементыГруппы
		ОбщиеЭлементыГруппы = Новый ТаблицаЗначений;
		ОбщиеЭлементыГруппы.Колонки.Добавить("ИмяОбласти");
		ОбщиеЭлементыГруппы.Колонки.Добавить("ИмяПараметра");
		ОбщиеЭлементыГруппы.Колонки.Добавить("Итог");
		ОбщиеЭлементыГруппы.Колонки.Добавить("Значение");
		ОбщиеЭлементыГруппы.Индексы.Добавить("ИмяОбласти");
		ОбщиеЭлементыГруппы.Индексы.Добавить("ИмяПараметра");
		Если ОбластьШапка <> Неопределено Тогда
			Для каждого Область Из ОбластьШапка.Области Цикл
				// Область может включать саму себ. исключаем ее из структуры
				Если Врег(Область.Имя) = Врег("Шапка" + мТекущаяЗакладка + ИмяГруппы) Тогда
					Продолжить;
				КонецЕсли;
				Если Врег(Область.Параметр) = Врег("Стр") Тогда
					Продолжить;
				КонецЕсли;
				ТекИмяОбласти       = Область.Имя;
				ТекИмяПараметра     = Область.Параметр;
				
				Строка = ОбщиеЭлементыГруппы.Добавить();
				Строка.ИмяОбласти   = ТекИмяОбласти;
				Строка.ИмяПараметра = ТекИмяПараметра;
				Строка.Итог = Ложь;
			КонецЦикла;
		КонецЕсли;
		
		Если ОбластьИтог <> Неопределено Тогда
			Для каждого Область Из ОбластьИтог.Области Цикл
				// Область может включать саму себ. исключаем ее из структуры
				Если Врег(Область.Имя) = Врег("Итог" + мТекущаяЗакладка + ИмяГруппы) Тогда
					Продолжить;
				КонецЕсли;
				ТекИмяОбласти       = Область.Имя;
				ТекИмяПараметра     = Область.Параметр;
				Строка = ОбщиеЭлементыГруппы.Добавить();
				Строка.ИмяОбласти   = ТекИмяОбласти;
				Строка.ИмяПараметра = ТекИмяПараметра;
				Если ТаблицаСтрокГруппы.Колонки.Найти(ТекИмяОбласти) <> Неопределено Тогда 
					Строка.Итог = Истина;
				Иначе
					Строка.Итог = Ложь;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		Если ОбластьПодвал <> Неопределено Тогда
			Для каждого Область Из ОбластьПодвал.Области Цикл
				// Область может включать саму себ. исключаем ее из структуры
				Если Врег(Область.Имя) = Врег("Подвал" + мТекущаяЗакладка + ИмяГруппы) Тогда
					Продолжить;
				КонецЕсли;
				ТекИмяОбласти       = Область.Имя;
				ТекИмяПараметра     = Область.Параметр;
				
				Строка = ОбщиеЭлементыГруппы.Добавить();
				Строка.ИмяОбласти   = ТекИмяОбласти;
				Строка.ИмяПараметра = ТекИмяПараметра;
				Строка.Итог = Ложь;
			КонецЦикла;
		КонецЕсли;	         		
		ОбщиеЭлементыГруппы.Индексы.Добавить("ИмяОбласти,ИмяПараметра,Итог");
			
		ДанныеСтраницы = СтрокаФормы.Строки.Добавить();
		
		ДанныеСтраницы.КодФормы = мТекущаяЗакладка;
		ДанныеСтраницы.ИмяГруппы = ИмяГруппы;
		
		ДанныеСтраницы.ОбщиеЭлементыГруппы 				= ОбщиеЭлементыГруппы;
		ДанныеСтраницы.ИмяРеквизитаТаблицыСтрокГруппы 	= ИмяРеквизитаТаблицыСтрокГруппы;
		ДанныеСтраницы.ТаблицаРасшифровки 				= ТаблицаРасшифровки;
		
		ФормаПериода.ЗначениеВРеквизитФормы(ТаблицаСтрокГруппы, ИмяРеквизитаТаблицыСтрокГруппы);	
		
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции// СформироватьСтруктуруМногострочнойФормы()

// Процедура производит очистку данных.
// Параметры:
//  ВидОчистки - строка, задающая способ очистки:
//               "ОчиститьФорму" - Очистить текущую форму
//				 "ОчиститьФормуИПриложения" - Очистить форму и приложения к ней
//
Процедура ОчиститьРеглОтчет(Форма, ВидОчистки) Экспорт	
		
	//ФормаЗаполнена = ФормаЗаполнена(Форма.ИмяФормы, Форма.мСписокФормБезИерархии);
	Вложенность = Ложь;
	//
	//Если ВидОчистки = "ОчиститьФорму" Тогда 
	//	
	//	Если ФормаЗаполнена Тогда
	//		Ответ = Вопрос("Очистить данные формы?", РежимДиалогаВопрос.ДаНет, ,КодВозвратаДиалога.Да,);
	//		Если Ответ = КодВозвратаДиалога.Нет Тогда
	//			Возврат;
	//		КонецЕсли;
	//	КонецЕсли;
	//	
	//	Вложенность = Ложь;   
	//				
	//ИначеЕсли ВидОчистки = "ОчиститьФормуИПриложения" Тогда
	//			
	//	Если ФормаЗаполнена Тогда      
	//		Текст = ?(Форма.ИмяФормы = Лев(Форма.мВыбраннаяФорма,СтрДлина(Форма.мВыбраннаяФорма)-7),"Полностью очистить декларацию?","Очистить форму и ее приложения?");
	//		Ответ = Вопрос(Текст, РежимДиалогаВопрос.ДаНет, ,КодВозвратаДиалога.Да,);
	//		Если Ответ = КодВозвратаДиалога.Нет Тогда
	//			Возврат;
	//		КонецЕсли;
	//	КонецЕсли;
	//	
	//	Вложенность = Истина;
	//						
	//КонецЕсли;
	
	ОчиститьДанныеРегОтчета(Форма, Форма.КодФормы, Форма.ПризнакМногострочности,Вложенность);
	
КонецПроцедуры // ОчиститьРеглОтчет()

// Очищает данные в структурах: мСписокСохранения, 
// мСписокВычисляемыхЯчеек, мСтруктураОтчета
// Параметры:
//     ИмяОчищаемойФормы - имя формы, подлежащей очистке
//     ТекПризнакМногострочности - признак многострочности формы
//     Вложенность - признак очистки доп.форм данной формы
//
Процедура ОчиститьДанныеРегОтчета(Форма, ИмяОчищаемойФормы, ТекПризнакМногострочности, Вложенность = Ложь) Экспорт
	 		
	Если ИмяОчищаемойФормы = Лев(Форма.мВыбраннаяФорма, СтрДлина(Форма.мВыбраннаяФорма)-7) Тогда 
		
		Если Вложенность Тогда 
			Форма.Очистить(ИмяОчищаемойФормы,Истина);
			
			НайденнаяСтрокаВДереве = Форма.РеквизитФормыВЗначение("СписокФормДерева").Строки.Найти(ИмяОчищаемойФормы,"КодФормы",Истина);
			Если НайденнаяСтрокаВДереве <> Неопределено И НайденнаяСтрокаВДереве.Строки.Количество() > 0 Тогда
				Для Каждого ПодчиненнаяСтрока Из НайденнаяСтрокаВДереве.Строки Цикл
					ОчиститьДанныеРегОтчета(Форма,ПодчиненнаяСтрока.КодФормы,ПодчиненнаяСтрока.Многострочность,Истина);
				КонецЦикла;
			КонецЕсли;
			
			ТекстСообщения = НСтр("ru='Данные в приложениях очищены'");
			ОбщегоНазначения.СообщитьПользователю(ТекстСообщения);
		
		Иначе
			Форма.Очистить(ИмяОчищаемойФормы);
		КонецЕсли;
		
	ИначеЕсли ТекПризнакМногострочности = Истина Тогда 
		
		Форма.Очистить(ИмяОчищаемойФормы, Вложенность);
		
		ФормаНС = Форма.РеквизитФормыВЗначение("мСписокФормБезИерархии");
		Строка = ФормаНС.Строки.Найти(ИмяОчищаемойФормы, "КодФормы");
		Если Строка <> Неопределено Тогда
			Строка.Выгружать = 0;  
		КонецЕсли;
		
		Форма.ЗначениеВРеквизитФормы(ФормаНС, "мСписокФормБезИерархии");
		
		Если Вложенность Тогда 
			
			НайденнаяМногСтрокаВДереве = Форма.РеквизитФормыВЗначение("СписокФормДерева").Строки.Найти(ИмяОчищаемойФормы,"КодФормы",Истина);
			Если НайденнаяМногСтрокаВДереве <> Неопределено И НайденнаяМногСтрокаВДереве.Строки.Количество() > 0 Тогда
				Для Каждого ПодчиненнаяСтрока2 Из НайденнаяМногСтрокаВДереве.Строки Цикл
					ОчиститьДанныеРегОтчета(Форма,ПодчиненнаяСтрока2.КодФормы,ПодчиненнаяСтрока2.Многострочность,Истина);
				КонецЦикла;
			КонецЕсли;
			
		КонецЕсли;
		
	Иначе //для обычных форм
		
		Форма.Очистить(ИмяОчищаемойФормы, Вложенность);
		
		ФормаНС = Форма.РеквизитФормыВЗначение("мСписокФормБезИерархии");
		Строка = ФормаНС.Строки.Найти(ИмяОчищаемойФормы, "КодФормы");
		Если Строка <> Неопределено Тогда
			Строка.Выгружать = 0;  
		КонецЕсли;
		Форма.ЗначениеВРеквизитФормы(ФормаНС, "мСписокФормБезИерархии");

		Если Вложенность Тогда 
			
			НайденнаяСтрокаВДереве = Форма.РеквизитФормыВЗначение("СписокФормДерева").Строки.Найти(ИмяОчищаемойФормы,"КодФормы",Истина);
			Если НайденнаяСтрокаВДереве <> Неопределено И НайденнаяСтрокаВДереве.Строки.Количество() > 0 Тогда
				Для Каждого ПодчиненнаяСтрока Из НайденнаяСтрокаВДереве.Строки Цикл
					ОчиститьДанныеРегОтчета(Форма,ПодчиненнаяСтрока.КодФормы,ПодчиненнаяСтрока.Многострочность,Истина);
				КонецЦикла;
			КонецЕсли;
			
		КонецЕсли;	
		
	КонецЕсли;	
	
КонецПроцедуры // ОчиститьДанныеРегОтчета()

// Процедура очищает данные поля табличного документа формы
// и данные формы в структуре хранения данных регламентированного отчета
// мСписокФормБезИерархии.
//
// Параметры:      Форма - текущая открытая форма отчета
//                 ТекИмяФормы - имя очищаемой формы регламентированного отчета
//                 ОчиститьВсе - признак вида очистки формы
//                               Значение равно "Истина" - очищаются все ячейки формы
//                               Значение равно "Ложь" - очищаются ячейки, не находящиеся в 
//                               списке значений СписокПоказателейНеПодлежащихОчистке.
//                 СписокПоказателейНеПодлежащихОчистке - (тип:СписокЗначений)
//								 список имен областей формы, не подлежащих очистке
//
Процедура ОчиститьСтруктуруДанныхИТабличноеПолеФормы(Форма, ТекИмяФормы, ОчиститьВсе,СписокПоказателейНеПодлежащихОчистке) Экспорт
	
	Перем СтруктураГруппы;
	
	мСписокФормБезИерархии = Форма.РеквизитФормыВЗначение("мСписокФормБезИерархии");
	СтрокаФормы = мСписокФормБезИерархии.Строки.Найти(ТекИмяФормы,"КодФормы");	
	ИмяПанелиФормы = "Панель" + ТекИмяФормы;
	ТекущаяПанель = Форма.Элементы[ИмяПанелиФормы];
	
	Если Не СтрокаФормы.Многострочность = 1 Тогда
		
		ТаблицаДанных = СтрокаФормы.Значение;                 		
		
		Для Каждого Страница Из ТекущаяПанель.ПодчиненныеЭлементы Цикл
			ИмяСтраницыБезПрефиксаПанели =  СтрЗаменить(Страница.Имя, ИмяПанелиФормы, ""); // ИмяСтраницыБезПерфиксаПанели
			мФормаОтчета = Форма[ТекИмяФормы+"ПолеТабличногоДокумента" + ИмяСтраницыБезПрефиксаПанели];
			Для Инд = 0 По мФормаОтчета.Области.Количество() - 1 Цикл
				ТекущаяОбласть = мФормаОтчета.Области[Инд];
				
				// Ячейки, не подлежащие очистке
				Если СписокПоказателейНеПодлежащихОчистке.НайтиПоЗначению(ТекущаяОбласть.Имя) <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				
				Если Не ВРЕГ(Лев(ТекущаяОбласть.Имя,2))= "S_" И НЕ ВРЕГ(Лев(ТекущаяОбласть.Имя,1))= "Б"  Тогда
					Если ОчиститьВсе Тогда
						Если Лев(ТекущаяОбласть.Имя,8)= "Страница" Тогда
							Продолжить;
						КонецЕсли;
						
						Если Найти(ТекущаяОбласть.Имя,"ОбластьФорматирования")<> 0 Тогда
							Продолжить;
						КонецЕсли;

					Иначе
						Если Лев(ТекущаяОбласть.Имя,8)= "Страница" Тогда
							Продолжить;
						КонецЕсли;
						
						Если Найти(ТекущаяОбласть.Имя,"ОбластьФорматирования")<> 0 Тогда
							Продолжить;
						КонецЕсли;
						
						Если ТекущаяОбласть.Защита = Истина  Тогда
							Продолжить;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
				
				Строка = ТаблицаДанных.Найти(ТекущаяОбласть.Имя,"ИмяОбласти");
				Если ТипЗнч(ТекущаяОбласть) = Тип("РисунокТабличногоДокумента") Тогда
					Если Строка <> Неопределено Тогда
						Строка.Значение = "";
					КонецЕсли;
					
					ТекущаяОбласть.Значение = "";
				Иначе
					ТекущаяОбласть.Очистить();
					
					Если Строка <> Неопределено Тогда
						Строка.Значение = "";
					КонецЕсли;

					Если ТекущаяОбласть.СодержитЗначение Тогда
						Если Строка <> Неопределено Тогда
							Строка.Значение = ТекущаяОбласть.Значение;
						КонецЕсли;
					Иначе
						Если Строка <> Неопределено Тогда
							Строка.Значение = ТекущаяОбласть.Текст;
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			КонецЦикла;
		КонецЦикла;						
		
	Иначе
		//Если форма многострочная, очищаем структуру из которой берутся данные 	
		ИмяПанелиФормы = "Панель" + ТекИмяФормы;
		Для Каждого Страница Из ТекущаяПанель.ПодчиненныеЭлементы Цикл
			ИмяСтраницыБезПрефиксаПанели =  СтрЗаменить(Страница.Имя, ИмяПанелиФормы, ""); // ИмяСтраницыБезПерфиксаПанели
			ИмяГруппы = ИмяСтраницыБезПрефиксаПанели;
			Имя = ТекИмяФормы + "ПолеТабличногоДокумента" + ИмяГруппы;
			Форма[Имя].Очистить();
			
			мМногострочнаяСтруктура = ПолучитьМногострочнуюСтруктуру(Форма, ТекИмяФормы);
			Если мМногострочнаяСтруктура.Свойство(ИмяГруппы, СтруктураГруппы) Тогда
				ОбщиеЭлементыГруппы = СтруктураГруппы.ШапкаИПодвал;
				ТаблицаСтрокГруппы  = СтруктураГруппы.Строки;
				ТаблицаСтрокГруппы.Очистить();			 
				Для Каждого ОбщийЭлемент Из ОбщиеЭлементыГруппы Цикл
					ОбщийЭлемент.Значение = Неопределено;
				КонецЦикла;
				ОбновитьМногострочнуюСтруктуру(Форма, ТекИмяФормы, мМногострочнаяСтруктура);
			КонецЕсли;		 	 
		КонецЦикла;
		
		СтрокаФормы.ВсегоСтраниц = 1;
		
		Если Форма.КодФормы = ТекИмяФормы Тогда
			Форма.ТекущаяСтраница = 0;			
			ПоказатьСтраницыМногострочнойФормы(Форма);
		КонецЕсли;
		
	КонецЕсли;
	
	// если форма не главная, то ставим признак Выгружать = 0;
	ВыбраннаяФорма = Форма.мВыбраннаяФорма;
	Если СтрокаФормы.КодФормы <> Лев(ВыбраннаяФорма,СтрДлина(ВыбраннаяФорма)-7) Тогда
		СтрокаФормы.Выгружать = 0;  
	КонецЕсли;
	
	Форма.ЗначениеВРеквизитФормы(мСписокФормБезИерархии, "мСписокФормБезИерархии");
	
	Форма.ЗаполнитьПараметры(ТекИмяФормы);
	
КонецПроцедуры

//Управляет видимостью страниц основной панели формы.
// Применяется только для многострочных форм
//Параметры:
//          ТекущаяСтраница - номер страницы
//          ВсегоСтраниц - общее количество страниц формы
//
Процедура ПоказатьСтраницыМногострочнойФормы(Форма) Экспорт   
	
	мСписокФормБезИерархии = Форма.РеквизитФормыВЗначение("мСписокФормБезИерархии");
	СтрокаФормы = мСписокФормБезИерархии.Строки.Найти(Форма.КодФормы,"КодФормы");	
	
	ТекущаяСтраница = Форма.ТекущаяСтраница;
	Если СтрокаФормы = Неопределено Тогда
		ВсегоСтраниц = 1;
		ТекущаяСтраница = 1;
	Иначе
		ВсегоСтраниц = СтрокаФормы.ВсегоСтраниц;
		ТекущаяСтраница = Форма.ТекущаяСтраница;
		Если ТекущаяСтраница > ВсегоСтраниц Тогда
			ТекущаяСтраница = ВсегоСтраниц;
		ИначеЕсли ТекущаяСтраница <=0 Тогда
			ТекущаяСтраница = 1;
		КонецЕсли;     	
	КонецЕсли;
	           	
	//добавлена "мФорма." для вызова из основной формы
	Если Форма.Элементы.Найти("ФормаПредыдущаяСтр") <> Неопределено
		И Форма.Элементы.Найти("ФормаСледующаяСтр") <> Неопределено Тогда
		
		Если ТекущаяСтраница > 1 И ТекущаяСтраница < ВсегоСтраниц Тогда
			
			Форма.Элементы.ФормаПредыдущаяСтр.Доступность = Истина;
			Форма.Элементы.ФормаСледующаяСтр.Доступность  = Истина;
			
		ИначеЕсли ТекущаяСтраница = 1 И ТекущаяСтраница < ВсегоСтраниц Тогда		
			
			Форма.Элементы.ФормаПредыдущаяСтр.Доступность = Ложь;
			Форма.Элементы.ФормаСледующаяСтр.Доступность  = Истина;
			
		ИначеЕсли ТекущаяСтраница = ВсегоСтраниц И ТекущаяСтраница = 1 Тогда		
			
			Форма.Элементы.ФормаПредыдущаяСтр.Доступность = Ложь;
			Форма.Элементы.ФормаСледующаяСтр.Доступность  = Ложь;		
			
		ИначеЕсли ТекущаяСтраница = ВсегоСтраниц Тогда		
			
			Форма.Элементы.ФормаПредыдущаяСтр.Доступность = Истина;
			Форма.Элементы.ФормаСледующаяСтр.Доступность  = Ложь;
			
		КонецЕсли;
		
		Если ТекущаяСтраница <> 0 Тогда	
			ПредставлениеНадписи = Строка(ТекущаяСтраница) + " из " + Строка(ВсегоСтраниц);
			Если Форма.Элементы.Найти("ФормаКоличествоСтраниц") <> Неопределено Тогда
				Форма.Элементы.ФормаКоличествоСтраниц.Заголовок = ПредставлениеНадписи;
			КонецЕсли;	
		Иначе
			Если Форма.Элементы.Найти("ФормаКоличествоСтраниц") <> Неопределено Тогда
				Форма.Элементы.ФормаКоличествоСтраниц.Заголовок   = "1 из 1";
			КонецЕсли;	
			Форма.Элементы.ФормаПредыдущаяСтр.Доступность = Ложь;
			Форма.Элементы.ФормаСледующаяСтр.Доступность  = Ложь;
			
			Если Форма.Элементы.Найти("ФормаПерейти") <> Неопределено Тогда
				Форма.Элементы.ФормаПерейти.Доступность       = Ложь;
			КонецЕсли;	
		КонецЕсли; 
		
	КонецЕсли;
	
	Если Форма.Элементы.Найти("ФормаПерейти") <> Неопределено Тогда
		Если ВсегоСтраниц <> Неопределено И ВсегоСтраниц > 1 Тогда
			Форма.Элементы.ФормаПерейти.Доступность       = Истина;
		Иначе
			Форма.Элементы.ФормаПерейти.Доступность       = Ложь;
		КонецЕсли;
	КонецЕсли;	
	
КонецПроцедуры // ПоказатьСтраницыМногострочнойФормы()

// Процедура выполняет основные действия по заполнению формы
// или приложения регламентированного отчета
//
// Параметры: Объект - передаваемая форма
Процедура ЗаполнитьФорму(Форма, ТекущееИмяФормы, ПризнакПерезаполнения) Экспорт
	
	Перем СтруктураГруппы;
	
	мСписокФормБезИерархии = Форма.РеквизитФормыВЗначение("мСписокФормБезИерархии"); 
	
	ТекФорма = мСписокФормБезИерархии.Строки.Найти(ТекущееИмяФормы, "КодФормы");
	
	Если ТекФорма.Многострочность = 1 Тогда
	
		мМногострочнаяСтруктура = ПолучитьМногострочнуюСтруктуру(Форма, ТекущееИмяФормы);
		
		Для Каждого Страница Из мМногострочнаяСтруктура Цикл  	
			     
			ИмяГруппы = Страница.Ключ;
			 						
			мМногострочнаяСтруктура.Свойство(ИмяГруппы, СтруктураГруппы);
			ОбщиеЭлементыГруппы = СтруктураГруппы.ШапкаИПодвал;           
			ТаблицаСтрокГруппы  = СтруктураГруппы.Строки;        	 	
				
			// Очищаем таблицу значений, для записи значений шапки(подвала)
			Для Каждого ЭлГруппы Из ОбщиеЭлементыГруппы Цикл
				ЭлГруппы.Значение = Неопределено;			 
			КонецЦикла;
							            		 	 
			//заполняем данные итогов		 
			ЗаполнитьДанныеИтоговВСтруктуре(Форма, ТаблицаСтрокГруппы, ОбщиеЭлементыГруппы); 
		КонецЦикла;                                               	
		
		ОбновитьМногострочнуюСтруктуру(Форма, ТекущееИмяФормы, мМногострочнаяСтруктура);
		
		Форма.ЗаполнитьПараметры(ТекущееИмяФормы);		

	Иначе
		
		//рассчитаем из приложений данные	 
		Форма.ВыборРасчета(ТекущееИмяФормы); 
			
	КонецЕсли;
			
	Если Не ПризнакПерезаполнения Тогда
		//здесь нужно передать объект отчета мФормы
		 СформироватьПризнакиФормыИПередатьИтоги(Форма, ТекущееИмяФормы, Ложь);
	КонецЕсли;
	
		
	Форма.Модифицированность = Истина;
	
КонецПроцедуры

// Процедура вызывается при закрытии формы 				
// или при заполнении текущей формы из родительской формы. 
//
// Параметры:
//           Объект - передаваемая форма рег.отчета
//           ТекИмяФормы - представляет имя текущей формы (мФорма.ИмяФормы)
//           ПризнакПередачиИтогов - определяет режим вызова данной процедуры
//                равен Истина, если процедура вызвана при закрытии формы
//              и равен ложь, если процедура вызвана при заполнении приложения из родительской формы.
//
Процедура СформироватьПризнакиФормыИПередатьИтоги(Форма, ТекИмяФормы, ПризнакПередачиИтогов = Истина) Экспорт
	мСписокФормБезИерархии = Форма.РеквизитФормыВЗначение("мСписокФормБезИерархии");	
	
	Строка  = мСписокФормБезИерархии.Строки.Найти(ТекИмяФормы, "КодФормы");

	Если ФормаЗаполнена(ТекИмяФормы, мСписокФормБезИерархии, Форма) Тогда 
			
		//устанавливаем признак выгружать в форме настройки страниц		
		Если Строка <> Неопределено Тогда
        	Строка.Выгружать = 1;
		КонецЕсли;
		Строка  = мСписокФормБезИерархии.Строки.Найти(ТекИмяФормы, "КодФормы");		
				
	Иначе // форма не заполнена
		
		Если ПризнакПередачиИтогов Тогда
			ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Форма ""%1"" не заполнена. Данные не переданы.'"), Строка.ЗаголовокФормы);
			ОбщегоНазначения.СообщитьПользователю(ТекстСообщения);
		КонецЕсли;
		
		Строка = мСписокФормБезИерархии.Строки.Найти(ТекИмяФормы, "КодФормы");
		Если Строка <> Неопределено Тогда
			Строка.Выгружать = 0;  
		КонецЕсли;   				
	КонецЕсли;
	
	Форма.ЗначениеВРеквизитФормы(мСписокФормБезИерархии, "мСписокФормБезИерархии");
	
	// Синхронизируем признак выгрузки в Списке форм дерева
	ЭлементыСпискаДерева = Форма.СписокФормДерева.ПолучитьЭлементы();
	ФормаСпискаДерева = РегламентированнаяОтчетностьКлиентСервер.НайтиСтрокуДерева(Форма.СписокФормДерева, Новый Структура("КодФормы", ТекИмяФормы));
	ФормаСпискаДерева.Выгружать = ?(Строка.Выгружать = 1, Истина, Ложь);
	
	// Обновим признак представления приложения в основной форме	
	Если Строка.ПризнакОсновной = 0 Тогда
		СтрокаОсновнойФормы = Форма.СписокФормДерева.ПолучитьЭлементы()[0];	
		
		Если СтрНайти(ТекИмяФормы, "700_01_") <> 0 Тогда
			КодФормыПриложения = "Форма700_01";
		ИначеЕсли СтрНайти(ТекИмяФормы, "700_02_") <> 0 Тогда
			КодФормыПриложения = "Форма700_02";  
		ИначеЕсли СтрНайти(ТекИмяФормы, "200_06_") <> 0 Тогда
			КодФормыПриложения = "Форма200_06";	
		Иначе
			КодФормыПриложения = ТекИмяФормы;
		КонецЕсли;
		
		ИмяОбласти = "Приложение" + Прав(КодФормыПриложения, 2);
		
		Если ФормаСпискаДерева.Выгружать Тогда
			РегламентированнаяОтчетность.ПередатьЗначениеВСтруктуру(Форма, СтрокаОсновнойФормы.КодФормы, ИмяОбласти, "Х", Истина);				
		Иначе
			РегламентированнаяОтчетность.ПередатьЗначениеВСтруктуру(Форма, СтрокаОсновнойФормы.КодФормы, ИмяОбласти, "", Истина);				
		КонецЕсли;
	КонецЕсли;
	
	// Передадим итоги
	ПереданыИтоги = ПередатьИтоги(Форма,ТекИмяФормы);
	Если Не ПереданыИтоги Тогда		
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Данные из формы %1 не переданы.'"), Форма.Заголовок);			
		ОбщегоНазначения.СообщитьПользователю(ТекстСообщения);	
	КонецЕсли;
		
КонецПроцедуры // СформироватьПризнакиФормыИПередатьИтоги()

// Функция определяет была ли заполнена форма.
// Параметры:
//           ТекИмяФормы - представляет имя текущей формы (ИмяФормы)
//
Функция ФормаЗаполнена(ТекущееИмяФормы, мСписокФормБезИерархии, Форма) Экспорт
	
	Строка = мСписокФормБезИерархии.Строки.Найти(ТекущееИмяФормы,"КодФормы");
		
	Если Строка.Многострочность = 1 Тогда
		
		мМногострочнаяСтруктура = ПолучитьМногострочнуюСтруктуру(Форма, ТекущееИмяФормы);
		
		// проверим заполненность по первой встретивщейся странице?
		// она может иметь разное имя - ЛистA, Страница1 и т.д.		
		Для Каждого КлючИЗначение Из мМногострочнаяСтруктура Цикл
		
			ТаблицаСтрокГруппы = КлючИЗначение.Значение.Строки;
			Если ТаблицаСтрокГруппы.Количество()>0 Тогда
				Возврат Истина;
			Иначе
				Возврат Ложь;
			КонецЕсли;
		
		КонецЦикла;
		
	Иначе
		
		ТаблицаДанных = Строка.Значение;
		Для Каждого СтрокаТаблицы Из ТаблицаДанных Цикл
			Если ВРЕГ(Лев(СтрокаТаблицы.ИмяОбласти,2)) = "S_" И ТипЗнч(СтрокаТаблицы.Значение) = Тип("Число") Тогда
				Если СтрокаТаблицы.Значение <> 0 Тогда 
					Возврат Истина;
				КонецЕсли;
			КонецЕсли;			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Ложь;
	
КонецФункции

// Подсчитывает итоги и передает из в структуру
//  
// Параметры: Объект - передаваемая форма
//
Функция  ПередатьИтоги(Форма, ТекИмяФормы) Экспорт
	Объект = Форма.ОтчетОбъект;	
	ТаблицаПД = Форма.РеквизитФормыВЗначение("мТаблицаПоказателейДляПередачиДанных");
	мСписокФормБезИерархии = Форма.РеквизитФормыВЗначение("мСписокФормБезИерархии");
	
	Отбор = Новый Структура();
	Отбор.Вставить("КодФормыИсточник",ТекИмяФормы);
	СтрокиПередачи = ТаблицаПД.НайтиСтроки(Отбор);
	
	// проверим существует ли данная область
	Если СтрокиПередачи <> Неопределено Тогда
		// производим передачу итогов
		Пока СтрокиПередачи <> Неопределено Цикл
			
			СписокФормПриемников = Новый СписокЗначений;
			Для Каждого Строка Из СтрокиПередачи Цикл
				// перебираем строки области
				КодФормыИсточник    = Строка.КодФормыИсточник;
				ИмяОбластиИсточник  = Строка.ИмяОбластиИсточник;
				КодФормыПриемник    = Строка.КодФормыПриемник;
				ИмяОбластиПриемник  = Строка.ИмяОбластиПриемник;
				
				ФормаПриемник = мСписокФормБезИерархии.Строки.Найти(КодФормыПриемник,"КодФормы");
				Если ФормаПриемник <> Неопределено Тогда
					
					//проверим признак автополучения итогов для формы приемника
					Если ФормаПриемник.АвтополучениеИтогов = 1 Тогда
						ПолучатьИтоги = Истина;
					Иначе
						ПолучатьИтоги = Ложь;
					КонецЕсли;
					
					Если ПолучатьИтоги Тогда
						
						//-------расчет данных---------
						// найдем формы из которых также передается значение				
						ОтборПоПриемнику = Новый Структура();
						ОтборПоПриемнику.Вставить("КодФормыПриемник",КодФормыПриемник);
						ОтборПоПриемнику.Вставить("ИмяОбластиПриемник",ИмяОбластиПриемник);
						СтрокиПриемника = ТаблицаПД.НайтиСтроки(ОтборПоПриемнику);
					
						ПередаваемоеЗначение = 0;
						Для Каждого СтрокаПоПриемнику Из СтрокиПриемника Цикл
							ЗначениеДляПередачи = ПолучитьЗначениеИзСтруктурыДляПередачиИтогов(Форма,
						    	          СтрокаПоПриемнику.КодФормыИсточник,СтрокаПоПриемнику.ИмяОбластиИсточник);
							Если ЗначениеДляПередачи = Неопределено Тогда
								Возврат Ложь;
							КонецЕсли;
							ПередаваемоеЗначение = ПередаваемоеЗначение + ЗначениеДляПередачи;
						КонецЦикла;
				  				
						//-------прием данных---------
						Если ФормаПриемник.Многострочность = 1 Тогда
							
							ТаблицаДанных = Форма.Значение;
							мМногострочнаяСтруктура = ТаблицаДанных[0].Данные;
							ОбластьНайдена = Ложь;
							Для Каждого Страница Из мМногострочнаяСтруктура Цикл  	
			     
								ИмяГруппы = Страница.Ключ;
								СтруктураГруппы = Неопределено; 						
								мМногострочнаяСтруктура.Свойство(ИмяГруппы, СтруктураГруппы);
								ОбщиеЭлементыГруппы = СтруктураГруппы.ШапкаИПодвал;           
								ТаблицаСтрокГруппы  = СтруктураГруппы.Строки;        	 	
							 	
								// Ищем область приемника в общих элементах группы (областях шапки и подвала мног.формы)
								СтрокаОбластиПриемника = ОбщиеЭлементыГруппы.Найти(ИмяОбластиПриемник,"ИмяОбласти");
								Если СтрокаОбластиПриемника <> Неопределено Тогда
									Если НЕ СтрокаОбластиПриемника.Итог = Истина Тогда
										СтрокаОбластиПриемника.Значение = ПередаваемоеЗначение; 
										ОбластьНайдена = Истина;						
									КонецЕсли;
								КонецЕсли;
								
								// Ищем область приемника в таблице строк группы (в колонках)
								// если находим, то добавляем в первую строку передаваемое значение
								// Если в таблице строк нет ни одной строки, то добавляем 1 строку
								// и в колонку с именем "ИмяОбластиПриемник" записываем передаваемое значение
								КолонкаОбластиПриемника = ТаблицаСтрокГруппы.Колонки.Найти(ИмяОбластиПриемник);
								Если КолонкаОбластиПриемника <> Неопределено Тогда
									// проверяем наличие строк
									Если ТаблицаСтрокГруппы.Количество() = 0 Тогда
										// добавляем строку
										Для Каждого Стр Из мМногострочнаяСтруктура Цикл
											ИмяГр = Стр.Ключ;
											СтрГр = Неопределено;
											мМногострочнаяСтруктура.Свойство(ИмяГр, СтрГр);
											ТаблицаСтрок = СтрГр.Строки;
											Строка = ТаблицаСтрок.Добавить();
										КонецЦикла;
										Объект.ЗаполнитьПараметры(КодФормыПриемник);
									КонецЕсли;
									ПерваяСтрока = ТаблицаСтрокГруппы[0];
									ПерваяСтрока[ИмяОбластиПриемник] = ПередаваемоеЗначение;
									ОбластьНайдена = Истина;
								КонецЕсли;
								
								//заполняем данные итогов
								ЗаполнитьДанныеИтоговВСтруктуре(Форма, ТаблицаСтрокГруппы, ОбщиеЭлементыГруппы); 
							КонецЦикла;
							
							// если область приемника нигде в структуре многострочной формы не была найдена
							// выводим соответствующее сообщение о неккоректном имени области приемника в 
							// макете "ПередачаДанных".
							Если НЕ ОбластьНайдена Тогда
								ОбщегоНазначения.СообщитьПользователю(СтрШаблон(НСтр("ru = 'Неверное имя области приемника ""%1"" для кода формы приемника ""%2"".'"), ИмяОбластиПриемник, КодФормыПриемник));
								Возврат Ложь;
							КонецЕсли;
							
						Иначе // если обычная
							ТаблицаДанных = ФормаПриемник.Значение;
							СтрокаОбластиПриемника = ТаблицаДанных.Найти(ИмяОбластиПриемник,"ИмяОбласти");
							Если СтрокаОбластиПриемника <> Неопределено Тогда
								СтрокаОбластиПриемника.Значение = ПередаваемоеЗначение; 
							Иначе
								ОбщегоНазначения.СообщитьПользователю(СтрШаблон(НСтр("ru = 'Неверное имя области приемника ""%1"" для кода формы приемника ""%2"".'"), ИмяОбластиПриемник, КодФормыПриемник));
								Возврат Ложь;
							КонецЕсли;
								
						КонецЕсли;
							
						// смотрим есть ли уже такая форма приемник в списке форм приемников
						// и если нет, то добавляем в список
						НайденныйЭлемент = СписокФормПриемников.НайтиПоЗначению(КодФормыПриемник);
						Если НайденныйЭлемент = Неопределено Тогда
							СписокФормПриемников.Добавить(КодФормыПриемник);
							Если КодФормыПриемник = ТекИмяФормы Тогда
								ОбщегоНазначения.СообщитьПользователю(НСтр("ru = 'Цикличная передача итогов'"));
								Возврат Ложь;
							КонецЕсли;
						КонецЕсли;
					КонецЕсли;
				Иначе
					ОбщегоНазначения.СообщитьПользователю(СтрШаблон(НСтр("ru = 'Неверный код формы приемника ""%1"" для передачи данных'"), КодФормыПриемник));
					Возврат Ложь;
				КонецЕсли;
				
			КонецЦикла;
			
			Форма.ЗначениеВРеквизитФормы(мСписокФормБезИерархии, "мСписокФормБезИерархии");
			
			//для каждой формы приемника производим процедуру расчета
			Для Каждого Элемент из СписокФормПриемников Цикл
				ФормаПриемник = Элемент.Значение;
				Форма.ВыборРасчета(ФормаПриемник);	
				мСписокФормБезИерархии = Форма.РеквизитФормыВЗначение("мСписокФормБезИерархии"); 
				ПередатьДанныеИзСтруктурыВТабличноеПоле(Форма, ФормаПриемник);
			КонецЦикла;
			
			Если СписокФормПриемников.Количество() = 0 Тогда
				СтрокиПередачи = Неопределено;
			КонецЕсли;
			
			Пока СписокФормПриемников.Количество() <> 0 Цикл 
				ФормаПриемник = СписокФормПриемников[0].Значение;
				Отбор = Новый Структура();
				Отбор.Вставить("КодФормыИсточник",ФормаПриемник);
				СтрокиПередачи = ТаблицаПД.НайтиСтроки(Отбор);
				СписокФормПриемников.Удалить(0);
				Если СтрокиПередачи <> Неопределено Тогда
					Прервать;
				КонецЕсли;			
			КонецЦикла;
				
		КонецЦикла;
		
	КонецЕсли;
	
	Форма.ЗначениеВРеквизитФормы(мСписокФормБезИерархии, "мСписокФормБезИерархии");
	
	
	Возврат Истина;
	
КонецФункции // ПередатьИтоги()

// Функция получает из общей структуры хранения данных
// значение для передачи итогов.
//
Функция ПолучитьЗначениеИзСтруктурыДляПередачиИтогов(Объект, КодФормыИсточник, ТекПоказательПередачи)
	
	ПередаваемоеЗначение = Неопределено;
	
	ФормаИсточник = Объект.РеквизитФормыВЗначение("мСписокФормБезИерархии").Строки.Найти(КодФормыИсточник,"КодФормы");
	Если ФормаИсточник <> Неопределено Тогда
		// если форма источник многострочная
		Если ФормаИсточник.Многострочность = 1 Тогда
			ТаблицаДанных = ФормаИсточник.Значение;
			МногСтруктура = ПолучитьМногострочнуюСтруктуру(Объект, КодФормыИсточник);
			Найдено = Ложь;
			Для Каждого Строка Из МногСтруктура Цикл
				СтруктураГруппы = Строка.Значение;
				ОбщиеЭлементыГруппы = СтруктураГруппы.ШапкаИПодвал;
				Если ОбщиеЭлементыГруппы.Найти(ТекПоказательПередачи,"ИмяОбласти") <> Неопределено Тогда
					ПередаваемоеЗначение = ОбщиеЭлементыГруппы.Найти(ТекПоказательПередачи,"ИмяОбласти").Значение;
					Найдено = Истина;
				КонецЕсли;
			КонецЦикла;
			// Преверяем, если вообще ни на одном листе не нашли данное имя области,
			// то сообщаем пол-лю и возвращаем Неопределено.
			Если Не Найдено Тогда
				ОбщегоНазначения.СообщитьПользователю(СтрШаблон(НСтр("ru = 'Неверное имя области ""%1"" формы источника ""%2"" для передачи данных'"), ТекПоказательПередачи, КодФормыИсточник));
				Возврат Неопределено;
			КонецЕсли;
		Иначе // если форма источник обычная
			ТаблицаДанных = ФормаИсточник.Значение;
			СтрокаОбластиИсточника = ТаблицаДанных.Найти(ТекПоказательПередачи,"ИмяОбласти");
			Если СтрокаОбластиИсточника <> Неопределено Тогда
				 ПередаваемоеЗначение = СтрокаОбластиИсточника.Значение;
			Иначе
				ОбщегоНазначения.СообщитьПользователю(СтрШаблон(НСтр("ru = 'Неверное имя области ""%1"" формы источника ""%2"" для передачи данных'"), ТекПоказательПередачи, КодФормыИсточник));
				Возврат Неопределено;
			КонецЕсли;
		КонецЕсли;
		Если ПередаваемоеЗначение = Неопределено Тогда
			ПередаваемоеЗначение = 0;
		КонецЕсли;
	Иначе
		Сообщить("");
		ОбщегоНазначения.СообщитьПользователю(СтрШаблон(НСтр("ru = 'Неверный код формы источника ""%1"" для передачи данных'"), КодФормыИсточник));
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат ПередаваемоеЗначение;
	
КонецФункции

// Функция опеределяет признак автозаполнения для форм,
// который устанавливается в форме настройки страниц
//
Функция ОпределитьПризнакАвтоЗаполненияФормы(Форма, ТекущееИмяФормы) 
	мСписокФормБезИерархии = Форма.РеквизитФормыВЗначение("мСписокФормБезИерархии");
	Форма = мСписокФормБезИерархии.Строки.Найти(ТекущееИмяФормы, "КодФормы");
	Если Форма <> Неопределено Тогда
		Если Форма.Автозаполнение = 1 Тогда
			ПризнакАвтоЗаполнения = Истина;
		Иначе
			ПризнакАвтоЗаполнения = Ложь;
		КонецЕсли;
	Иначе
		ПризнакАвтоЗаполнения = Ложь;
	КонецЕсли;
	
	Возврат ПризнакАвтоЗаполнения;
	
КонецФункции // ОпределитьПризнакАвтоЗаполненияФормы()

// Создает и возвращает ссылку на форму регламентированного отчета, соответствующего переданному 
// в качестве параметра наименованию. При получении формы учитывается информация в кэше.
// Параметры:
//		НаименованиеОтчета - строка-идентификатор регламентированного отчета.
//		НаименованиеМакета - строка - имя макета.
// Возвращаемое значение:
//		Форма - созданный объект. В случае неудачи возвращается Неопределено.
Функция ПолучитьМакетРеглОтчета(НаименованиеОтчета, НаименованиеМакета, ВнешнийОтчет = Ложь) Экспорт
	
	Перем ВременныйФайл;
	
	НайденныйЭлемент = Справочники.РегламентированныеОтчеты.НайтиПоРеквизиту("ИсточникОтчета", НаименованиеОтчета);
	
	Если НайденныйЭлемент = Справочники.РегламентированныеОтчеты.ПустаяСсылка() Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если РегламентированнаяОтчетность.ЭтоВнешнийОтчет(НаименованиеОтчета) ИЛИ ВнешнийОтчет Тогда // это внешний отчет
		Попытка
			Возврат ВнешниеОтчеты.Создать(НаименованиеОтчета).ПолучитьМакет(НаименованиеМакета);
		Исключение
			Возврат Неопределено;
		КонецПопытки;
	Иначе // это внутренний отчет
		Если Метаданные.Отчеты.Найти(НаименованиеОтчета) <> Неопределено Тогда
			Попытка
				Возврат Отчеты[НаименованиеОтчета].ПолучитьМакет(НаименованиеМакета);
			Исключение
				Возврат Неопределено;
			КонецПопытки;
		Иначе
			// отчет с таким именем не найден		
			Возврат Неопределено;
		КонецЕсли; 
	КонецЕсли;
	
КонецФункции // ПолучитьМакетРеглОтчета()

//Создает таблицу для отражения в учете из многострочной формы
//
Процедура ПодготовитьТаблицуДляОтражениеВУчете(Форма, ВнешнийОтчет = Ложь) Экспорт
	
	Перем СтруктураГруппы;
	
	мВыбраннаяФорма = Форма.мВыбраннаяФорма;
	МакетОтражениевУчете = ПолучитьМакетРеглОтчета(БухгалтерскиеОтчетыКлиентСервер.ПолучитьИдентификаторОбъекта(Форма), "ОтражениевУчете", ВнешнийОтчет);
	
	ОбластьМакета = МакетОтражениевУчете.Область(мВыбраннаяФорма);
	мСписокФормБезИерархии = Форма.РеквизитФормыВЗначение("мСписокФормБезИерархии");
	ТаблицаДляОтражениеВУчете = Форма.РеквизитФормыВЗначение("ТаблицаДляОтражениеВУчете", Тип("ТаблицаЗначений"));
	
	ТаблицаДляОтражениеВУчете.Очистить();
	
	Для Ном = ОбластьМакета.Верх По ОбластьМакета.Низ Цикл
		ВидНалога 				 = СокрП(МакетОтражениевУчете.Область(Ном, 1).Текст);
		Если ПустаяСтрока(ВидНалога) Тогда
			// Не считываем пустую строку в области, если она есть по первой колонке.			
			Прервать;
		КонецЕсли;
		ДатаУплаты      	   	 = СокрП(МакетОтражениевУчете.Область(Ном, 2).Текст);
		КБК                    	 = СокрП(МакетОтражениевУчете.Область(Ном, 3).Текст);
		ДатаОтражения          	 = СокрП(МакетОтражениевУчете.Область(Ном, 4).Текст);
		ДатаНачалаОтчета       	 = СокрП(МакетОтражениевУчете.Область(Ном, 5).Текст);
		ДатаОкончанияОтчета    	 = СокрП(МакетОтражениевУчете.Область(Ном, 6).Текст);  
		ТекИмяФормы    		   	 = СокрП(МакетОтражениевУчете.Область(Ном, 7).Текст);  
		ИсточникЗначения	   	 = СокрП(МакетОтражениевУчете.Область(Ном, 8).Текст);  		
		ИсточникДляОрганизации 	 = СокрП(МакетОтражениевУчете.Область(Ном, 9).Текст);  
		РННПлательщика		   	 = СокрП(МакетОтражениевУчете.Область(Ном, 10).Текст);  
		КомментарийФормы       	 = СокрП(МакетОтражениевУчете.Область(Ном, 11).Текст);
		ИсточникНалоговыйКомитет = СокрП(МакетОтражениевУчете.Область(Ном, 12).Текст);  		
		ИсточникДанных 			 = СокрП(МакетОтражениевУчете.Область(Ном, 13).Текст); 
		ИмяЛИста 			 	 = СокрП(МакетОтражениевУчете.Область(Ном, 14).Текст);
		
		НайденнаяСтрока = мСписокФормБезИерархии.Строки.Найти(ТекИмяФормы,"КодФормы");
		ТаблицаДанных = НайденнаяСтрока.Значение;
		ФормаМногострочная = НайденнаяСтрока.Многострочность = 1;
		
		Если Не ФормаМногострочная Тогда
			Продолжить;
		КонецЕсли;	
		МногострочнаяСтруктура 	= ПолучитьМногострочнуюСтруктуру(Форма, ТекИмяФормы);					
		МногострочнаяСтруктура.Свойство(ИмяЛИста, СтруктураГруппы);
		ТаблицаШапкаИПодвал 	= СтруктураГруппы.ШапкаИПодвал;
		ТаблицаСтрок 			= СтруктураГруппы.Строки;
		
		Если ИсточникДанных = "ШапкаИПодвал" Тогда
			МассивСтрок = ТаблицаШапкаИПодвал.НайтиСтроки(Новый Структура("ИмяОбласти", ИсточникЗначения));
			Если МассивСтрок.Количество() = 0 Тогда
				Значение = 0;
			Иначе
				Значение = ?(ЗначениеЗаполнено(МассивСтрок[0].Значение), МассивСтрок[0].Значение, 0);	
			КонецЕсли;
				
			Если Значение <> 0 Тогда
				СтрокаОтражения 					= ТаблицаДляОтражениеВУчете.Добавить();
				СтрокаОтражения.ВидНалога 			= ВидНалога;                     
				СтрокаОтражения.ДатаУплаты 			= ПолучитьДатуИзСтроки(ДатаУплаты);
				СтрокаОтражения.КБК 				= КБК;
				СтрокаОтражения.ДатаОтражения 		= ПолучитьДатуИзСтроки(ДатаОтражения);
				СтрокаОтражения.ДатаНачалаОтчета 	= ПолучитьДатуИзСтроки(ДатаНачалаОтчета);
				СтрокаОтражения.ДатаОкончанияОтчета = ПолучитьДатуИзСтроки(ДатаОкончанияОтчета);
				СтрокаОтражения.Организация 		= Форма.Налогоплательщик;
				СтрокаОтражения.СтруктурнаяЕдиница 	= Форма.Налогоплательщик;
				СтрокаОтражения.НалоговыйКомитет 	= Форма.НалоговыйКомитет;
				СтрокаОтражения.РННПлательщика 		= 0;
				СтрокаОтражения.Комментарий 		= КомментарийФормы;	
				СтрокаОтражения.Значение			= Значение;
				СтрокаОтражения.ИмяФормы			= ТекИмяФормы;
			КонецЕсли;
		Иначе
			Для Каждого СтрокаТЧ ИЗ ТаблицаСтрок Цикл
				Значение = СтрокаТЧ[ИсточникЗначения];
				Если Значение <> 0 Тогда
					СтрокаОтражения 					= ТаблицаДляОтражениеВУчете.Добавить();
					СтрокаОтражения.ВидНалога 			= ВидНалога;                     
					СтрокаОтражения.ДатаУплаты 			= ПолучитьДатуИзСтроки(ДатаУплаты);
					СтрокаОтражения.КБК 				= КБК;
					СтрокаОтражения.ДатаОтражения 		= ПолучитьДатуИзСтроки(ДатаОтражения);
					СтрокаОтражения.ДатаНачалаОтчета 	= ПолучитьДатуИзСтроки(ДатаНачалаОтчета);
					СтрокаОтражения.ДатаОкончанияОтчета = ПолучитьДатуИзСтроки(ДатаОкончанияОтчета);
					СтрокаОтражения.Организация 		= Форма.Налогоплательщик;
					СтрокаОтражения.СтруктурнаяЕдиница 	= Форма.Налогоплательщик;
					Попытка
						СтрокаОтражения.НалоговыйКомитет 	= СтрокаТЧ[ИсточникНалоговыйКомитет];
					Исключение
					КонецПопытки;	
					СтрокаОтражения.РННПлательщика 		= 0;//РегламентированнаяОтчетность.ЗначениеТаблицыДанныхОбычнойФормы(ТаблицаДанных,РННПлательщика);;
					СтрокаОтражения.Комментарий 		= КомментарийФормы;	
					СтрокаОтражения.Значение			= Значение;
					СтрокаОтражения.ИмяФормы			= ТекИмяФормы;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;	
	КонецЦикла;
	Форма.ЗначениеВРеквизитФормы(ТаблицаДляОтражениеВУчете, "ТаблицаДляОтражениеВУчете");
КонецПроцедуры	

// Функция возвращает таблицу значений, построенную по макету "Отражение в учете"
// 
// Параметры: РеглОтчет - ссылка на документ "Регламентированный отчет"
Функция ПолучитьТаблицуОтраженияВУчете(РеглОтчет, Макет, СписокФормБезИерархии, СписокСтруктурныхЕдиниц, ДополнительныеПараметрыОтражения = Неопределено) Экспорт
	
	// Получим данные для отражения в учете
	
	ТаблицаОтраженияВУчете = Новый ТаблицаЗначений;	
	ТаблицаОтраженияВУчете.Колонки.Добавить("ВидНалога");                     
	ТаблицаОтраженияВУчете.Колонки.Добавить("ДатаУплаты");
	ТаблицаОтраженияВУчете.Колонки.Добавить("КБК");
	ТаблицаОтраженияВУчете.Колонки.Добавить("ДатаОтражения");
	ТаблицаОтраженияВУчете.Колонки.Добавить("ДатаНачалаОтчета");
	ТаблицаОтраженияВУчете.Колонки.Добавить("ДатаОкончанияОтчета");
	ТаблицаОтраженияВУчете.Колонки.Добавить("ИмяФормы");
	ТаблицаОтраженияВУчете.Колонки.Добавить("ИсточникЗначения");
	ТаблицаОтраженияВУчете.Колонки.Добавить("ИсточникДляОрганизации");
	ТаблицаОтраженияВУчете.Колонки.Добавить("Организация"); // сюда запишем ссылку на организацию
	ТаблицаОтраженияВУчете.Колонки.Добавить("СтруктурнаяЕдиница"); // сюда запишем ссылку на структурную единицу
	ТаблицаОтраженияВУчете.Колонки.Добавить("РННПлательщика"); // сюда запишем РНН плательщика
	ТаблицаОтраженияВУчете.Колонки.Добавить("Комментарий");	
	ТаблицаОтраженияВУчете.Колонки.Добавить("Значение"); // сюда запишем значение из структуры данных
	
	// Для обработки дополнительных данных
	ПоказателиОтчета = Новый Структура;
	ПараметрыОтчета = Новый Структура;
	ТаблицаДобавленныхПриложенийДляОтражения = Новый Массив();
	
	Если ДополнительныеПараметрыОтражения <> Неопределено Тогда
		// Определим числовые данные
		ДополнительныеПараметрыОтражения.Свойство("ПоказателиОтчета", ПоказателиОтчета);
		
		Для Каждого ПоказательОтчета Из ПоказателиОтчета Цикл
			ТаблицаОтраженияВУчете.Колонки.Добавить(ПоказательОтчета.Ключ);	
		КонецЦикла;
		
		// Определим прочие колонки
		ДополнительныеПараметрыОтражения.Свойство("ПараметрыОтчета", ПараметрыОтчета);
		
		Для Каждого ПараметрОтчета Из ПараметрыОтчета Цикл
			ТаблицаОтраженияВУчете.Колонки.Добавить(ПараметрОтчета.Ключ);	
		КонецЦикла;
		
		ДополнительныеПараметрыОтражения.Свойство("ТаблицаДобавленныхПриложенийДляОтражения", ТаблицаДобавленныхПриложенийДляОтражения);
		
		Если ТаблицаДобавленныхПриложенийДляОтражения  = Неопределено Тогда
			ТаблицаДобавленныхПриложенийДляОтражения = Новый Массив();
		КонецЕсли;
		
	КонецЕсли;
	
	ТаблицаОтраженияВУчетеФормаМногострочная = ТаблицаОтраженияВУчете.СкопироватьКолонки();
	МассивОтработаныхФорм = НОвый Массив;
	
	Попытка
		ОбластьМакета = Макет.Область(РеглОтчет.ВыбраннаяФорма);
	Исключение
		// такой области в макете нет.
		// возможно документ был создан из отчета не подключенного в настоящий момент к информационной базе.		
		Возврат ТаблицаОтраженияВУчете;
	КонецПопытки;
	
	
	Для Ном = ОбластьМакета.Верх По ОбластьМакета.Низ Цикл
		
		ВидНалога = СокрП(Макет.Область(Ном, 1).Текст);
		
		Если ДополнительныеПараметрыОтражения <> Неопределено
			И ВидНалога = "ИндивидуальныйПодоходныйНалог"
			И (Найти(РеглОтчет.ВыбраннаяФорма, "910")
				ИЛИ Найти(РеглОтчет.ВыбраннаяФорма, "913")) Тогда
			
			ОтражениеДанныхИП = Истина;
			ДополнительныеПараметрыОтражения.Свойство("ОтражениеДанныхИП", ОтражениеДанныхИП);
			
			Если НЕ ОтражениеДанныхИП Тогда
				ВидНалога = "НалогНаПрибыль";
			КонецЕсли;
			
		КонецЕсли;
		
		Если ПустаяСтрока(ВидНалога) Тогда
			// Не считываем пустую строку в области, если она есть по первой колонке.			
			Прервать;
		КонецЕсли;
		
		ДатаУплаты      	   = СокрП(Макет.Область(Ном, 2).Текст);
		КБК                    = СокрП(Макет.Область(Ном, 3).Текст);
		ДатаОтражения          = СокрП(Макет.Область(Ном, 4).Текст);
		ДатаНачалаОтчета       = СокрП(Макет.Область(Ном, 5).Текст);
		ДатаОкончанияОтчета    = СокрП(Макет.Область(Ном, 6).Текст);  
		ТекИмяФормы    		   = СокрП(Макет.Область(Ном, 7).Текст);  
		ИсточникЗначения	   = СокрП(Макет.Область(Ном, 8).Текст);  		
		ИсточникДляОрганизации = СокрП(Макет.Область(Ном, 9).Текст);  
		РННПлательщика		   = СокрП(Макет.Область(Ном, 10).Текст);  
		КомментарийФормы       = СокрП(Макет.Область(Ном, 11).Текст);
		
		Если ВидНалога = "НалогНаПрибыль" И (Найти(РеглОтчет.ВыбраннаяФорма, "910") ИЛИ Найти(РеглОтчет.ВыбраннаяФорма, "913")) Тогда
			КБК                = "101101";
			КомментарийФормы   = НСтр("ru = 'КПН'", ОбщегоНазначения.КодОсновногоЯзыка());
		КонецЕсли;
		
		НоваяСтрока = ТаблицаОтраженияВУчете.Добавить();		
		НоваяСтрока.ВидНалога		       = ВидНалога;
		НоваяСтрока.ДатаУплаты             = ПолучитьДатуИзСтроки(ДатаУплаты);
		НоваяСтрока.КБК            		   = КБК;
		НоваяСтрока.ДатаОтражения          = ПолучитьДатуИзСтроки(ДатаОтражения);
		НоваяСтрока.ДатаНачалаОтчета       = ПолучитьДатуИзСтроки(ДатаНачалаОтчета);	
		НоваяСтрока.ДатаОкончанияОтчета    = ПолучитьДатуИзСтроки(ДатаОкончанияОтчета);	
		НоваяСтрока.ИмяФормы     		   = ТекИмяФормы;  
		НоваяСтрока.ИсточникЗначения	   = ИсточникЗначения;           
		НоваяСтрока.Организация            = Справочники.Организации.ПустаяСсылка();
		НоваяСтрока.СтруктурнаяЕдиница     = Справочники.Организации.ПустаяСсылка();
		НоваяСтрока.ИсточникДляОрганизации = ИсточникДляОрганизации;           
		НоваяСтрока.РННПлательщика		   = РННПлательщика;           
		НоваяСтрока.Комментарий   		   = КомментарийФормы;           
		
		Для Каждого ПоказательОтчета Из ПоказателиОтчета Цикл
			НоваяСтрока[ПоказательОтчета.Ключ] = СокрП(Макет.Область(Ном, ПоказательОтчета.Значение).Текст);			
		КонецЦикла;
		
		Для Каждого ПараметрОтчета Из ПараметрыОтчета Цикл
			НоваяСтрока[ПараметрОтчета.Ключ] = СокрП(Макет.Область(Ном, ПараметрОтчета.Значение).Текст);			
		КонецЦикла;
		
	КонецЦикла;           	
	
	//Для регл.отчета Форма 700.
	//Проходим по списку добавленных приложений и заполняем данные по приложениям 700.01 (многострочные 700.02 не трогаем, т.к. они заполнятся отдельно из ТаблицаДляОтражениеВУчете)
	Для Каждого Приложение Из ТаблицаДобавленныхПриложенийДляОтражения Цикл
		
		Если  СтрНайти(Приложение.КодФормы, "Форма700_01") <> 0 Тогда
			
			КодФормы = Приложение.КодФормы;
			КодФормыБезПрефикса = Сред(КодФормы, 6);
			
			Ном = ОбластьМакета.Низ;
			
			ВидНалога = СокрП(Макет.Область(Ном, 1).Текст);
			
			Если ПустаяСтрока(ВидНалога) Тогда
				// Не считываем пустую строку в области, если она есть по первой колонке.			
				Прервать;
			КонецЕсли;
			
			ДатаУплаты      	   = СокрП(Макет.Область(Ном, 2).Текст);
			КБК                    = СокрП(Макет.Область(Ном, 3).Текст);
			ДатаОтражения          = СокрП(Макет.Область(Ном, 4).Текст);
			ДатаНачалаОтчета       = СокрП(Макет.Область(Ном, 5).Текст);
			ДатаОкончанияОтчета    = СокрП(Макет.Область(Ном, 6).Текст);  
			ТекИмяФормы    		   = КодФормы;  
			ИсточникЗначения	   = "s_" + КодФормыБезПрефикса + "_038";  		
			ИсточникДляОрганизации = СокрП(Макет.Область(Ном, 9).Текст);  
			РННПлательщика		   = СокрП(Макет.Область(Ном, 10).Текст);  
			КомментарийФормы       = СокрП(Макет.Область(Ном, 11).Текст);
			
			НоваяСтрока = ТаблицаОтраженияВУчете.Добавить();		
			НоваяСтрока.ВидНалога		       = ВидНалога;
			НоваяСтрока.ДатаУплаты             = ПолучитьДатуИзСтроки(ДатаУплаты);
			НоваяСтрока.КБК            		   = КБК;
			НоваяСтрока.ДатаОтражения          = ПолучитьДатуИзСтроки(ДатаОтражения);
			НоваяСтрока.ДатаНачалаОтчета       = ПолучитьДатуИзСтроки(ДатаНачалаОтчета);	
			НоваяСтрока.ДатаОкончанияОтчета    = ПолучитьДатуИзСтроки(ДатаОкончанияОтчета);	
			НоваяСтрока.ИмяФормы     		   = ТекИмяФормы;  
			НоваяСтрока.ИсточникЗначения	   = ИсточникЗначения;           
			НоваяСтрока.Организация            = Справочники.Организации.ПустаяСсылка();
			НоваяСтрока.СтруктурнаяЕдиница     = Справочники.Организации.ПустаяСсылка();
			НоваяСтрока.ИсточникДляОрганизации = ИсточникДляОрганизации;           
			НоваяСтрока.РННПлательщика		   = РННПлательщика;           
			НоваяСтрока.Комментарий   		   = КомментарийФормы;
			
			Для Каждого ПоказательОтчета Из ПоказателиОтчета Цикл
				НоваяСтрока[ПоказательОтчета.Ключ] = СокрП(Макет.Область(Ном, ПоказательОтчета.Значение).Текст);			
			КонецЦикла;
			
			Для Каждого ПараметрОтчета Из ПараметрыОтчета Цикл
				НоваяСтрока[ПараметрОтчета.Ключ] = Приложение.МестныйБюджет;			
			КонецЦикла;
		КонецЕсли;	
	КонецЦикла;	
	
	Налогоплательщик = РеглОтчет.Организация;	
	
	ТекущееИмяФормы = Неопределено;
	
	//Выполнять ежемесячный расчет взносов и отчислений за ИП 
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("парамНалогоплательщик", Налогоплательщик);
	Запрос.УстановитьПараметр("парамПериод", РеглОтчет.ДатаОкончания);
	Запрос.Текст = "ВЫБРАТЬ Разрешенные
	|	УчетнаяПолитикаНалоговыйУчетСрезПоследних.ЕжемесячныйРасчетВзносовИОтчисленийЗаИП
	|ИЗ
	|	РегистрСведений.УчетнаяПолитикаНалоговыйУчет.СрезПоследних(&парамПериод, Организация = &парамНалогоплательщик) КАК УчетнаяПолитикаНалоговыйУчетСрезПоследних";
	
	Выборка = Запрос.Выполнить().Выбрать();
	Если Выборка.Следующий() Тогда
		ЕжемесячныйРасчетВзносовИОтчисленийЗаИП = Выборка.ЕжемесячныйРасчетВзносовИОтчисленийЗаИП;
	КонецЕсли;
	
	ЕстьНалоговыйКомитет = ?(ТаблицаОтраженияВУчете.Колонки.Найти("НалоговыйКомитет")= Неопределено, Ложь, Истина);
	// заполним значения в полученной таблице	
	Для Каждого Элемент Из ТаблицаОтраженияВУчете Цикл
		КодФормы = Элемент.ИмяФормы;
		Если ТекущееИмяФормы <> КодФормы Тогда
			НайденнаяСтрока = СписокФормБезИерархии.Строки.Найти(КодФормы,"КодФормы");
			ТаблицаДанных = НайденнаяСтрока.Значение;
			ФормаМногострочная = НайденнаяСтрока.Многострочность = 1;
		КонецЕсли;
		
		Если ФормаМногострочная И Не ДополнительныеПараметрыОтражения.Свойство("ТаблицаДобавленныхПриложенийДляОтражения") Тогда // форма многострочная					
			Если МассивОтработаныхФорм.Найти(КодФормы) <> Неопределено Тогда
				Продолжить;
			КонецЕсли;	
			ДанныеОтчета = РеглОтчет.ДанныеОтчета.Получить();
			СтруктураДополнительныхРеквизитовФормы = ДанныеОтчета.СтруктураДополнительныхРеквизитовФормы;
			Если СтруктураДополнительныхРеквизитовФормы.Свойство("ТаблицаДляОтражениеВУчете") Тогда
				//ТаблицаОтраженияВУчете.Загрузить(СтруктураДополнительныхРеквизитовФормы.ТаблицаДляОтражениеВУчете.Выгрузить());
				ТаблицаДляОтраженияВУчете = СтруктураДополнительныхРеквизитовФормы.ТаблицаДляОтражениеВУчете;
				ПараметрОтбораСтрок = Новый Структура("ИмяФормы", КодФормы);
				МассивОтработаныхФорм.Добавить(КодФормы);
				МассивСтрок =  ТаблицаДляОтраженияВУчете.НайтиСтроки(ПараметрОтбораСтрок);
				Для Каждого СтрокаМассива Из МассивСтрок Цикл
					НоваяСтрокаТЧ = ТаблицаОтраженияВУчетеФормаМногострочная.Добавить();
					ЗаполнитьЗначенияСвойств(НоваяСтрокаТЧ,СтрокаМассива);
				КонецЦикла;	
			КонецЕсли;	
		Иначе // форма обычная
			// получим значение ячейки - источника
			Если Найти(РеглОтчет.ВыбраннаяФорма, "910") ИЛИ Найти(РеглОтчет.ВыбраннаяФорма, "913") Тогда
				Если Элемент.ДатаНачалаОтчета >= РеглОтчет.ДатаНачала 
					И Элемент.ДатаОкончанияОтчета <= РеглОтчет.ДатаОкончания Тогда
					
					ЗначениеОбласти = ЗначениеТаблицыДанныхОбычнойФормы(ТаблицаДанных, Элемент.ИсточникЗначения);
					Если ЕжемесячныйРасчетВзносовИОтчисленийЗаИП И (Элемент.ВидНалога = "ОбязательныеПенсионныеВзносы" 
						ИЛИ Элемент.ВидНалога = "ОбязательныеСоциальныеОтчисления"
						ИЛИ Элемент.ВидНалога = "ВзносыОбязательноеСоциальноеМедицинскоеСтрахование") Тогда
						Элемент.Значение = 0;
					Иначе
						Элемент.Значение = ЗначениеОбласти;
					КонецЕсли;
				Иначе 
					Элемент.Значение = 0;
				КонецЕсли;
			Иначе
				ЗначениеОбласти = ЗначениеТаблицыДанныхОбычнойФормы(ТаблицаДанных, Элемент.ИсточникЗначения);			
				Элемент.Значение = ЗначениеОбласти;
			КонецЕсли;	
			
			// получим значение РНН плательщика
			ЗначениеРНН = ЗначениеТаблицыДанныхОбычнойФормы(ТаблицаДанных, Элемент.РННПлательщика);			
			Элемент.РННПлательщика = ЗначениеРНН;
			
			// получим организацию
			Элемент.Организация = Налогоплательщик;
			
			// получим структурную единицу
			Если СписокСтруктурныхЕдиниц.Количество() = 1 Тогда
				Элемент.СтруктурнаяЕдиница = СписокСтруктурныхЕдиниц[0].Значение;			
			Иначе //по нескольким структ.единицам
				Элемент.СтруктурнаяЕдиница = Налогоплательщик;			
			КонецЕсли;
			
		КонецЕсли;
		
		Для Каждого ПоказательОтчета Из ПоказателиОтчета Цикл
			ЗначениеПоказателя = ЗначениеТаблицыДанныхОбычнойФормы(ТаблицаДанных, Элемент[ПоказательОтчета.Ключ]);			
			Элемент[ПоказательОтчета.Ключ] = ЗначениеПоказателя;
		КонецЦикла;
		
		Для Каждого ПараметрОтчета Из ПараметрыОтчета Цикл
			Если ЕстьНалоговыйКомитет Тогда
				Если  Элемент.НалоговыйКомитет = "НалоговыйКомитет" Тогда 
					Если Элемент.Организация.УчетПоМестнымБюджетам И Не Элемент.ВидНалога = "НалогНаИмущество" Тогда
						Элемент.НалоговыйКомитет = Элемент.Организация.МестныйБюджет;
					Иначе
						ЗначениеПараметра = Вычислить("РеглОтчет." + Элемент[ПараметрОтчета.Ключ]);	
						Элемент[ПараметрОтчета.Ключ] = ЗначениеПараметра;
					КонецЕсли; 
				КонецЕсли; 				
			Иначе
				ЗначениеПараметра = Вычислить("РеглОтчет." + Элемент[ПараметрОтчета.Ключ]);	
				Элемент[ПараметрОтчета.Ключ] = ЗначениеПараметра;
			КонецЕсли;					
		КонецЦикла;
		
		ТекущееИмяФормы = КодФормы;		
	КонецЦикла;
	
	//Для Формы 700. Заполнение многострочных приложений 700.02 по таблице ТаблицаДляОтражениеВУчете.
	Если ДополнительныеПараметрыОтражения <> Неопределено Тогда
		Если ДополнительныеПараметрыОтражения.Свойство("ТаблицаДобавленныхПриложенийДляОтражения") Тогда	
			ДанныеОтчета = РеглОтчет.ДанныеОтчета.Получить();
			СтруктураДополнительныхРеквизитовФормы = ДанныеОтчета.СтруктураДополнительныхРеквизитовФормы;
			Если СтруктураДополнительныхРеквизитовФормы.Свойство("ТаблицаДляОтражениеВУчете") Тогда
				ТаблицаДляОтраженияВУчете = СтруктураДополнительныхРеквизитовФормы.ТаблицаДляОтражениеВУчете;
				Для Каждого СтрокаМассива Из ТаблицаДляОтраженияВУчете Цикл
					НоваяСтрокаТЧ = ТаблицаОтраженияВУчетеФормаМногострочная.Добавить();
					ЗаполнитьЗначенияСвойств(НоваяСтрокаТЧ,СтрокаМассива);
				КонецЦикла;	
			КонецЕсли;
		КонецЕсли;
	КонецЕсли;
	
	Для Каждого СтрокаТЧ Из ТаблицаОтраженияВУчетеФормаМногострочная Цикл
		НоваяСтрокаТЧ = ТаблицаОтраженияВУчете.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрокаТЧ,СтрокаТЧ);
	КонецЦикла;	
	
	Возврат ТаблицаОтраженияВУчете;
	
КонецФункции // ПолучитьТаблицуОтраженияВУчете()

// Функция преобразовывает строковое значение в дату
//
Функция ПолучитьДатуИзСтроки(Источник) Экспорт
	
	ПустаяДата = РегламентированнаяОтчетностьКлиентСервер.ПустоеЗначениеТипа(Тип("Дата"));
	
	Буфер = Источник;
	
	ПозицияТочки = Найти(Буфер, ".");
	
	Если ПозицияТочки = 0 Тогда
		Возврат ПустаяДата;
	КонецЕсли;
	
	ЧислоДаты = Лев(Буфер, ПозицияТочки - 1);
	Буфер = Сред(Буфер, ПозицияТочки + 1);
	
	ПозицияТочки = Найти(Буфер, ".");
	
	Если ПозицияТочки = 0 Тогда
		Возврат ПустаяДата;
	КонецЕсли;
	
	МесяцДаты = Лев(Буфер, ПозицияТочки - 1);
	ГодДаты = Сред(Буфер, ПозицияТочки + 1);
	
	Попытка 
		ПолученнаяДата = Дата(Число(ГодДаты), Число(МесяцДаты), Число(ЧислоДаты));;
	Исключение
		ПолученнаяДата = ПустаяДата;		
	КонецПопытки;
	
	Возврат ПолученнаяДата;
	
КонецФункции // ПолучитьДатуИзСтроки()


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ВЫГРУЗКИ РЕГЛАМЕНТИРОВАННЫХ ОТЧЕТОВ

// Формирует построчно структуру XML файла из макета "ВыгрузкаВXML"
//
Процедура ВыгрузитьСтрокуВXML(Форма,Запись, ТаблицаВыгрузки, КоличествоСтрокВТаблице, НомерСтроки, ТекущаяФорма = Неопределено, ТекСтраница = Неопределено) Экспорт
	
	СтрокаВыгрузки = ТаблицаВыгрузки.Получить(НомерСтроки);
	НоваяФорма = СтрокаВыгрузки.Форма; 
	НоваяСтраница = СтрокаВыгрузки.Страница; 
	
	Если ТекущаяФорма <> Неопределено И НоваяФорма <> ТекущаяФорма Тогда
	   Запись.ЗаписатьКонецЭлемента();			// </sheet>
   КонецЕсли;
   
	Если НЕ НоваяФорма = ТекущаяФорма Тогда		
		Если НЕ ТекущаяФорма = Неопределено Тогда
			Запись.ЗаписатьКонецЭлемента();			// </sheetGroup>
			Запись.ЗаписатьКонецЭлемента();			// </form>
		КонецЕсли;
		Запись.ЗаписатьНачалоЭлемента("form");		
		Запись.ЗаписатьАтрибут("name",СтрокаВыгрузки.Форма);
		Запись.ЗаписатьНачалоЭлемента("sheetGroup");
	КонецЕсли;   
	
	Если НЕ НоваяСтраница = ТекСтраница Тогда
		Если ТекущаяФорма <> Неопределено И НоваяФорма <> ТекущаяФорма Тогда
			// ничего не делаем
	    ИначеЕсли НЕ ТекСтраница = Неопределено Тогда		
			Запись.ЗаписатьКонецЭлемента();			// </sheet>
		КонецЕсли;
		Запись.ЗаписатьНачалоЭлемента("sheet");
		Запись.ЗаписатьАтрибут("name",СтрокаВыгрузки.Страница);
	КонецЕсли;


	Если СтрокаВыгрузки.Многострочность <> Неопределено И СтрокаВыгрузки.Многострочность = 1 Тогда 
		ВыгрузитьМногострочнуюФорму(Форма, Запись, ТаблицаВыгрузки, КоличествоСтрокВТаблице, НомерСтроки, ТекСтраница);
	// проверим многострочное ли значение
	ИначеЕсли ЗначениеЗаполнено(СтрокаВыгрузки.КоличествоROW) И СтрокаВыгрузки.КоличествоROW <> "0" Тогда  // для обычных форм
		// если в обычной форме встретилась многострочность 
		КоличествоПовторений = Число(СтрокаВыгрузки.КоличествоROW);
		Для Н = 1 По КоличествоПовторений Цикл 				
			Запись.ЗаписатьНачалоЭлемента("row");
			СтрокаВыгрузки = ТаблицаВыгрузки.Получить(НомерСтроки);
			Если Н = 1 Тогда
				ТаблицаМногострочныхТегов = ТаблицаВыгрузки.СкопироватьКолонки();
				НоваяСтрока = ТаблицаМногострочныхТегов.Добавить();			
				ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаВыгрузки);
				
				// Проверим многострочная ли следующая строка
				СледСтрокаВыгрузки = ТаблицаВыгрузки.Получить(НомерСтроки+1);
				Пока ЗначениеЗаполнено(СледСтрокаВыгрузки.КоличествоROW) И СледСтрокаВыгрузки.КоличествоROW <> "0" Цикл
					НомерСтроки = НомерСтроки+1;
					НоваяСтрока = ТаблицаМногострочныхТегов.Добавить();			
					ЗаполнитьЗначенияСвойств(НоваяСтрока, СледСтрокаВыгрузки);
					Если (ТаблицаВыгрузки.Количество()-1) > НомерСтроки  Тогда
						СледСтрокаВыгрузки = ТаблицаВыгрузки.Получить(НомерСтроки+1);
					Иначе
						Прервать;
					КонецЕсли;
				КонецЦикла;   				
			КонецЕсли;
			Для Каждого МногСтрока Из ТаблицаМногострочныхТегов Цикл
				ЗаписатьЗначениеЭлемента(Запись, МногСтрока);	
			КонецЦикла;    			
			Запись.ЗаписатьКонецЭлемента();			// </row>
		КонецЦикла;			
	Иначе
		ЗаписатьЗначениеЭлемента(Запись, СтрокаВыгрузки);
	КонецЕсли;	      	
	
	ТекущаяФорма = НоваяФорма;
	ТекСтраница = НоваяСтраница;
	
КонецПроцедуры // ВыгрузитьСтрокуВXML()

// Выгружает многострочные формы в XML
//
Процедура ВыгрузитьМногострочнуюФорму(Форма, Запись, ТаблицаВыгрузки, КоличествоСтрокВТаблице, НомерСтроки, ТекСтраница)
	
	Перем СтруктураГруппы;
	
	СтрокаВыгрузки = ТаблицаВыгрузки.Получить(НомерСтроки);	
	
	Если СтрокаВыгрузки.КоличествоНаЛисте = 1 Тогда  // форма многостраничная
		
		// для многострочной = одностраничной
		
		НачальнаяСтрока = НомерСтроки;
		КонечнаяСтрока = 0;
		
		ТекущаяФорма = СтрокаВыгрузки.Форма;
		СледСтрокаВыгрузки = ТаблицаВыгрузки.Получить(НомерСтроки+1);
		НоваяФорма = СледСтрокаВыгрузки.Форма;
		Пока НоваяФорма = ТекущаяФорма Цикл
			НомерСтроки = НомерСтроки+1;
			
			ТекущаяФорма = СледСтрокаВыгрузки.Форма;
			Если НомерСтроки+1 < КоличествоСтрокВТаблице Тогда
				СледСтрокаВыгрузки = ТаблицаВыгрузки.Получить(НомерСтроки+1);						
				НоваяФорма = СледСтрокаВыгрузки.Форма;
				КонечнаяСтрока = НомерСтроки;
			Иначе
				НоваяФорма = Неопределено;
				КонечнаяСтрока = НомерСтроки;
			КонецЕсли;
		КонецЦикла;    		
		
		МногСтруктура = РегламентированнаяОтчетность.ПолучитьМногострочнуюСтруктуру(Форма, СтрокаВыгрузки.КодФормы);	
		
		КоличествоЗаписей = 0;
		
		Для Каждого КлючИЗначение Из МногСтруктура Цикл
			ТаблицаСтрокГруппы = КлючИЗначение.Значение.Строки;
			КоличествоЗаписей =  ТаблицаСтрокГруппы.Количество();
			Прервать;
		КонецЦикла;
		
		ВсегоСтр = 0;
		
		Если КоличествоЗаписей <= 1 Тогда 
			ВсегоСтр = 0;
		Иначе 
			ВсегоСтр = КоличествоЗаписей - 1;	
		КонецЕсли;
				
		ОдинШаг = Истина;
		НачальнаяСтрока = НачальнаяСтрока - 1;	
		
		Для ШагФорм = 0 По ВсегоСтр Цикл 
			
			Для Шаг = НачальнаяСтрока По КонечнаяСтрока Цикл  
				
				Если Шаг = КонечнаяСтрока Тогда 
					Прервать;
				КонецЕсли;
				
				СтрокаВыгрузкиТек = ТаблицаВыгрузки.Получить(Шаг);
				ТекущаяФорма 	  = СтрокаВыгрузкиТек.Форма; 
				ТекСтраница   = СтрокаВыгрузкиТек.Страница;
				
				СтрокаВыгрузкиСлед = ТаблицаВыгрузки.Получить(Шаг + 1);
								
				НоваяФорма 		   = СтрокаВыгрузкиСлед.Форма; 
				НоваяСтраница      = СтрокаВыгрузкиСлед.Страница; 		
					
				Если ОдинШаг Тогда 
					НомерЛиста = Новый Структура;
					НомерЛиста.Вставить("НомерЛиста",ШагФорм);
					ЗаписатьЗначениеЭлемента(Запись, СтрокаВыгрузкиСлед, МногСтруктура, НомерЛиста);		            
					ОдинШаг = Ложь;
					Продолжить;
				КонецЕсли;
				              											
				Если НЕ НоваяФорма = ТекущаяФорма Тогда	
					Запись.ЗаписатьКонецЭлемента();			// </sheet>
					Запись.ЗаписатьКонецЭлемента();			// </sheetGroup>
					Запись.ЗаписатьКонецЭлемента();			// </form>
					Запись.ЗаписатьНачалоЭлемента("form");					
					Запись.ЗаписатьАтрибут("name",СтрокаВыгрузкиСлед.Форма);
					Запись.ЗаписатьНачалоЭлемента("sheetGroup");
				КонецЕсли;    
				Если НЕ НоваяСтраница = ТекСтраница Тогда
					Если НоваяФорма <> ТекущаяФорма Тогда
						// ничего не делаем
					Иначе
						Запись.ЗаписатьКонецЭлемента();			// </sheet>
					КонецЕсли;
					Запись.ЗаписатьНачалоЭлемента("sheet");
					Запись.ЗаписатьАтрибут("name",СтрокаВыгрузкиСлед.Страница);
				КонецЕсли;

				НомерЛиста = Новый Структура;
				НомерЛиста.Вставить("НомерЛиста",ШагФорм);
				ЗаписатьЗначениеЭлемента(Запись, СтрокаВыгрузкиСлед, МногСтруктура, НомерЛиста);
			КонецЦикла;
			//	
			//Если ОдинШагНазад Тогда 
			//	НачальнаяСтрока = НачальнаяСтрока - 1;
			//	ОдинШагНазад = Ложь;
			//КонецЕсли;
		КонецЦикла;

	Иначе // форма многострочная
		
		// Определяем одинаковое ли количество строк на всех страницах формы и создаем таблицу значений
		// например, в форме 300.07 и 300.08 одинаковое количество
		// а в других может быть неодинаковое - и там другой механизм выгрузки по строкам
		ОдинаковоеКоличествоСтрок = Истина;
		КоличествоСтрокНаЛисте = 0;
		
		ТаблицаМногострочнойФормы = ТаблицаВыгрузки.СкопироватьКолонки();
		НоваяСтрока = ТаблицаМногострочнойФормы.Добавить();			
		ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаВыгрузки);
		
		ТекущаяФорма = СтрокаВыгрузки.Форма;
		СледСтрокаВыгрузки = ТаблицаВыгрузки.Получить(НомерСтроки+1);
		НоваяФорма = СледСтрокаВыгрузки.Форма;
		Пока НоваяФорма = ТекущаяФорма Цикл
			НомерСтроки = НомерСтроки+1;
			НоваяСтрока = ТаблицаМногострочнойФормы.Добавить();			
			ЗаполнитьЗначенияСвойств(НоваяСтрока, СледСтрокаВыгрузки);
			Если ЗначениеЗаполнено(СледСтрокаВыгрузки.КоличествоROW) И СледСтрокаВыгрузки.КоличествоROW <> "0" Тогда
				ТекКоличествоСтрокНаЛисте = Число(СледСтрокаВыгрузки.КоличествоROW);
				Если КоличествоСтрокНаЛисте <> 0 И КоличествоСтрокНаЛисте <> ТекКоличествоСтрокНаЛисте Тогда
					 ОдинаковоеКоличествоСтрок = Ложь;
				КонецЕсли;
				КоличествоСтрокНаЛисте = Число(СледСтрокаВыгрузки.КоличествоROW);
			КонецЕсли;
			ТекущаяФорма = СледСтрокаВыгрузки.Форма;
			Если НомерСтроки+1 < КоличествоСтрокВТаблице Тогда
				СледСтрокаВыгрузки = ТаблицаВыгрузки.Получить(НомерСтроки+1);						
				НоваяФорма = СледСтрокаВыгрузки.Форма;
			Иначе
				НоваяФорма = Неопределено;
			КонецЕсли;
		КонецЦикла;
		
		//Выгружаем многострочные данные, у которых одинаковое количество строк
		//Если ОдинаковоеКоличествоСтрок Тогда //как для 300.07, 300.08 и большинства других многострочных
			
			// Определим количество <sheetGroup>
			//МногСтруктура = СтрокаВыгрузки.Значение[0].Данные;
			МногСтруктура = РегламентированнаяОтчетность.ПолучитьМногострочнуюСтруктуру(Форма, СтрокаВыгрузки.КодФормы); 
			
			КоличествоЗаписей = 0;
			Для Каждого КлючИЗначение Из МногСтруктура Цикл
				ТаблицаСтрокГруппы = КлючИЗначение.Значение.Строки;
				КоличествоЗаписей =  ТаблицаСтрокГруппы.Количество();
				Прервать;
			КонецЦикла;
		
			мКоличествоНаЛисте = СтрокаВыгрузки.КоличествоНаЛисте; // из макета Показатели
			Стр =  Цел(КоличествоЗаписей/мКоличествоНаЛисте);
			Если Стр = КоличествоЗаписей/мКоличествоНаЛисте  Тогда
				ВсегоСтр = Стр;
			Иначе
				ВсегоСтр = Стр + 1;
			КонецЕсли;
			
			Если КоличествоЗаписей = 0 Тогда // форма не заполнена, то выгружаем пустые теги
				ВсегоСтр = 1;
			КонецЕсли;
			
			Для КолСтр = 1 По ВсегоСтр Цикл // sheetgroup
				Если КолСтр <> 1 Тогда
					Запись.ЗаписатьКонецЭлемента();		// </sheet>
					Запись.ЗаписатьКонецЭлемента();		// </sheetgroup>
					Запись.ЗаписатьНачалоЭлемента("sheetGroup");
					Запись.ЗаписатьНачалоЭлемента("sheet");
					Запись.ЗаписатьАтрибут("name", СтрокаВыгрузки.Страница);
				КонецЕсли;

				ТекСтраница = СтрокаВыгрузки.Страница;
				Для Ном = 0 По ТаблицаМногострочнойФормы.Количество()-1 Цикл 
					СтрокаТаблицы = ТаблицаМногострочнойФормы[Ном];				
					НоваяСтраница = СтрокаТаблицы.Страница;					
					Если НоваяСтраница <> ТекСтраница Тогда
						 Запись.ЗаписатьКонецЭлемента();		// </sheet>
						 Запись.ЗаписатьНачалоЭлемента("sheet");
						 Запись.ЗаписатьАтрибут("name", СтрокаТаблицы.Страница);
					КонецЕсли;		                       
					// если перешли на новую страницу
					Если ЗначениеЗаполнено(СтрокаТаблицы.Отображение) И КолСтр <> Число(СтрокаТаблицы.Отображение) Тогда
						Продолжить;
					КонецЕсли;
					// проверим элемент это или нет
					Если Лев(СтрокаТаблицы.ИмяАтрибута,1) = "#" Тогда
						Атрибут = Сред(СтрокаТаблицы.ИмяАтрибута,2);
						// опеределим начальный или конечный элемент
						Если Лев(Атрибут,1) = "/" Тогда // это конечный элемент							
							Запись.ЗаписатьКонецЭлемента();
						Иначе // это начальный
							Запись.ЗаписатьНачалоЭлемента(Атрибут);
						КонецЕсли;						
					ИначеЕсли ЗначениеЗаполнено(СтрокаТаблицы.КоличествоROW) И СтрокаТаблицы.КоличествоROW <> "0" Тогда
						
						КоличествоПовторений = Число(СтрокаТаблицы.КоличествоROW);
						Если КолСтр = ВсегоСтр И КолСтр <> 1  Тогда // рассчитаем сколько должно быть строк на последней странице, при этом на 1 стр - должно быть количество строк как в макете
							КоличествоПовторений = КоличествоЗаписей - КоличествоПовторений*(КолСтр-1);
						КонецЕсли;
						Для Н = 1 По КоличествоПовторений Цикл // ТаблицаМногострочнойФормы.Количество() Цикл 
							Запись.ЗаписатьНачалоЭлемента("row");							
							Если Н = 1 Тогда
								ТаблицаМногострочныхТегов = ТаблицаМногострочнойФормы.СкопироватьКолонки();
								НоваяСтрока = ТаблицаМногострочныхТегов.Добавить();			
								ЗаполнитьЗначенияСвойств(НоваяСтрока, СтрокаТаблицы);
								
								// Проверим многострочная ли следующая строка
								СледСтрокаВыгрузки = ТаблицаМногострочнойФормы.Получить(Ном+1);
								Пока ЗначениеЗаполнено(СледСтрокаВыгрузки.КоличествоROW) И СледСтрокаВыгрузки.КоличествоROW <> "0" Цикл
									Ном = Ном+1;
									НоваяСтрока = ТаблицаМногострочныхТегов.Добавить();			
									ЗаполнитьЗначенияСвойств(НоваяСтрока, СледСтрокаВыгрузки);
									Если Ном + 1 = ТаблицаМногострочнойФормы.Количество() Тогда
										Прервать;
									КонецЕсли;
									СледСтрокаВыгрузки = ТаблицаМногострочнойФормы.Получить(Ном+1);
								КонецЦикла;   				
							КонецЕсли;
							Для Каждого МногСтрока Из ТаблицаМногострочныхТегов Цикл
								СтруктураПараметров = Новый Структура;
								СтруктураПараметров.Вставить("КоличествоГруппСтраниц", КолСтр);
								СтруктураПараметров.Вставить("НомерЗаписи", Н);
								ЗаписатьЗначениеЭлемента(Запись, МногСтрока, МногСтруктура, СтруктураПараметров);	
							КонецЦикла;    			
												
							Запись.ЗаписатьКонецЭлемента();			// </row>
						КонецЦикла;	
					Иначе			
						СтруктураПараметров = Новый Структура;
						СтруктураПараметров.Вставить("КоличествоГруппСтраниц", КолСтр);
						ЗаписатьЗначениеЭлемента(Запись, СтрокаТаблицы, МногСтруктура, СтруктураПараметров);					
					КонецЕсли;				 
					СтрокаТаблицы = ТаблицаМногострочнойФормы[Ном];				
					ТекСтраница = СтрокаТаблицы.Страница;
				КонецЦикла; 
			КонецЦикла; 				
		
	КонецЕсли;	
	
КонецПроцедуры // ВыгрузитьМногострочнуюФорму300()

//Приводит значение к нужному формату для выгрузки в формате XML
//
Функция ПривестиЗначениеКФорматуСОНО(Значение, ВыгружатьНулевыеЗначения = Ложь) 
    
    Если Врег(Значение) = "Х" ИЛИ Врег(Значение) = "X" Тогда
		Значение = Истина;
	ИначеЕсли ТипЗнч(Значение) = Тип("Дата") Тогда
		Если Значение = Дата('00010101') Тогда
			Значение = "";
		Иначе
			Значение = Лев(Значение,10);
		КонецЕсли;
	ИначеЕсли ТипЗнч(Значение) = Тип("Число") И Значение = 0 И НЕ ВыгружатьНулевыеЗначения Тогда
		Значение = "";
   	ИначеЕсли ТипЗнч(Значение) = Тип("СписокЗначений") Тогда	
        МассивЗначение  = Значение.ВыгрузитьЗначения();
        Значение = СтрСоединить(МассивЗначение, ";");      
	ИначеЕсли Значение = Неопределено И ВыгружатьНулевыеЗначения Тогда	
		Значение = 0;
	КонецЕсли;
	
	Возврат Значение;	
	
КонецФункции // ПривестиЗначениеКФорматуСОНО300()

// Записываем значение в поле field из структуры хранения данных
//
Процедура ЗаписатьЗначениеЭлемента(Запись, СтрокаВыгрузки, МногСтруктура = Неопределено,  СтруктураПараметров = Неопределено)
	
	Запись.ЗаписатьНачалоЭлемента("field");
	Запись.ЗаписатьАтрибут("name",СтрокаВыгрузки.ИмяАтрибута);
	// Выгрузим значение ячейки, если оно есть в форме
	ИмяЯчейки = СтрокаВыгрузки.ИмяЯчейки;
	Если ЗначениеЗаполнено(ИмяЯчейки) Тогда
		//получаем и записываем значение из отчета		
		Если СтрокаВыгрузки.Выгружать = 1 Тогда
			Если СтрокаВыгрузки.Многострочность Тогда
				// определим имя Листа по имени страницы
				ИмяЛиста = СтрокаВыгрузки.ИмяЛиста;
				СтруктураГруппы = Неопределено;
				//если в обычной форме, есть многострочность
				Если МногСтруктура = Неопределено Тогда
					МногСтруктура = СтрокаВыгрузки.Значение[0].Данные;
				КонецЕсли;
				
				Если ЗначениеЗаполнено(ИмяЛиста) И МногСтруктура.Свойство(ИмяЛиста) Тогда            					
					МногСтруктура.Свойство(ИмяЛиста,СтруктураГруппы);				
				Иначе
					ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = '%1: Не заполнено ""Имя листа"" или ""Имя листа"" указано неверно для ячейки ""%2"" в макете для выгрузки значения в XML!'"),
																  СтрокаВыгрузки.КодФормы,
																  ИмяЯчейки);
																  
			 		ОбщегоНазначения.СообщитьПользователю(ТекстСообщения);	
				КонецЕсли;
					
				Если ИмяЯчейки = "НомерСтраницы"  И НЕ СтруктураПараметров = Неопределено Тогда
					КолСтр = Неопределено;
					СтруктураПараметров.Свойство("КоличествоГруппСтраниц", КолСтр);
					Запись.ЗаписатьТекст(XMLСтрока(Формат(КолСтр,"ЧЦ=3; ЧВН=")));
					// заполнения многостраничных данных	
				ИначеЕсли СтрокаВыгрузки.КоличествоНаЛисте = 1 Тогда  
				    Если СтруктураГруппы <> Неопределено Тогда
						 НомерЛиста = СтруктураПараметров.НомерЛиста;
						 СтрокаЗначений = СтруктураГруппы.Строки[НомерЛиста];
						 Попытка
							 Строка = СтрокаЗначений[ИмяЯчейки];
						 Исключение
							 Строка = Неопределено;
						 КонецПопытки;
						 Если Строка <> Неопределено Тогда
							 Значение = Строка;
							 Значение = ПривестиЗначениеКФорматуСОНО(Значение, СтрокаВыгрузки.ВыгружатьНулевыеЗначения); //СтрокаФорматов);
				    		 Запись.ЗаписатьТекст(XMLСтрока(Значение));
						 КонецЕсли;
					 КонецЕсли;
				ИначеЕсли ЗначениеЗаполнено(СтрокаВыгрузки.КоличествоROW) И СтрокаВыгрузки.КоличествоROW <> "0" Тогда  // многострочная часть row
					КоличествоНаЛисте = Число(СтрокаВыгрузки.КоличествоROW);
					НомерЗаписиНаЛисте = Неопределено;
					СтруктураПараметров.Свойство("НомерЗаписи", НомерЗаписиНаЛисте);
					КолСтр = Неопределено;
					СтруктураПараметров.Свойство("КоличествоГруппСтраниц", КолСтр);										
					Если СтруктураГруппы <> Неопределено Тогда
						 ТаблицаСтрокГруппы = СтруктураГруппы.Строки;						 					
						 // рассчитаем индекс строки и проверим есть ли такая строка в таблице данных
						 ИндексСтроки = НомерЗаписиНаЛисте + (КолСтр-1)* КоличествоНаЛисте - 1;
						 Если ИндексСтроки < ТаблицаСтрокГруппы.Количество() Тогда  // строк в таблице может быть меньше, чем выгружается в XML
							 Строка = ТаблицаСтрокГруппы.Получить(ИндексСтроки);
							 Если Строка <> Неопределено Тогда // найдена строка для выгрузки значения
								 Если ТаблицаСтрокГруппы.Колонки.Найти(ИмяЯчейки) <> Неопределено Тогда 
									 Значение = Строка[ИмяЯчейки];
									 // для числовых ячеек будем выгружать 0. Так как это обычно требуется в ФЛК суммовых полей
									 Значение = ПривестиЗначениеКФорматуСОНО(Значение, СтрокаВыгрузки.ВыгружатьНулевыеЗначения); 
					    		 	 Запись.ЗаписатьТекст(XMLСтрока(Значение));
								 КонецЕсли;
							 КонецЕсли;
						 КонецЕсли;
					КонецЕсли;
				Иначе // шапка или подвал
					Если СтруктураГруппы <> Неопределено Тогда
						 ОбщиеЭлементыГруппы = СтруктураГруппы.ШапкаИПодвал;
						 Строка = ОбщиеЭлементыГруппы.Найти(ИмяЯчейки,"ИмяОбласти");
						 Если Строка <> Неопределено Тогда
							 Значение = Строка.Значение;
							 Значение = ПривестиЗначениеКФорматуСОНО(Значение, СтрокаВыгрузки.ВыгружатьНулевыеЗначения); //СтрокаФорматов);
				    		 Запись.ЗаписатьТекст(XMLСтрока(Значение));
							 // Для формы 700.02 начиная с 2018 года
							 // итоговые суммы заполняются только для первой страницы.
							 // В связи с этим добавлена очистка итогов после заполнения первой страницы.
							 Если СтрНайти(СтрокаВыгрузки.КодФормы, "Форма700_02") > 0 Тогда
								 СтрокаГод = ОбщиеЭлементыГруппы.Найти("Год", "ИмяПараметра");
								 Если СтрокаГод <> Неопределено Тогда
									 ЗначениеГод = СтрокаГод.Значение;
								 Иначе
									 ЗначениеГод = Неопределено;
								 КонецЕсли;
								 Если ЗначениеГод <> Неопределено И ЗначениеГод >= 2018 Тогда
									 Если СтрНайти(СтрокаВыгрузки.КодФормы, "Форма700_02") > 0
										И (СтрНайти(СтрокаВыгрузки.ИмяЯчейки, "_P") > 0
											ИЛИ СтрНайти(СтрокаВыгрузки.ИмяЯчейки, "_S") > 0) Тогда
										Строка.Значение = 0;
									КонецЕсли;
								 КонецЕсли;
							 КонецЕсли;
						Иначе
							ОбщегоНазначения.СообщитьПользователю(СтрШаблон(НСтр("ru = 'Не найден в структуре хранения данных показатель %1 для формы %2'"), ИмяЯчейки, СтрокаВыгрузки.Форма));
							Значение = "";
						КонецЕсли;
					КонецЕсли;
				КонецЕсли;
			Иначе
				ТаблицаДанных = СтрокаВыгрузки.Значение;
				СтрокаОбласти = ТаблицаДанных.Найти(ИмяЯчейки,"ИмяОбласти");
				Если СтрокаОбласти <> Неопределено Тогда
					Значение = СтрокаОбласти.Значение;
					Значение = ПривестиЗначениеКФорматуСОНО(Значение, СтрокаВыгрузки.ВыгружатьНулевыеЗначения); //СтрокаФорматов);
				    Запись.ЗаписатьТекст(XMLСтрока(Значение));
				Иначе
					ОбщегоНазначения.СообщитьПользователю(СтрШаблон(НСтр("ru = 'Не найдена ячейка ""%1"" для выгрузки значения в XML!'"), ИмяЯчейки));
				КонецЕсли;
			КонецЕсли;
		Иначе
			// Если приложение 100.01 не заполнено, то запишем номер страниц "001"
			Если Найти(СтрокаВыгрузки.ИмяФормы, "form_100") И ИмяЯчейки = "НомерСтраницы" Тогда
				КолСтр = Неопределено;
				СтруктураПараметров.Свойство("КоличествоГруппСтраниц", КолСтр);
				Запись.ЗаписатьТекст(XMLСтрока(Формат(КолСтр,"ЧЦ=3; ЧВН=")));
			КонецЕсли;

		КонецЕсли;		
	КонецЕсли;
	Запись.ЗаписатьКонецЭлемента();			// </field>

КонецПроцедуры // ЗаписатьЗначениеЭлемента300()

//Выгружает данные отчета в формат XML
// Параметры:
//   ИмяФайла - файл, куда будет идти запись текста XML.
//   Объект - объект регламентированного отчета.
//
Функция ВыгрузитьОтчетВXMLДляСОНО(Объект, ВыдаватьСообщение = Истина, ПрефиксФормы = Неопределено) Экспорт
	
    Если ПрефиксФормы = Неопределено Тогда
		Префикс = Прав(Объект.мВыбраннаяФорма,7);
	Иначе
		Префикс = ПрефиксФормы;
	КонецЕсли;
	
	ИмяВременногоФайла = ПолучитьИмяВременногоФайла("tmp");
	
	// запишем общие атрибуты (code, version) и создадим элемент form
	Запись = Новый ЗаписьXML;		
	Запись.ОткрытьФайл(ИмяВременногоФайла,"UTF-8");
	Запись.ЗаписатьОбъявлениеXML();
	
	// Запишем корневой элемент
	Запись.ЗаписатьНачалоЭлемента("fno");
	
	МакетВыгрузки = Объект.РеквизитФормыВЗначение("ОтчетОбъект").ПолучитьМакет("ВыгрузкаВXML");

	ТаблОбщиеРеквизиты = Новый ТаблицаЗначений;
	ТаблОбщиеРеквизиты.Колонки.Добавить("ИмяАтрибута");
	ТаблОбщиеРеквизиты.Колонки.Добавить("ЗначениеАтрибута");
	
	ОбластьОбщихРеквизитов = МакетВыгрузки.Область("ОбщиеРеквизиты" + Префикс);
	Для Ном = ОбластьОбщихРеквизитов.Верх По ОбластьОбщихРеквизитов.Низ Цикл
		Строка = ТаблОбщиеРеквизиты.Добавить();
		Строка.ИмяАтрибута 		  = СокрП(МакетВыгрузки.Область(Ном, 1).Текст);
		Строка.ЗначениеАтрибута   = СокрП(МакетВыгрузки.Область(Ном, 2).Текст);		
	КонецЦикла;                           	
	
	// Запишем атрибуты корневого элемента
	Для Каждого Строка Из ТаблОбщиеРеквизиты Цикл
		Запись.ЗаписатьАтрибут(Строка.ИмяАтрибута,Строка.ЗначениеАтрибута);			  
	КонецЦикла;
	
	// создадим таблицу для выгрузки
	ТаблицаВыгрузки = Новый ТаблицаЗначений;
	ТаблицаВыгрузки.Колонки.Добавить("Форма");
	ТаблицаВыгрузки.Колонки.Добавить("Страница");
	ТаблицаВыгрузки.Колонки.Добавить("ИмяАтрибута");
	ТаблицаВыгрузки.Колонки.Добавить("ИмяЯчейки");
	ТаблицаВыгрузки.Колонки.Добавить("КоличествоROW");
	ТаблицаВыгрузки.Колонки.Добавить("ИмяФормы");
	ТаблицаВыгрузки.Колонки.Добавить("ИмяЛиста");
	ТаблицаВыгрузки.Колонки.Добавить("Отображение");
		
	ТаблицаВыгрузки.Колонки.Добавить("КодФормы");
	ТаблицаВыгрузки.Колонки.Добавить("Выгружать");
	ТаблицаВыгрузки.Колонки.Добавить("Многострочность");
	ТаблицаВыгрузки.Колонки.Добавить("ЗаголовокФормы"); 
	ТаблицаВыгрузки.Колонки.Добавить("КоличествоНаЛисте");    
	ТаблицаВыгрузки.Колонки.Добавить("Значение"); 
   	ТаблицаВыгрузки.Колонки.Добавить("ВыгружатьНулевыеЗначения");    
	
	ОбластьВыгрузки = МакетВыгрузки.Область("Выгрузка" + Префикс);
	СписокФормБезИерархии = Объект.РеквизитФормыВЗначение("мСписокФормБезИерархии");
	ТекущееИмяФормы = Неопределено;
	Для Ном = ОбластьВыгрузки.Верх По ОбластьВыгрузки.Низ Цикл
		Строка = ТаблицаВыгрузки.Добавить();
		Строка.Форма 	       			= СокрП(МакетВыгрузки.Область(Ном, 1).Текст);
		Строка.Страница        			= СокрП(МакетВыгрузки.Область(Ном, 2).Текст);		
		Строка.ИмяАтрибута     			= СокрП(МакетВыгрузки.Область(Ном, 3).Текст);		
		Строка.ИмяЯчейки      	 		= СокрП(МакетВыгрузки.Область(Ном, 4).Текст);		
		Строка.КоличествоROW   			= СокрП(МакетВыгрузки.Область(Ном, 5).Текст);		
		Строка.ИмяФормы        			= СокрП(МакетВыгрузки.Область(Ном, 6).Текст);		
		Строка.ИмяЛиста        			= СокрП(МакетВыгрузки.Область(Ном, 7).Текст);		
		Строка.Отображение     			= СокрП(МакетВыгрузки.Область(Ном, 8).Текст);		
        
  		Строка.ВыгружатьНулевыеЗначения  = ?(СокрП(МакетВыгрузки.Область(Ном, 9).Текст) = "1", Истина, Ложь);		

		НовоеИмяФормы = Строка.ИмяФормы;
		Если НовоеИмяФормы <> ТекущееИмяФормы Тогда
			Форма = СписокФормБезИерархии.Строки.Найти(Строка.ИмяФормы, "ИмяФормы");
		КонецЕсли;
		Если Форма <> Неопределено Тогда
			Строка.КодФормы  		 = Форма.КодФормы;
			Строка.Выгружать  		 = Форма.Выгружать;
			Строка.Многострочность   = Форма.Многострочность;
			Строка.ЗаголовокФормы    = Форма.ЗаголовокФормы;
			Строка.КоличествоНаЛисте = Форма.КоличествоНаЛисте;
			Строка.Значение  		 = Форма.Значение;			
		КонецЕсли;
		ТекущееИмяФормы = Строка.имяФормы;
	КонецЦикла;                           	
	
	// выгрузка в XML 
	КоличествоСтрокВТаблице = ТаблицаВыгрузки.Количество();
	НомерСтроки = 0;
	
	ТекущаяФорма = Неопределено;
	ТекСтраница = Неопределено;
	
	Пока Истина Цикл
		Если НомерСтроки >= КоличествоСтрокВТаблице Тогда
			Прервать;
		КонецЕсли; 
		ВыгрузитьСтрокуВXML(Объект, Запись, ТаблицаВыгрузки, КоличествоСтрокВТаблице, НомерСтроки, ТекущаяФорма, ТекСтраница);			
		НомерСтроки = НомерСтроки + 1;                                                                                      		
	КонецЦикла;
	
	Запись.ЗаписатьКонецЭлемента();		// </sheet>
	Запись.ЗаписатьКонецЭлемента();		// </sheetGroup>
	Запись.ЗаписатьКонецЭлемента();		// </form> 	
	Запись.ЗаписатьКонецЭлемента();     // fno
		
	Запись.Закрыть();
	
	// данный текст модуля добавлен для совместимости с СОНО (в СОНО для UTF-8 нет BOM поля)
	ТекстДок = Новый ТекстовыйДокумент;
    ТекстДок.Прочитать(ИмяВременногоФайла,"windows-1251");
    Строка = ТекстДок.ПолучитьСтроку(1);
    ТекстДок.ЗаменитьСтроку(1,Прав(Строка,СтрДлина(Строка)-3));
    ВыбФайл = Новый Файл(ИмяВременногоФайла);
    ТекстДок.Записать(ВыбФайл.Путь + ВыбФайл.ИмяБезРасширения + ВыбФайл.Расширение,"windows-1251");
	
	АдресХранилища = ПоместитьВоВременноеХранилище(новый ДвоичныеДанные(ИмяВременногоФайла));
	Если ВыдаватьСообщение Тогда    		
		//выдаем пользователю сообщение о конце выгрузки
		РегламентированнаяОтчетностьКлиентСервер.ВыдатьОтветПриВыгрузке();
	КонецЕсли;
	
	УдалитьФайлы(ИмяВременногоФайла);
	
	Возврат АдресХранилища
КонецФункции // ВыгрузкаОтчетаВXMLДляСОНО()

//////////////////////////////////////////////////////////////////////////////////
///ПРОЦЕДУРЫ ПЕЧАТИ

Процедура ЗаполнитьПечатныеЛисты(ТекФорма, Форма)
	
	Перем СтруктураГруппы;
	
	ФормаВСпискеБезИерархии = РегламентированнаяОтчетностьКлиентСервер.НайтиСтрокуДерева(Форма.мСписокФормБезИерархии, Новый Структура("КодФормы",ТекФорма.КодФормы));
	Если ФормаВСпискеБезИерархии = Неопределено Тогда
		Возврат;
	КонецЕсли; 
	
	Стр = 1;
	ИдентификаторТекФормы = Новый УникальныйИдентификатор();
	ИмяПанелиФормы = "Панель" + ТекФорма.КодФормы;
	Если Не ТекФорма.Многострочность Тогда
		
		Для Каждого Страница Из Форма.Элементы[ИмяПанелиФормы].ПодчиненныеЭлементы Цикл
			ТабДок = Новый ТабличныйДокумент;
			ИмяСтраницыБезПрефиксаПанели =  СтрЗаменить(Страница.Имя, ИмяПанелиФормы, ""); // ИмяСтраницыБезПерфиксаПанели
			
			ИмяОбласти = ИмяСтраницыБезПрефиксаПанели;
			ТекПТД = ТекФорма.КодФормы + "ПолеТабличногоДокумента" + ИмяСтраницыБезПрефиксаПанели;
			
			Если Форма[ТекПТД].Области.Найти(ИмяОбласти) = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			ТекОбласть = Форма[ТекПТД].ПолучитьОбласть(ИмяОбласти);
			ТабДок.Вывести(ТекОбласть);	
			
			Если ТекФорма.ОриентацияСтр = "Портрет" Тогда
				ТабДок.ОриентацияСтраницы = ОриентацияСтраницы.Портрет;
			Иначе
				ТабДок.ОриентацияСтраницы = ОриентацияСтраницы.Ландшафт;
			КонецЕсли;   
			
			ТабДок.ЧерноБелаяПечать = Ложь;
			ТабДок.АвтоМасштаб 		= Истина;
			
			Значение = Новый Массив;
			Значение.Добавить(ТабДок);
			Значение.Добавить(ИдентификаторТекФормы);
			Значение.Добавить(ТекФорма.ЗаголовокФормы);
			
			Форма.СтруктураРеквизитовФормы.мПечатныеФормы.Добавить(Значение, Страница.Заголовок);
		КонецЦикла;
	Иначе
		
		Попытка
			ГодФормирования = Год(Форма.СтруктураРеквизитовФормы.мДатаНачалаПериодаОтчета);
		Исключение
			ГодФормирования = 0;
		КонецПопытки;
		
		Пока Стр <  ФормаВСпискеБезИерархии.ВсегоСтраниц + 1 Цикл		 
			Для Каждого Страница Из Форма.Элементы[ИмяПанелиФормы].ПодчиненныеЭлементы Цикл
				
				ИмяСтраницыБезПрефиксаПанели =  СтрЗаменить(Страница.Имя, ИмяПанелиФормы, ""); // ИмяСтраницыБезПерфиксаПанели
			
				Если ТекФорма.КодФормы = "Форма300_05" И ИмяСтраницыБезПрефиксаПанели = "ЛистA" И Стр > 1 И ГодФормирования < 2020 Тогда
					Продолжить;
				КонецЕсли;	
		
				ТабДок = Новый ТабличныйДокумент;
				
				ИмяГруппы = ИмяСтраницыБезПрефиксаПанели;
				
				мМногострочнаяСтруктура = ПолучитьМногострочнуюСтруктуру(Форма, ТекФорма.КодФормы);
				мМногострочнаяСтруктура.Свойство(ИмяГруппы, СтруктураГруппы);
				
				Если ТекФорма.КодФормы = "Форма300_05" Тогда
					Стр2 = Стр;
					ВывестиРазделВТабличныйДокументФормы(Форма, Стр2, ИмяГруппы, СтруктураГруппы, ТекФорма.КодФормы, ФормаВСпискеБезИерархии.ВсегоСтраниц);
				Иначе	
					ВывестиРазделВТабличныйДокументФормы(Форма, Стр, ИмяГруппы, СтруктураГруппы, ТекФорма.КодФормы, ФормаВСпискеБезИерархии.ВсегоСтраниц);
				КонецЕсли;	
				
				ТекущееТабПоле = ТекФорма.КодФормы + "ПолеТабличногоДокумента" + ИмяГруппы;
				ТабДок.Вывести(Форма[ТекущееТабПоле]);
				
				Если ТекФорма.ОриентацияСтр = "Портрет" Тогда
					ТабДок.ОриентацияСтраницы = ОриентацияСтраницы.Портрет;
				Иначе
					ТабДок.ОриентацияСтраницы = ОриентацияСтраницы.Ландшафт;
				КонецЕсли;
				
				ТабДок.АвтоМасштаб        = Истина;
				ТабДок.ЧерноБелаяПечать   = Ложь;
				
				Значение = Новый Массив;
				Значение.Добавить(ТабДок);
				Значение.Добавить(ИдентификаторТекФормы);
				Значение.Добавить(ТекФорма.ЗаголовокФормы);
			 					
	           Форма.СтруктураРеквизитовФормы.мПечатныеФормы.Добавить(Значение, СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Лист %1. %2'"), Стр, Страница.Заголовок)); 
				
			КонецЦикла;
			Стр = Стр + 1;		 
		КонецЦикла;
		
		ВывестиСтраницуМногострочнойФормы(Форма);
	КонецЕсли;
	
КонецПроцедуры

Процедура ДобавитьВСписокПечатаемыйЛист(ЭлементыСпискаДерева, Форма, ТекФормаРодителя, ВерхнийУровень)
	
	КодФормы = Форма.КодФормы;
	
	Для Каждого СтрокаУровня1 Из ЭлементыСпискаДерева Цикл
			
		Если СтрокаУровня1.ВыводНаПечать = 0 Тогда
			Продолжить;
		КонецЕсли;
		       			
		Если СтрокаУровня1.КодФормы = КодФормы ИЛИ (КодФормы = ВерхнийУровень.КодФормы 
			ИЛИ (СтрокаУровня1 = ТекФормаРодителя И ТекФормаРодителя <> ВерхнийУровень)) Тогда 
			ЗаполнитьПечатныеЛисты(СтрокаУровня1, Форма);		
		КонецЕсли;     		
		
		ПодчиненныеСтроки = СтрокаУровня1.ПолучитьЭлементы();
		
		Если ПодчиненныеСтроки.Количество() > 0 Тогда
			
			ДобавитьВСписокПечатаемыйЛист(ПодчиненныеСтроки, Форма, ТекФормаРодителя, ВерхнийУровень)
				
		КонецЕсли;
		
	КонецЦикла;
	

КонецПроцедуры

Процедура СформироватьСписокПечатаемыхЛистов(Форма)	 Экспорт
		
	ЭлементыСпискаДерева = Форма.СписокФормДерева.ПолучитьЭлементы();
	ТекФорма = РегламентированнаяОтчетностьКлиентСервер.НайтиСтрокуДерева(Форма.СписокФормДерева, Новый Структура("КодФормы",Форма.КодФормы));
	Если Не ТекФорма = Неопределено Тогда
		ТекФормаРодителя     = ТекФорма.ПолучитьРодителя();
	Иначе
		ТекФормаРодителя     = Неопределено;
	КонецЕсли;
			
	ВерхнийУровень       = ЭлементыСпискаДерева[0];

	ДобавитьВСписокПечатаемыйЛист(ЭлементыСпискаДерева, Форма, ТекФормаРодителя, ВерхнийУровень);
	
	НомераЛистов = Новый СписокЗначений;
		
	Для Каждого Эл Из Форма.СтруктураРеквизитовФормы.мПечатныеФормы Цикл
				
		Значение = Новый Массив;
		Значение.Добавить(ПоместитьВоВременноеХранилище(Эл.Значение[0], Форма.УникальныйИдентификатор));
		Значение.Добавить(Эл.Значение[1]);
		Значение.Добавить(Эл.Значение[2]);
		
		Форма.СтруктураРеквизитовФормы.СписокПечатаемыхЛистов.Добавить(Значение, Эл.Представление);			
		
	КонецЦикла;
	
	Форма.СтруктураРеквизитовФормы.мПечатныеФормы.Очистить();
	          
КонецПроцедуры


/////////////////////////////////////////////////////////////////////////
//ПОДКЛЮЧЕНИЕ ВНЕШНИХ ОТЧЕТОВ

Функция ПодключитьВнешнийРеглОтчет(Ссылка) Экспорт
	
	// Проверка корректности переданных параметров
	Если ТипЗнч(Ссылка) <> Тип("СправочникСсылка.РегламентированныеОтчеты") 
		ИЛИ Ссылка = Справочники.РегламентированныеОтчеты.ПустаяСсылка() Тогда
		Возврат Неопределено;
	КонецЕсли;
		
	// Подключение
	#Если ТолстыйКлиентОбычноеПриложение Тогда
		ИмяОбработки = ПолучитьИмяВременногоФайла();
		ДвоичныеДанные = Ссылка.ВнешнийОтчетХранилище.Получить();
		ДвоичныеДанные.Записать(ИмяОбработки);
		Возврат ИмяОбработки;
	#КонецЕсли
	
	Менеджер = ВнешниеОтчеты;
		
	АдресВоВременномХранилище = ПоместитьВоВременноеХранилище(Ссылка.ВнешнийОтчетХранилище.Получить());
	
	ИмяОбработки = Менеджер.Подключить(АдресВоВременномХранилище, , Ложь);
	
	Возврат ИмяОбработки;
	
КонецФункции



////////////////////////////////////////////////////////////////////////
// Процедуры и функции для работы в фоновом режиме

Функция ПолучитьТаблицуРасшифровкиВФоне(ФормаСтруктура, КодФормы = Неопределено) Экспорт
	
	мСтруктураМногострочныхРазделов = ФормаСтруктура.мСтруктураМногострочныхРазделов;
	
	Если КодФормы = Неопределено Тогда
		КодФормы = ФормаСтруктура.КодФормы;
	КонецЕсли;
	
	Строка = мСтруктураМногострочныхРазделов.Строки.Найти(КодФормы, "КодФормы");
	
	Возврат Строка.ТаблицаРасшифровки;
	
КонецФункции

// Процедура обеспечивает передачу данных и в поле табличного документа, и в 
// структуру хранения данных для обычных форм и для многострочных форм
// для реквизитов шапки, итога и подвала по именам параметров в макете
//
// Параметры:       Форма - форма регламентированного отчета
//                  КодФормы - имя формы передаваемой или код формы
//                  ИмяОбласти - имя области поля табличного документа
//                  Значение - значение
//                  ПередаватьВТабличноеПоле - отображать ли переданное значение на форме
//                  ПередаватьВМногострочнуюЧасть - значение передается во все строки Таблиц строк каждой группы
//  
Процедура ПередатьЗначениеВСтруктуруВФоне(ФормаСтруктура, КодФормы, ИмяОбласти, Значение = "", ПередаватьВТабличноеПоле = Истина, ПередаватьВМногострочнуюЧасть = Ложь, ПараметрРасшифровкиСтроки = Неопределено) Экспорт
	
	СписокФормБезИерархии = ФормаСтруктура.мСписокФормБезИерархии;
	
	НайденнаяСтрока = СписокФормБезИерархии.Строки.Найти(КодФормы,"КодФормы");
	
	ТаблицаДанных = НайденнаяСтрока.Значение;
	
	Если НайденнаяСтрока.Многострочность = 1 Тогда
		// параметр ИмяОбласти выступает в качестве параметра		
		мСтруктураМногострочныхРазделов = ФормаСтруктура.мСтруктураМногострочныхРазделов;
		МногострочнаяСтруктура = мСтруктураМногострочныхРазделов.Строки.Найти(КодФормы,"КодФормы");
		Для Каждого СтруктураГруппы Из МногострочнаяСтруктура.Строки Цикл			
			Если НЕ ПередаватьВМногострочнуюЧасть Тогда
				ОбщиеЭлементыГруппы = СтруктураГруппы.ОбщиеЭлементыГруппы;
				СтруктураПоиска = Новый Структура("ИмяПараметра",ИмяОбласти);
				Строки = ОбщиеЭлементыГруппы.НайтиСтроки(СтруктураПоиска);
				Если Строки.Количество() <> 0 Тогда
					Для каждого Строка Из Строки Цикл
						Строка.Значение = Значение;					
					КонецЦикла;                                             
				КонецЕсли;							
			Иначе
				ТаблицаСтрокГруппы = ФормаСтруктура[СтруктураГруппы.ИмяРеквизитаТаблицыСтрокГруппы];
				Если ТаблицаСтрокГруппы.Колонки.Найти(ИмяОбласти) <> Неопределено Тогда
					Для Каждого Строка Из ТаблицаСтрокГруппы Цикл
						Строка[ИмяОбласти] = Значение;
						Если ЗначениеЗаполнено(ПараметрРасшифровкиСтроки) Тогда
							Строка[ИмяОбласти + "_Расшифровка"] = ПараметрРасшифровкиСтроки;
						КонецЕсли;						
					КонецЦикла;
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
		
		//Форма.ЗначениеВРеквизитФормы(мСтруктураМногострочныхРазделов, "мСтруктураМногострочныхРазделов");
		
		Если ПередаватьВТабличноеПоле Тогда	
			//ПередатьДанныеИзСтруктурыВТабличноеПоле(Форма, КодФормы);
		КонецЕсли;				
		
	Иначе // обычная форма
		
		Строка = ТаблицаДанных.Найти(ИмяОбласти,"ИмяОбласти");
		Если Строка <> Неопределено Тогда
			Строка.Значение = Значение;
		Иначе
			ОбщегоНазначения.СообщитьПользователю(СтрШаблон(НСтр("ru = 'В структуре формы ""%1"" не найдена область ""%2"".'"), КодФормы, ИмяОбласти));
		КонецЕсли;
		
		Если ПередаватьВТабличноеПоле Тогда
			// передаем значение из структуры в табличное поле, если в данный момент активна форма под именем "КодФормы"			
			//ИмяПанелиФормы = "Панель" + КодФормы;
			//Для Каждого Страница Из Форма.Элементы[ИмяПанелиФормы].ПодчиненныеЭлементы  Цикл
			//	ИмяСтраницыБезПрефиксаПанели =  СтрЗаменить(Страница.Имя, ИмяПанелиФормы, ""); // ИмяСтраницыБезПерфиксаПанели
			//	ТекПоле = Форма[КодФормы + "ПолеТабличногоДокумента" + ИмяСтраницыБезПрефиксаПанели];				
			//	ТекОбласть = ТекПоле.Области.Найти(ИмяОбласти);
			//	Если ТекОбласть <> Неопределено Тогда 
			//		Если ТекОбласть.СодержитЗначение Тогда
			//			ТекОбласть.Значение = Значение;
			//		Иначе
			//			ТекОбласть.Текст = Значение;
			//		КонецЕсли;
			//		//Прервать; 
			//	КонецЕсли;
			//КонецЦикла;			
		КонецЕсли;
	КонецЕсли;
	
КонецПроцедуры

Функция ПолучитьМногострочнуюСтруктуруВФоне(ФормаСтруктура, ТекущееИмяФормы = Неопределено) Экспорт            
	
	Если ТекущееИмяФормы = Неопределено тогда
		ТекущееИмяФормы = ФормаСтруктура.КодФормы;
	КонецЕсли;	
	
	мСтруктураМногострочныхРазделов = ФормаСтруктура.мСтруктураМногострочныхРазделов;
									   
	МногострочнаяСтруктура = Новый Структура;
	СтрокаФормы = мСтруктураМногострочныхРазделов.Строки.Найти(ТекущееИмяФормы,"КодФормы");	
	Если СтрокаФормы = Неопределено Тогда
		Возврат Неопределено
	КонецЕсли;	
	
	Для Каждого СтрокаДанных Из СтрокаФормы.Строки Цикл
		ДанныеСтраницы = Новый Структура;
		ДанныеСтраницы.Вставить("ШапкаИПодвал", СтрокаДанных.ОбщиеЭлементыГруппы);		
		ДанныеСтраницы.Вставить("Строки",       ФормаСтруктура[СтрокаДанных.ИмяРеквизитаТаблицыСтрокГруппы]);
		ДанныеСтраницы.Вставить("ИмяРеквизитаТаблицыСтрокГруппы", СтрокаДанных.ИмяРеквизитаТаблицыСтрокГруппы);
		
		МногострочнаяСтруктура.Вставить(СтрокаДанных.ИмяГруппы, ДанныеСтраницы);
	КонецЦикла;		
		
	Возврат МногострочнаяСтруктура;
	
КонецФункции

Функция ПолучитьТаблицуДанныхОбычнойФормыВФоне(ФормаСтруктура, КодФормы) Экспорт
	
	СтрокаФормы = ФормаСтруктура.мСписокФормБезИерархии.Строки.Найти(КодФормы, "КодФормы");
	ТаблицаДанных = СтрокаФормы.Значение;
	
	Возврат ТаблицаДанных;
	
КонецФункции
